{"searchDocs":[{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/API-Routes-Middleware/example-code","content":"Example Code You may download the sample code for this topic here: API-Routes-Middleware","keywords":"","version":"Next"},{"title":"\"API\" Routes Introduction","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/API-Routes-Middleware/api-routes-intro","content":"","keywords":"","version":"Next"},{"title":"Route Definitions​","type":1,"pageTitle":"\"API\" Routes Introduction","url":"/WebProgrammingForAppsAndServices/API-Routes-Middleware/api-routes-intro#route-definitions","content":" If you open the &quot;hello.js&quot; file, you will see some code that looks very similar to how routes are defined in &quot;Express&quot;, ie:  File: &quot;pages/api/hello.js&quot;  export default function handler(req, res) { res.status(200).json({ name: 'John Doe' }); }   ","version":"Next","tagName":"h2"},{"title":"'req' and 'res'​","type":1,"pageTitle":"\"API\" Routes Introduction","url":"/WebProgrammingForAppsAndServices/API-Routes-Middleware/api-routes-intro#req-and-res","content":" You will see that both &quot;req&quot; and &quot;res&quot; objects are available to the exported callback function in order to give us access to the HTTP request / response. However, it is important to note that these are not the same as the &quot;Request&quot; and &quot;Response&quot; objects provided by &quot;Express&quot;, though they serve the same purpose.  Additionally, &quot;middleware&quot; functions have been built in to parse the incoming request, which gives the &quot;req&quot; object the following additional properties:  req.cookies - An object containing the cookies sent by the request. Defaults to req.query - An object containing the query string. Defaults to &quot; - Note: route parameter values also included. req.body - An object containing the body parsed by content-type, or null if no body was sent  Similarly, some &quot;helper functions&quot; have been made available on the &quot;res&quot; object to provide additional functionality. These are similar to what is offered by &quot;Express&quot;:  res.status(code) - A function to set the status code. code must be a valid HTTP status code res.json(body) - Sends a JSON response. body must be a serializable object res.send(body) - Sends the HTTP response. body can be a string, an object or a Buffer res.redirect([status,] path) - Redirects to a specified path or URL. status must be a valid HTTP status code. If not specified, status defaults to &quot;307&quot; &quot;Temporary redirect&quot;. res.revalidate(urlPath) - Revalidate a page on demand using getStaticProps. urlPath must be a string.  ","version":"Next","tagName":"h3"},{"title":"HTTP Methods​","type":1,"pageTitle":"\"API\" Routes Introduction","url":"/WebProgrammingForAppsAndServices/API-Routes-Middleware/api-routes-intro#http-methods","content":" At the moment, the &quot;hello&quot; API route responds to &quot;GET&quot; requests only. If we wish to extend this to match other HTTP methods (ie: &quot;POST&quot;), we can leverage the &quot;method&quot; property of the &quot;req&quot; object:  export default function handler(req, res) { const { method } = req; switch (method) { case 'GET': res.status(200).json({ name: 'John Doe' }); break; case 'POST': // return the 'name' value provided in the body of the rquest res.status(200).json({ name: req.body.name }); break; default: // send an error message back, indicating that the method is not supported by this route res.setHeader('Allow', ['GET', 'POST']); res.status(405).end(`Method ${method} Not Allowed`); } }   ","version":"Next","tagName":"h3"},{"title":"Dynamic Routes​","type":1,"pageTitle":"\"API\" Routes Introduction","url":"/WebProgrammingForAppsAndServices/API-Routes-Middleware/api-routes-intro#dynamic-routes","content":" As with regular routing, API routes may also contain &quot;route parameters&quot;. These must be defined in a similar way, in that they must exist in their own .js file with the desired route parameter as the file name. For example, if we wish to match the route &quot;/api/users/id&quot; (where id is the unknown parameter), we would crate the following file:  File: &quot;/pages/api/users/[id].js&quot;  export default function handler(req, res) { const { id } = req.query; // &quot;id&quot; route parameter res.status(200).json({ name: `user ${id}` }); }   If we wish to reference the route parameter in the route definition, it can be accessed using req.query.  ","version":"Next","tagName":"h3"},{"title":"Web API Structure​","type":1,"pageTitle":"\"API\" Routes Introduction","url":"/WebProgrammingForAppsAndServices/API-Routes-Middleware/api-routes-intro#web-api-structure","content":" Using the above techniques, it is possible to create routes that match that of a typical Web API. For example, consider the following files:  File: &quot;/pages/api/users/index.js&quot;  export default function handler(req, res) { const { name } = req.body; const { method } = req; switch (method) { case 'GET': // Read data from your database res.status(200).json({ message: `TODO: Get All Users` }); break; case 'POST': // Create data in your database res.status(200).json({ message: `TODO: Create User with Name: ${name}` }); break; default: res.setHeader('Allow', ['GET', 'POST']); res.status(405).end(`Method ${method} Not Allowed`); } }   File: &quot;/pages/api/users/[id].js&quot;  export default function handler(req, res) { const { id } = req.query; const { name } = req.body; const { method } = req; switch (method) { case 'GET': // Read data from your database res.status(200).json({ message: `TODO: Get User with id: ${id} ` }); break; case 'PUT': // Update data in your database res.status(200).json({ message: `TODO: Update User with id: ${id} - Set Name: ${name}` }); break; case 'DELETE': // Delete data in your database res.status(200).json({ message: `TODO: Delete User with id: ${id}` }); break; default: res.setHeader('Allow', ['GET', 'PUT', 'DELETE']); res.status(405).end(`Method ${method} Not Allowed`); } }   Here, we have accounted for each of the major operations, ie:  Route\tHTTP Method\tDescription/api/users\tGET\tGet all the users /api/users\tPOST\tCreate a user /api/users/:id\tGET\tGet a single user /api/users/:id\tPUT\tUpdate a user with new information /api/users/:id\tDELETE\tDelete a user  ","version":"Next","tagName":"h2"},{"title":"Using MongoDB (Mongoose)​","type":1,"pageTitle":"\"API\" Routes Introduction","url":"/WebProgrammingForAppsAndServices/API-Routes-Middleware/api-routes-intro#using-mongodb-mongoose","content":" If we wish to extend the API structure to work with real data (ie: using MongoDB Atlas), we can use the familiar &quot;Mongoose&quot; ODM.  To get started, install it as a dependency:  npm install mongoose   Next, since the database connection will be shared in multiple files (ie: &quot;/pages/api/users/[id].js&quot; and &quot;/pages/api/users/index.js&quot;), we should place the database model and connection logic in a separate file (or files) somewhere within our project folder. Since this code is not responsible for rendering a specific route or component, we will create a new &quot;lib&quot; folder and place it there:  File: lib/dbUtils.js  import mongoose from 'mongoose'; const userSchema = new mongoose.Schema({ name: { type: String, required: true, unique: true, }, }); mongoose.models = {}; export const UserModel = mongoose.model('users', userSchema); export async function mongooseConnect() { if (mongoose.connections[0].readyState) { return true; } try { await mongoose.connect(`Your MongoDB Connection String Here`); return true; } catch (err) { throw new Error(err); } }   You can see from the above code, that we are exporting both the UserModel and the mongooseConnect() function to be used in our API routes. You will also notice that we have created our &quot;Schema&quot; and reset the &quot;models&quot; before defining the &quot;UserModel&quot; (failing to do so may result in an &quot;OverwriteModelError&quot;, ie: &quot;Cannot overwrite 'users' model once compiled.&quot;).  Additionally, you will notice that our &quot;mongooseConnect()&quot; function checks to see if our connection is in a &quot;ready&quot; state. If this property is falsy ie: 0, then our connection is disconnected and we must create a new connection using &quot;mongoose.connect()&quot;. If the &quot;.readystate&quot; property is truthy, then this function does not need to create a new connection and simply returns true.  With our &quot;dbUtils.js&quot; file complete, we can focus on adding the remainder of the CRUD Operations to our API routes, specifically:  File: &quot;/pages/api/users/index.js&quot;  import { UserModel, mongooseConnect } from '@/lib/dbUtils'; export default async function handler(req, res) { const { name } = req.body; const { method } = req; try { await mongooseConnect(); switch (method) { case 'GET': let users = await UserModel.find().exec(); res.status(200).json(users); break; case 'POST': const newUser = new UserModel({ name: name }); await newUser.save(); res.status(200).json({ message: `User: ${name} Created` }); break; default: res.setHeader('Allow', ['GET', 'POST']); res.status(405).end(`Method ${method} Not Allowed`); } } catch (err) { res.status(500).json({ message: err.message }); } }   File: &quot;/pages/api/users/[id].js&quot;  import { UserModel, mongooseConnect } from '@/lib/dbUtils'; export default async function handler(req, res) { const { id } = req.query; const { name } = req.body; const { method } = req; try { await mongooseConnect(); switch (method) { case 'GET': let users = await UserModel.find({ _id: id }).exec(); res.status(200).json(users[0]); break; case 'PUT': await UserModel.updateOne({ _id: id }, { $set: { name: name } }).exec(); res.status(200).json({ message: `User with id: ${id} updated` }); break; case 'DELETE': await UserModel.deleteOne({ _id: id }).exec(); res.status(200).json({ message: `Deleted User with id: ${id}` }); break; default: res.setHeader('Allow', ['GET', 'PUT', 'DELETE']); res.status(405).end(`Method ${method} Not Allowed`); } } catch (err) { res.status(500).json({ message: err.message }); } }   In both files, we wait for mongooseConnect() to complete (either creating a connection, or reusing the current one) before we use the &quot;UserModel&quot; to perform our operations. ","version":"Next","tagName":"h2"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Authentication-In-Next/example-code","content":"Example Code You may download the sample code for this topic here: Authentication-In-Next","keywords":"","version":"Next"},{"title":"Middleware","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/API-Routes-Middleware/middleware","content":"","keywords":"","version":"Next"},{"title":"Getting Started​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingForAppsAndServices/API-Routes-Middleware/middleware#getting-started","content":" To see how middleware in Next.js is implemented, create a &quot;middleware.js&quot; file within the root of your application folder (ie: &quot;my-app/middleware.js&quot;):  File: /middleware.js  export function middleware(request) { console.log('requested: ', request.url); }   info If the middleware does not modify the response (discussed further down), you do not need to explicitly return or invoke a .next() method. Next.js will automatically continue processing the request.  If you test the server now and navigate to the default route &quot;/&quot;, you will see that the middleware function has been executed once for every resource sent from our local server (http://localhost:3000) for the &quot;/&quot; page:  requested: http://localhost:3000/vercel.svg requested: http://localhost:3000/next.svg requested: http://localhost:3000/_next/static/media/2aaf0723e720e8b9-s.p.woff2 requested: http://localhost:3000/_next/static/chunks/react-refresh.js?ts=1693361554048 requested: http://localhost:3000/_next/static/chunks/main.js?ts=1693361554048 requested: http://localhost:3000/_next/static/chunks/webpack.js?ts=1693361554048 requested: http://localhost:3000/_next/static/chunks/pages/_app.js?ts=1693361554048 requested: http://localhost:3000/_next/static/development/_buildManifest.js?ts=1693361554048 requested: http://localhost:3000/_next/static/chunks/pages/index.js?ts=1693361554048 requested: http://localhost:3000/_next/static/development/_ssgManifest.js?ts=1693361554048 requested: http://localhost:3000/_next/static/development/_devMiddlewareManifest.json requested: http://localhost:3000/_next/static/development/_devPagesManifest.json requested: http://localhost:3000/favicon.ico requested: http://localhost:3000/vercel.svg requested: http://localhost:3000/next.svg   We are able to access the &quot;url&quot; property on the &quot;request&quot; object, because request is technically an instance of &quot;NextRequest&quot;, which itself, is an extension of the native &quot;Request&quot; object.  ","version":"Next","tagName":"h2"},{"title":"Matching Paths​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingForAppsAndServices/API-Routes-Middleware/middleware#matching-paths","content":" Now that we know that the &quot;middleware&quot; function is behaving correctly (ie: invoked as a part of the request / response cycle - before the request is completed), we should consider only applying it to certain paths, such as pages or api routes. To achieve this, we must update our &quot;middleware.js&quot; file to also export a &quot;config&quot; object with a &quot;matcher&quot; property:  export const config = { matcher: '/', };   In the above case, having a matcher value of &quot;/&quot; will restrict the middleware function to only run on the &quot;/&quot; route. If we open the console with the current configuration, we will only see:  requested: http://localhost:3000/   ","version":"Next","tagName":"h2"},{"title":"Multiple Paths​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingForAppsAndServices/API-Routes-Middleware/middleware#multiple-paths","content":" Say we have a second route: &quot;/about&quot; that we would also like to match. This can be done by passing an array of matchers to the &quot;matcher&quot; property:  export const config = { matcher: ['/', '/about'], };   ","version":"Next","tagName":"h3"},{"title":"Nested Paths (Wildcard)​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingForAppsAndServices/API-Routes-Middleware/middleware#nested-paths-wildcard","content":" There are many cases where we have nested paths, such as &quot;/api/users&quot;. In addition to matching &quot;/api/users&quot;, we may want to match all &quot;/api/users&quot; routes, such as &quot;/api/users/123&quot;. This can be done using the :path* (which will also match routes such as &quot;/api/users/a/b/c&quot;):  export const config = { matcher: ['/api/users/:path*'], };   info The matcher config allows full regex so matching like negative lookaheads or character matching is supported. For example: '/((?!api|_next/static|_next/image|favicon.ico).*)' will match all request paths except for the ones starting with: api (API routes)_next/static (static files)_next/image (image optimization files)favicon.ico (favicon file) Next.js Docs - &quot;matcher&quot;  ","version":"Next","tagName":"h3"},{"title":"Conditionally​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingForAppsAndServices/API-Routes-Middleware/middleware#conditionally","content":" Finally, we may wish to perform different actions depending on which path is matched. In this case, we do not include the &quot;matcher&quot; config, and instead rely on the &quot;request&quot; parameter. Recall: this is an instance of &quot;NextRequest&quot;, which gives us access to the &quot;nextUrl&quot; property, which itself includes &quot;an extended, parsed, URL object that gives you access to Next.js specific properties such as pathname, basePath, trailingSlash and i18n&quot;. This appears to be exactly what we need (i.e. manually examine the pathname and respond with the intended logic):  export function middleware(request) { if (request.nextUrl.pathname.startsWith('/about')) { console.log('Visiting About'); } if (request.nextUrl.pathname.startsWith('/api/users')) { console.log('Visiting the Users API'); } }   ","version":"Next","tagName":"h3"},{"title":"Practical Examples​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingForAppsAndServices/API-Routes-Middleware/middleware#practical-examples","content":" Now that we are able to add middleware functionality to a certain route / set of routes, let's see what kind of practical benefits this provides.  info When using middleware, we have access to a &quot;NextResponse&quot; object from &quot;next/server&quot; (ie: import { NextResponse } from 'next/server';). Using this object, we can perform some useful actions from our middleware, such as: redirect the incoming request to a different URLrewrite the response by displaying a given URLSet request headers for API Routes, getServerSideProps, and rewrite destinationsSet response cookiesSet response headers  ","version":"Next","tagName":"h2"},{"title":"Using Cookies​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingForAppsAndServices/API-Routes-Middleware/middleware#using-cookies","content":" As we know, a &quot;cookie&quot; is a small chunk of data that is sent by a server and stored in the client's web browser using the header &quot;Set-Cookie&quot;. Similarly, the data is automatically sent from the client back to the server, using the &quot;Cookie&quot; header, often used to manage session information. In Next.js we can implement this functionality in our middleware functions by using the &quot;cookies&quot; property on both the request (&quot;NextRequest&quot;) and response (&quot;NextResponse&quot;) objects.  In the below example, we have two routes: &quot;/setCookie&quot; (which is expecting a query parameter: &quot;message&quot;) and &quot;/getCookie&quot;. When the middleware matches the &quot;/setCookie&quot; route, it reads the query parameter &quot;message&quot; and adds it to the &quot;Set-Cookie&quot; response header. If the middleware matches the &quot;/getCookie&quot; route, it simply outputs the &quot;message&quot; cookie value to the console. It uses the &quot;next()&quot; function to continue routing:  import { NextResponse } from 'next/server'; export function middleware(request) { const response = NextResponse.next(); if (request.nextUrl.pathname.startsWith('/setCookie')) { let cookieMessage = request.nextUrl.searchParams.get('message'); response.cookies.set('message', cookieMessage); } if (request.nextUrl.pathname.startsWith('/getCookie')) { let cookie = request.cookies.get('message'); console.log(cookie); } return response; }   info We can also manually set headers using response.headers.set(), ie: response.headers.set('x-hello-from-middleware', 'hello');   ","version":"Next","tagName":"h3"},{"title":"URL Rewrites​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingForAppsAndServices/API-Routes-Middleware/middleware#url-rewrites","content":" It may also be beneficial to map a specific path in Next.js to a different one, either temporarily (ie: during testing or development of a new bug fix / feature) or permanently depending on a condition such as the users language preference. This is possible using URL &quot;rewrites&quot;:  Rewrites allow you to map an incoming request path to a different destination path. Rewrites act as a URL proxy and mask the destination path, making it appear the user hasn't changed their location on the site. In contrast, redirects will reroute to a new page and show the URL changes.  For example, the following code will check the &quot;Accept-Language&quot; header value for the existence of &quot;fr&quot;. If it is found, the url will be &quot;rewritten&quot; to the &quot;/fr/about&quot; route. To the user, they will still be at &quot;/about&quot;, but the page rendered will be from &quot;/fr/about&quot;  import { NextResponse } from 'next/server'; export function middleware(request) { const language = request.headers.get('Accept-Language'); if (language.includes('fr')) { return NextResponse.rewrite(new URL('/fr/about', request.url)); } } export const config = { matcher: ['/about'], };  ","version":"Next","tagName":"h3"},{"title":"Authentication (Logging In)","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Authentication-In-Next/authentication-logging-in","content":"","keywords":"","version":"Next"},{"title":"Obtaining & Running the “vehicles-UI” Example​","type":1,"pageTitle":"Authentication (Logging In)","url":"/WebProgrammingForAppsAndServices/Authentication-In-Next/authentication-logging-in#obtaining--running-the-vehicles-ui-example","content":" As a starting point download the Example Code, extract the files and open the &quot;vehicles-UI&quot; folder in Visual Studio Code. You will notice that this folder contains a my-app folder with the code for a Next.js app with two pages: &quot;Home&quot; (index.js) and &quot;Vehicles&quot; (vehicles.js).  Before we can run this app however, we must first:  Ensure that the completed example from Introduction to JWT (ie: &quot;simple-API-complete&quot;) is currently running on port 8080. Open the &quot;vehicles-UI/my-app&quot; folder in the integrated terminal for Visual Studio code and execute the command &quot;npm install&quot; to obtain the dependencies  With the dependencies installed and node_modules rebuilt, we can now start up our app with &quot;npm run dev&quot;. You will see that we only have two routes available to the user: “Home” and “Vehicles”. If we try to access the “Vehicles” route, we will not see any data due to a 401 - Unauthorized error returned from our “simple-API-complete” (this can be confirmed in the browser console).  info This sample app makes use of the UI components from React Bootstrap. This was accomplished by installing &quot;react-bootstrap&quot; and &quot;bootstrap&quot; from NPM and adding the following &quot;import&quot; statement in &quot;_app.js&quot;: import 'bootstrap/dist/css/bootstrap.min.css';   ","version":"Next","tagName":"h2"},{"title":"Building an \"Authentication\" Library​","type":1,"pageTitle":"Authentication (Logging In)","url":"/WebProgrammingForAppsAndServices/Authentication-In-Next/authentication-logging-in#building-an-authentication-library","content":" Since we will be handling authentication and working with JWT, it makes the most sense to have all of our “Authentication” related code in one place. For this example, we will be creating a new folder under &quot;/my-app&quot; called &quot;lib&quot;. Within the &quot;lib&quot; folder, create a file called &quot;authenticate.js&quot;. Within this file, we will place code that is responsible for:  Executing a &quot;POST&quot; request using &quot;fetch()&quot; to the &quot;api/login&quot; route of our server with a given user / password. Storing / Removing the obtained JWT locally Reading the contents of the JWT Determining whether or not the user is “authenticated” after logging in  ","version":"Next","tagName":"h2"},{"title":"Function: authenticateUser()​","type":1,"pageTitle":"Authentication (Logging In)","url":"/WebProgrammingForAppsAndServices/Authentication-In-Next/authentication-logging-in#function-authenticateuser","content":" The first function that we will create in &quot;authenticate.js&quot; is called &quot;authenticateUser&quot; and will attempt to obtain a JWT from our &quot;simple-API-complete&quot; server at the route &quot;/api/login&quot;, given a specific user and password. This function must be &quot;async&quot; since it's making use of the asynchronous &quot;fetch()&quot; function. Additionally, it must only store the token locally if the status code from &quot;/api/login&quot; is 200, otherwise the function must throw a new Error, with the error message sent from the API:  export async function authenticateUser(user, password) { const res = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/login`, { method: 'POST', body: JSON.stringify({ userName: user, password: password }), headers: { 'content-type': 'application/json', }, }); const data = await res.json(); if (res.status === 200) { setToken(data.token); return true; } else { throw new Error(data.message); } }   Notice the url used in the &quot;fetch&quot; call references &quot;process.env.NEXT_PUBLIC_API_URL&quot;. The value for this constant is provided in the &quot;/my-app/.env&quot; file:  NEXT_PUBLIC_API_URL=&quot;http://localhost:8080/api&quot;   info Environment variables in Next.js use the following naming convention: .env: Defines environment variables, to be loaded in code using &quot;process.env&quot; (this is true for all .env files).env.local: Defines &quot;secrets&quot; (tokens, etc) and is meant to be excluded from your code repository (ie: added to .gitignore).env.development: Defines environment variables to be used in the development environment.env.production: Defines environment variables to be used in the production environment.env.test: Defines environment variables to be used in the test environment Additionally, in order to make your environment variables available in the browser, they must be prefixed with the text NEXT_PUBLIC_ as in our example: &quot;NEXT_PUBLIC_API_URL&quot;.  ","version":"Next","tagName":"h3"},{"title":"Function: setToken()​","type":1,"pageTitle":"Authentication (Logging In)","url":"/WebProgrammingForAppsAndServices/Authentication-In-Next/authentication-logging-in#function-settoken","content":" This function is designed explicitly to store the token. It is used by the above &quot;authenticateUser&quot; as well as elsewhere through our application:  function setToken(token) { localStorage.setItem('access_token', token); }   You will notice that in this case, we have chosen to persist the token using &quot;localStorage&quot; with the key &quot;access_token&quot;  Local Storage​  From MDN:  The localStorage read-only property of the window interface allows you to access a Storage object for the Document's origin; the stored data is saved across browser sessions.  Essentially, we are storing the value of the token in the browser for retrieval at a later date / time. This is in contrast to keeping it stored in memory, as we do not wish for the user to be logged out if the page is refreshed and the app is reloaded.  To view all values currently stored in &quot;localStorage&quot; (as well as &quot;sessionStorage&quot; &quot;cookies&quot;, etc.) using Chrome, you can access the dev tools and open the &quot;Application&quot; tab. You will find the values under &quot;Storage&quot;:    ","version":"Next","tagName":"h3"},{"title":"Function: getToken()​","type":1,"pageTitle":"Authentication (Logging In)","url":"/WebProgrammingForAppsAndServices/Authentication-In-Next/authentication-logging-in#function-gettoken","content":" Similar to &quot;setToken()&quot; above, this function is designed explicitly to retrieve the token from &quot;localStorage&quot; using getItem(). If the token does not exist, this function returns null:  export function getToken() { try { return localStorage.getItem('access_token'); } catch (err) { return null; } }   In this case, we place the &quot;getItem()&quot; call within a try / catch block. This helps us deal with the possibility of encountering &quot;ReferenceError: localStorage is not defined&quot; when a page / pages using getToken() are pre-rendered by Next.js.  ","version":"Next","tagName":"h3"},{"title":"Function: removeToken()​","type":1,"pageTitle":"Authentication (Logging In)","url":"/WebProgrammingForAppsAndServices/Authentication-In-Next/authentication-logging-in#function-removetoken","content":" This is the final function that works directly with &quot;localStorage&quot; - it simply removes the token from localStorage using removeItem().  export function removeToken() { localStorage.removeItem('access_token'); }   ","version":"Next","tagName":"h3"},{"title":"Function: readToken()​","type":1,"pageTitle":"Authentication (Logging In)","url":"/WebProgrammingForAppsAndServices/Authentication-In-Next/authentication-logging-in#function-readtoken","content":" The purpose of the readToken() function is to obtain the payload from the JWT (This is the data that was digitally signed on our server, ie: &quot;_id&quot; and &quot;userName&quot;). This is accomplished by first retrieving the token from localStorage (using getToken()), followed by reading the token using &quot;jwtDecode&quot; (available from npm and installed using &quot;npm i jwt-decode&quot;):  import { jwtDecode } from 'jwt-decode'; // ... export function readToken() { try { const token = getToken(); return token ? jwtDecode(token) : null; } catch (err) { return null; } }   ","version":"Next","tagName":"h3"},{"title":"Function: isAuthenticated()​","type":1,"pageTitle":"Authentication (Logging In)","url":"/WebProgrammingForAppsAndServices/Authentication-In-Next/authentication-logging-in#function-isauthenticated","content":" The final function defined within our &quot;authenticate.js&quot; lib, serves to determine whether or not the current user is &quot;authenticated&quot;. In this case, we simply attempt to read the token (readToken()). If a value is returned, return true otherwise, return false. This will be used primarily to determine whether or not a user is allowed to proceed to a specific route / page.  export function isAuthenticated() { const token = readToken(); return token ? true : false; }   ","version":"Next","tagName":"h3"},{"title":"Creating a \"Login\" Page​","type":1,"pageTitle":"Authentication (Logging In)","url":"/WebProgrammingForAppsAndServices/Authentication-In-Next/authentication-logging-in#creating-a-login-page","content":" With our &quot;authenticate.js&quot; lib complete, we can now concentrate on implementing a User Interface which enables users to enter their credentials and attempt to &quot;log in&quot; (acquire the JWT).  To begin, we will create a login.js file within the &quot;pages&quot; directory.  ","version":"Next","tagName":"h2"},{"title":"Form Components​","type":1,"pageTitle":"Authentication (Logging In)","url":"/WebProgrammingForAppsAndServices/Authentication-In-Next/authentication-logging-in#form-components","content":" Since we're using &quot;React Bootstrap&quot;, we can leverage some of their components to make a login form that matches the rest of the site:  import { Card, Form, Button } from &quot;react-bootstrap&quot;; export default function Login(props){ return ( &lt;&gt; &lt;Card bg=&quot;light&quot;&gt; &lt;Card.Body&gt;&lt;h2&gt;Login&lt;/h2&gt;Enter your login information below:&lt;/Card.Body&gt; &lt;/Card&gt; &lt;br /&gt; &lt;Form&gt; &lt;Form.Group&gt; &lt;Form.Label&gt;User:&lt;/Form.Label&gt;&lt;Form.Control type=&quot;text&quot; id=&quot;userName&quot; name=&quot;userName&quot; /&gt; &lt;/Form.Group&gt; &lt;br /&gt; &lt;Form.Group&gt; &lt;Form.Label&gt;Password:&lt;/Form.Label&gt;&lt;Form.Control type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; /&gt; &lt;/Form.Group&gt; &lt;br /&gt; &lt;Button variant=&quot;primary&quot; className=&quot;pull-right&quot; type=&quot;submit&quot;&gt;Login&lt;/Button&gt; &lt;/Form&gt; &lt;/&gt; ); }   ","version":"Next","tagName":"h3"},{"title":"Capturing User Input​","type":1,"pageTitle":"Authentication (Logging In)","url":"/WebProgrammingForAppsAndServices/Authentication-In-Next/authentication-logging-in#capturing-user-input","content":" During the initial discussion on Forms in React, the concept of &quot;Controlled Components&quot; was first introduced, followed closely by &quot;React Hook Form&quot;. While it was established that React Hook Form is an excellent alternative to &quot;Controlled Components&quot; (in terms of flexibility, ease of use, etc.), it is not required in this case. This is because we only have two simple input fields and all error messages related to logging in come from the API, so client-side validation is not strictly necessary.  Recall, to capture form data using &quot;Controlled Components&quot;, we must include:  Form field values within the &quot;state&quot;:  import { useState } from 'react'; // ... const [user, setUser] = useState(''); const [password, setPassword] = useState('');   A Function to handle form submissions:  function handleSubmit(e) { e.preventDefault(); console.log('TODO: Submit Form'); }   Updated form fields to synchronize with the &quot;state&quot; values (implemented by adding a &quot;value&quot; property and an &quot;onChange&quot; event):  &lt;Form.Control type=&quot;text&quot; value={user} id=&quot;userName&quot; name=&quot;userName&quot; onChange={e =&gt; setUser(e.target.value)} /&gt; &lt;Form.Control type=&quot;password&quot; value={password} id=&quot;password&quot; name=&quot;password&quot; onChange={e =&gt; setPassword(e.target.value)} /&gt;   Update the &quot;Form&quot; component to use the &quot;onSubmit&quot; event:  &lt;Form onSubmit={handleSubmit}&gt; &lt;/form&gt;   If we apply all of these changes to our form, we should have the following code. When the form is submitted, the values for user and password are available in the state:  import { Card, Form, Button } from &quot;react-bootstrap&quot;; import { useState } from 'react'; export default function Login(props){ const [user, setUser] = useState(&quot;&quot;); const [password, setPassword] = useState(&quot;&quot;); function handleSubmit(e) { e.preventDefault(); console.log(`TODO: Submit Form with: ${user} / ${password}`) } return ( &lt;&gt; &lt;Card bg=&quot;light&quot;&gt; &lt;Card.Body&gt;&lt;h2&gt;Login&lt;/h2&gt;Enter your login information below:&lt;/Card.Body&gt; &lt;/Card&gt; &lt;br /&gt; &lt;Form onSubmit={handleSubmit}&gt; &lt;Form.Group&gt; &lt;Form.Label&gt;User:&lt;/Form.Label&gt;&lt;Form.Control type=&quot;text&quot; value={user} id=&quot;userName&quot; name=&quot;userName&quot; onChange={e =&gt; setUser(e.target.value)} /&gt; &lt;/Form.Group&gt; &lt;br /&gt; &lt;Form.Group&gt; &lt;Form.Label&gt;Password:&lt;/Form.Label&gt;&lt;Form.Control type=&quot;password&quot; value={password} id=&quot;password&quot; name=&quot;password&quot; onChange={e =&gt; setPassword(e.target.value)} /&gt; &lt;/Form.Group&gt; &lt;br /&gt; &lt;Button variant=&quot;primary&quot; className=&quot;pull-right&quot; type=&quot;submit&quot;&gt;Login&lt;/Button&gt; &lt;/Form&gt; &lt;/&gt; ); }   ","version":"Next","tagName":"h3"},{"title":"Authenticating the User / Showing Errors​","type":1,"pageTitle":"Authentication (Logging In)","url":"/WebProgrammingForAppsAndServices/Authentication-In-Next/authentication-logging-in#authenticating-the-user--showing-errors","content":" The final piece for our &quot;Login&quot; component is to make use of &quot;authenticate.js&quot; to actually authenticate the user with the data entered in the form. If the user enters correct credentials, we will redirect them to the &quot;/vehicles&quot; route, however if invalid credentials have been entered, we must show an error message to the user. This will involve:  Including the &quot;authenticateUser&quot; function from our &quot;authenticate.js&quot; lib as well as the &quot;useRouter&quot; hook from &quot;next/router&quot;:  import { authenticateUser } from '@/lib/authenticate'; import { useRouter } from 'next/router';   Adding a &quot;warning&quot; string in the &quot;state&quot; to display a login error to the user (if applicable) as well as invoking the &quot;useRouter&quot; hook to get an instance of &quot;router&quot;  const [warning, setWarning] = useState(''); const router = useRouter();   Updating &quot;handleSubmit&quot; to use &quot;authenticateUser&quot; and update &quot;warning&quot; if it fails or redirect to &quot;/vehicles&quot; if it succeeds:  async function handleSubmit(e) { e.preventDefault(); try { await authenticateUser(user, password); router.push('/vehicles'); } catch (err) { setWarning(err.message); } }   Adding an &quot;Alert&quot; Component and conditionally showing the warning message:  import { Card, Form, Alert, Button } from 'react-bootstrap'; // ... { warning &amp;&amp; ( &lt;&gt;&lt;br /&gt;&lt;Alert variant=&quot;danger&quot;&gt;{warning}&lt;/Alert&gt;&lt;/&gt; )}   ","version":"Next","tagName":"h2"},{"title":"Adding an \"Authorization\" Header to SWR​","type":1,"pageTitle":"Authentication (Logging In)","url":"/WebProgrammingForAppsAndServices/Authentication-In-Next/authentication-logging-in#adding-an-authorization-header-to-swr","content":" If we test the app at this point, we should see that our &quot;/login&quot; page correctly shows errors, as well as redirects to &quot;/vehicles&quot; when appropriate (credentials have been accepted). You can also verify that the token has been correctly added as &quot;access_token&quot; in local storage.  The only piece missing is ensuring that the &quot;access_token&quot; (JWT) is correctly added to an &quot;Authorization&quot; header, when making a request for vehicles from our API.  At the moment, the code to make a request in &quot;pages/vehicles.js&quot; currently looks like:  const fetcher = (url) =&gt; fetch(url).then((res) =&gt; res.json()); //... const { data, error } = useSWR(`${process.env.NEXT_PUBLIC_API_URL}/vehicles`, fetcher);   We do not have any code to specify a header, nor do we have any way of accessing the token from local_storage within this component.  This can be easily fixed however, by updating the &quot;fetcher&quot; function:  import { getToken } from &quot;@/lib/authenticate&quot;; // ... const fetcher = (url) =&gt; fetch(url, { headers: { Authorization: `JWT ${getToken()}` }}).then((res) =&gt; res.json());   If we test the route now, we should see that the correct header has been added to our request and we can indeed see the vehicles rendered on the page. ","version":"Next","tagName":"h2"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Bootstrap-UI-Implementation/example-code","content":"Example Code You may download the sample code for this topic here: Bootstrap-UI-Implementation","keywords":"","version":"Next"},{"title":"UI Considerations","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Authentication-In-Next/UI-considerations","content":"","keywords":"","version":"Next"},{"title":"Creating a \"Route Guard\" Component​","type":1,"pageTitle":"UI Considerations","url":"/WebProgrammingForAppsAndServices/Authentication-In-Next/UI-considerations#creating-a-route-guard-component","content":" To address the first issue (unauthorized access to the &quot;vehicles&quot; page), we will create a component that functions in a similar way to &quot;Layout&quot;, in that it will be placed in App (_app.js) and &quot;wrap&quot; &lt;Component {...pageProps} /&gt;. The purpose of this component is to only render &quot;props.children&quot; if the user has been authenticated and is allowed to view the requested route.  To begin, create a new component in the &quot;components&quot; folder called: &quot;RouteGuard&quot; and add it to _app.js  File: &quot;/components/RouteGuard.js&quot;  export default function RouteGuard(props) { return &lt;&gt;{props.children}&lt;/&gt; }   File: &quot;/pages/_app.js&quot;  import 'bootstrap/dist/css/bootstrap.min.css'; import Layout from '@/components/Layout'; import RouteGuard from '@/components/RouteGuard'; export default function App({ Component, pageProps }) { return &lt;RouteGuard&gt;&lt;Layout&gt;&lt;Component {...pageProps} /&gt;&lt;/Layout&gt;&lt;/RouteGuard&gt; }   At the moment, this will not have any effect. However, with the component correctly positioned within our app, we can discuss how we can correctly add the desired functionality to the guard.  ","version":"Next","tagName":"h2"},{"title":"Redirecting to \"/login\" if unauthenticated​","type":1,"pageTitle":"UI Considerations","url":"/WebProgrammingForAppsAndServices/Authentication-In-Next/UI-considerations#redirecting-to-login-if-unauthenticated","content":" If we wish to send the user to the &quot;/login&quot; route if they try to access a route without being authenticated first, we need to ensure that the following logic is in place for our route guard:  Maintains a list of &quot;public&quot; routes, ie: &quot;/login&quot;, &quot;/&quot; and &quot;/_error&quot; (Next.js uses the path &quot;/_error&quot; internally when rendering the &quot;404 | This page could not be found&quot; error). Ability to check the url of the current (requested) route and compare it against the above list Check to see if the user is currently authenticated Redirect to &quot;/login&quot; if unauthenticated / render props.children if the user is authenticated  authCheck() Function​  To implement these requirements, we should first construct a function called &quot;authCheck&quot; that checks the requested route and compares it against the &quot;public&quot; routes.  const PUBLIC_PATHS = ['/login', '/', '/_error']; // ... function authCheck(url) { const path = url.split('?')[0]; if (!PUBLIC_PATHS.includes(path)) { console.log(`trying to request a secure path: ${path}`); } }   Here, we define constant list of &quot;PUBLIC_PATHS&quot; as '/login', '/' and '/_error'. We also remove any query parameters from the url by splitting the string at &quot;?&quot; and taking the first half.  If the PUBLIC_PATHS array does not include the requested route, output a message to the console indicating that a secure path is being accessed.  invoking authCheck()​  To correctly invoke authCheck() we must execute it:  When the component is first mounted: using the useEffect() hook When a client-side route change has completed: using the 'routeChangeComplete' router event info Router Events in Next.js can be &quot;subscribed&quot; to by using the &quot;events.on&quot; properties of the &quot;router&quot; object (obtained from the useRouter() hook), for example: router.events.on('routeChangeComplete', (url) =&gt; { console.log(`route change to ${url} complete!`); }); When no longer needed, the event can be &quot;unsubscribed&quot; to by using: router.evnts.off()  To ensure that authCheck() is correctly invoked in both of the above scenarios, we can update our RouteGuard component to use the following code:  import { useRouter } from 'next/router'; import { useState, useEffect } from 'react'; const PUBLIC_PATHS = ['/login', '/', '/_error']; export default function RouteGuard(props) { const router = useRouter(); useEffect(() =&gt; { // on initial load - run auth check authCheck(router.pathname); // on route change complete - run auth check router.events.on('routeChangeComplete', authCheck); // unsubscribe from events in useEffect return function return () =&gt; { router.events.off('routeChangeComplete', authCheck); }; }, []); function authCheck(url) { const path = url.split('?')[0]; if (!PUBLIC_PATHS.includes(path)) { console.log(`trying to request a secure path: ${path}`); } } return &lt;&gt;{props.children}&lt;/&gt; }   With this code in place for RouteGuard, we should see &quot;trying to request a secure path /vehicles&quot; if we try to refresh the &quot;/vehicles&quot; page or navigate to it using the navigation bar.  Adding Authentication &amp; Redirection​  To complete the RouteGuard functionality, we must implement logic to check whether or not the user is logged in. We can use this to either alow access to the requested route (by rendering &quot;props.children&quot;), or redirect the user back to &quot;/login&quot; (using router.push(&quot;/login&quot;);).  First, we should add a value in the state to store whether or not the user has been authorized to view the protected routes. We can use this to conditionally render &quot;props.children&quot;, as described above:  const [authorized, setAuthorized] = useState(false); // ... return &lt;&gt;{authorized &amp;&amp; props.children}&lt;/&gt;   Next, we must add the ability to check if a user has been authenticated and if so, set &quot;authorized&quot; to true, so that the route may be rendered. However, if the user has not been authenticated, we can set &quot;authorized&quot; to false and redirect the user back to &quot;/login&quot;. This can be achieved by importing the &quot;isAuthenticated()&quot; function from our &quot;authenticate&quot; lib, as well as updating our &quot;authCheck&quot; function:  import { isAuthenticated } from '@/lib/authenticate'; // ... function authCheck(url) { // redirect to login page if accessing a private page and not logged in const path = url.split('?')[0]; if (!isAuthenticated() &amp;&amp; !PUBLIC_PATHS.includes(path)) { setAuthorized(false); router.push('/login'); } else { setAuthorized(true); } }   Here, we make sure to only redirect to &quot;/login&quot; if the user has not been authenticated and they are trying to access a restricted route. If they are not authenticated and try to access an unrestricted route (ie: a route defined in &quot;PUBLIC_PATHS&quot;), then they should be allowed to proceed.  ","version":"Next","tagName":"h3"},{"title":"Updating the Navigation Component​","type":1,"pageTitle":"UI Considerations","url":"/WebProgrammingForAppsAndServices/Authentication-In-Next/UI-considerations#updating-the-navigation-component","content":" With our Route Guard in place and successfully preventing unauthorized users from viewing the &quot;/vehicles&quot; page, we an concentrate on the last piece of our UI: Updating the &quot;Navigation&quot; Component. Here, we will show a welcome message, ie &quot;Welcome userName&quot; as well as only show the &quot;Vehicles&quot; link if the user has logged in. Additionally, we will replace the &quot;login&quot; link with a &quot;logout&quot; link.  The first thing we must do is add the &quot;readToken&quot; and &quot;removeToken&quot; functions from our &quot;authenticate&quot; lib as well as &quot;useRouter&quot; from &quot;next/router&quot;:  import { readToken, removeToken } from '@/lib/authenticate'; import { useRouter } from 'next/router';   We will use this within the component to:  Store the current value of the token:  let token = readToken();   Implement a &quot;logout&quot; function that removes the token and redirects the user back to &quot;/&quot;:  const router = useRouter(); function logout() { removeToken(); router.push('/'); }   ","version":"Next","tagName":"h2"},{"title":"Updating the JSX​","type":1,"pageTitle":"UI Considerations","url":"/WebProgrammingForAppsAndServices/Authentication-In-Next/UI-considerations#updating-the-jsx","content":" Finally, with our token in place and our logout function implemented, we can make the following changes to our JSX code for the component to conditionally render text / elements using the &quot;token&quot; value:  return ( import Link from &quot;next/link&quot;; import { Navbar, Nav, Container } from &quot;react-bootstrap&quot;; &lt;Navbar bg=&quot;light&quot; expand=&quot;lg&quot;&gt; &lt;Container&gt; &lt;Navbar.Brand as={Link} href=&quot;/&quot;&gt;Vehicles UI {token &amp;&amp; &lt;&gt;- Welcome {token.userName}&lt;/&gt;}&lt;/Navbar.Brand&gt; &lt;Navbar.Toggle aria-controls=&quot;basic-navbar-nav&quot; /&gt; &lt;Navbar.Collapse id=&quot;basic-navbar-nav&quot;&gt; &lt;Nav className=&quot;me-auto&quot;&gt; &lt;Nav.Link as={Link} href=&quot;/&quot;&gt;Home&lt;/Nav.Link&gt; {token &amp;&amp; &lt;Nav.Link as={Link} href=&quot;/vehicles&quot;&gt;Vehicles&lt;/Nav.Link&gt;} &lt;/Nav&gt; &lt;Nav className=&quot;ml-auto&quot;&gt; {!token &amp;&amp; &lt;Nav.Link as={Link} href=&quot;/login&quot;&gt;Login&lt;/Nav.Link&gt;} {token &amp;&amp; &lt;Nav.Link onClick={logout}&gt;Logout&lt;/Nav.Link&gt;} &lt;/Nav&gt; &lt;/Navbar.Collapse&gt; &lt;/Container&gt; &lt;/Navbar&gt; );   Using the above code, we can ensure that once the user is logged in, they will see their user name as well as the &quot;vehicles&quot; and &quot;logout&quot; links in the navigation bar! ","version":"Next","tagName":"h3"},{"title":"Continuous Deployment","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Deployment-Automated-Testing/continuous-deployment","content":"","keywords":"","version":"Next"},{"title":"(Re)Introduction to Vercel​","type":1,"pageTitle":"Continuous Deployment","url":"/WebProgrammingForAppsAndServices/Deployment-Automated-Testing/continuous-deployment#reintroduction-to-vercel","content":" To add Continuous Deployment to our pipeline, we will leverage the excellent free services available from Vercel, the creators of Next.js.  To begin using Vercel, we must ensure that our code has been pushed to a public Git provider such as: GitHub, GitLab or BitBucket. If you have been following along with the Continuous Integration instructions, this should indeed be the case.  First, browse to https://vercel.com and hit the &quot;Start Deploying&quot; button. Next, press the &quot;Continue with GitHub&quot; button, since our code is located on GitHub. If you are not currently logged in to GitHub, you will need to provide your credentials in a pop-up window before continuing. Once you have logged in to GitHub, you will be taken to the Let's build something new. screen in Vercel, which prompts you to &quot;Import Git Repository&quot;. From here, you will need to click &quot;+ Add GitHub Account&quot;    This will prompt you to &quot;Install Vercel&quot;. From here, we would like to find our specific app, ie &quot;my-app&quot; on GitHub. You will need to start by clicking your account and choosing the &quot;Only select repositories&quot; and finding the &quot;my-app&quot; repository.    Once you have selected the target repository (ie: &quot;my-app&quot;), click the green Install button You should now see the my-app repository available for import. To proceed, click Import    At the next page, you are not required to make any changes, as Vercel should detect that we are using Next.js in the &quot;framework preset&quot;. If you had any environment variables, you could set them here. However, since we aren't currently using any environment variables, click Deploy. Once the deploy step has completed, you should be taken to a &quot;Congratulations!&quot; page with a black button labeled Go To Dashboard. Click this to see the information about your deployment.    From the dashboard, we are presented with some important information, primarily the &quot;Domains&quot; section, which shows the production URL of the app (in this case: my-app-lime-eight.vercel.app)  ","version":"Next","tagName":"h3"},{"title":"Updating the Production Site​","type":1,"pageTitle":"Continuous Deployment","url":"/WebProgrammingForAppsAndServices/Deployment-Automated-Testing/continuous-deployment#updating-the-production-site","content":" Now that we have a working site deployed on Vercel (ie: in &quot;Production&quot;), let's take a step back and see how we can use this pipeline to make an update:  For example, say we wish to append the text &quot;(Starter Site)&quot; to the &lt;title&gt;...&lt;title&gt; element of the &quot;Home&quot; page:  Create (and switch to) a new branch for this update.  git checkout -b fix/home-title   Update the code and save your changes, ie: File: &quot;pages/index.js&quot;  &lt;title&gt;Create Next App (Starter Site)&lt;/title&gt;   Commit your local changes:  git add . git commit -m &quot;appended text to title on Home&quot;   Push the &quot;fix/home-title&quot; branch to GitHub  git push origin fix/home-title   Preview Deployments​  If you navigate back to the dashboard for the Vercel app, you will see that we now have a &quot;Preview Deployment&quot;, generated from our push to the &quot;fix/home-title&quot; branch:    Effectively, this means that we have not altered our production site (my-app-lime-eight.vercel.app), but instead created a &quot;Preview&quot; of what the production site would look like with the change. In this case, this preview has been assigned the url &quot;my-jk1f8wunw-patrick-crawford.vercel.app&quot;.  As before, since we pushed a separate branch to our repository, GitHub gives an option to create a Pull Request. Once we do, we can confirm that Vercel has created the preview deployment and all of our tests passed:    If the &quot;Preview&quot; is approved, then we can proceed to merge the pull request. This will trigger a rebuild with Vercel and our production site will be updated to match the Preview.  As before, if you wish to update your local &quot;main&quot; branch with the fix, you can issue the commands:  git checkout main git pull origin main  ","version":"Next","tagName":"h3"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Deployment-Automated-Testing/example-code","content":"Example Code You may download the sample code for this topic here: Deployment-Automated-Testing","keywords":"","version":"Next"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Forms-Introduction/example-code","content":"Example Code You may download the sample code for this topic here: Forms-Introduction","keywords":"","version":"Next"},{"title":"Rendering Data","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Bootstrap-UI-Implementation/bootstrap-rendering-data","content":"","keywords":"","version":"Next"},{"title":"Dependencies​","type":1,"pageTitle":"Rendering Data","url":"/WebProgrammingForAppsAndServices/Bootstrap-UI-Implementation/bootstrap-rendering-data#dependencies","content":" Before we obtain the data and attempt to render it in the browser, we should first include any dependencies that are required. To begin, we will start with an HTML5 skeleton that includes Bootstrap 5.1  &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;!-- Bootstrap 5.1 CSS--&gt; &lt;link href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; integrity=&quot;sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3&quot; crossorigin=&quot;anonymous&quot; /&gt; &lt;!-- Bootstrap 5.1 JS Bundle --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js&quot; integrity=&quot;sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p&quot; crossorigin=&quot;anonymous&quot; &gt;&lt;/script&gt; &lt;title&gt;Bootstrap Practice&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt;   ","version":"Next","tagName":"h2"},{"title":"The Data​","type":1,"pageTitle":"Rendering Data","url":"/WebProgrammingForAppsAndServices/Bootstrap-UI-Implementation/bootstrap-rendering-data#the-data","content":" Next, it is a good idea to examine the data that we will be rendering on the page before using any other boilerplate code. For our purposes we will use the posts collection. This dataset provides the following functionality that we can use in our user interface:  https://jsonplaceholder.typicode.com/posts - This is a full list of &quot;Posts&quot; using the format:  { &quot;userId&quot;: 1, &quot;id&quot;: 1, &quot;title&quot;: &quot;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&quot;, &quot;body&quot;: &quot;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&quot; }   https://jsonplaceholder.typicode.com/posts?userId=3 - This is the same list filtered by &quot;userID&quot; (in this case userId=3) https://jsonplaceholder.typicode.com/posts/1 - This is the same list, filtered by &quot;id&quot; (in this case id=1) https://jsonplaceholder.typicode.com/comments?postId=1 - Here, we have all the comments for a given post (in this case postId=1) using the format:  { &quot;postId&quot;: 1, &quot;id&quot;: 1, &quot;name&quot;: &quot;id labore ex et quam laborum&quot;, &quot;email&quot;: &quot;Eliseo@gardner.biz&quot;, &quot;body&quot;: &quot;laudantium enim quasi est quidem magnam voluptate ipsam eos\\ntempora quo necessitatibus\\ndolor quam autem quasi\\nreiciendis et nam sapiente accusantium&quot; }   ","version":"Next","tagName":"h2"},{"title":"UI Elements​","type":1,"pageTitle":"Rendering Data","url":"/WebProgrammingForAppsAndServices/Bootstrap-UI-Implementation/bootstrap-rendering-data#ui-elements","content":" With the dependencies in place and the structure (&quot;shape&quot;) of the data known, we can begin to create the UI elements for our application.  ","version":"Next","tagName":"h2"},{"title":"Navbar​","type":1,"pageTitle":"Rendering Data","url":"/WebProgrammingForAppsAndServices/Bootstrap-UI-Implementation/bootstrap-rendering-data#navbar","content":" The best place to begin is with the navigation bar (navbar). Since it is possible to filter our data by &quot;userId&quot; let's create a navbar that also has a &quot;search&quot; bar:  &lt;nav class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Posts Dataset&lt;/a&gt; &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-bs-toggle=&quot;collapse&quot; data-bs-target=&quot;#navbarSupportedContent&quot; aria-controls=&quot;navbarSupportedContent&quot; aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot; &gt; &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=&quot;collapse navbar-collapse justify-content-end&quot; id=&quot;navbarSupportedContent&quot;&gt; &lt;form class=&quot;d-flex&quot; id=&quot;searchForm&quot;&gt; &lt;input class=&quot;form-control me-2&quot; type=&quot;search&quot; placeholder=&quot;User ID (Number)&quot; id=&quot;userId&quot; aria-label=&quot;Search&quot; /&gt; &lt;button class=&quot;btn btn-outline-success&quot; type=&quot;submit&quot;&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt;   Here, we have only included the &quot;navbar-brand&quot;, &quot;navbar-toggler&quot; / &quot;collapse&quot; and &quot;form&quot; elements. The form has been given an id of &quot;searchForm&quot; and the &quot;collapse&quot; &lt;div&gt; has been given an additional class &quot;justify-content-end&quot; to ensure that the search bar appears on the right of the navigation bar.  ","version":"Next","tagName":"h3"},{"title":"Main Container & Data Table​","type":1,"pageTitle":"Rendering Data","url":"/WebProgrammingForAppsAndServices/Bootstrap-UI-Implementation/bootstrap-rendering-data#main-container--data-table","content":" The primary display for our data will be in a table format. This will display all &quot;posts&quot; by including their &quot;userId&quot;, &quot;title&quot; and &quot;body&quot; attributes, ie:  &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col&quot;&gt; &lt;table class=&quot;table table-hover&quot; id=&quot;postsTable&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;User ID&lt;/th&gt; &lt;th&gt;Title&lt;/th&gt; &lt;th&gt;Body&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;&lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;   Notice how we have included a regular table with the classes &quot;table&quot; and &quot;table-hover&quot; as well as the id &quot;postsTable&quot;. This is where we will eventually render all of our &quot;Posts&quot; data from the API.  ","version":"Next","tagName":"h3"},{"title":"Modal Window​","type":1,"pageTitle":"Rendering Data","url":"/WebProgrammingForAppsAndServices/Bootstrap-UI-Implementation/bootstrap-rendering-data#modal-window","content":" Finally, we will include a &quot;modal&quot; window to show a specific post as well as the related comments. This window will be shown once a user clicks on a specific row of the table. For now, we will simply include the &quot;skeleton&quot; and update the contents on demand later:  &lt;div class=&quot;modal fade&quot; tabindex=&quot;-1&quot; id=&quot;commentsModal&quot;&gt; &lt;div class=&quot;modal-dialog&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;h5 class=&quot;modal-title&quot;&gt;Comments&lt;/h5&gt; &lt;button type=&quot;button&quot; class=&quot;btn-close&quot; data-bs-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt;&lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-secondary&quot; data-bs-dismiss=&quot;modal&quot;&gt;Close&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;   Here, we have given the &quot;modal&quot; an id of &quot;commentsModal&quot; as well as omitted the &quot;modal-body&quot; content. Lastly, since the user will not be entering any data, we have also omitted the &quot;Save Changes&quot; button  ","version":"Next","tagName":"h3"},{"title":"The JavaScript​","type":1,"pageTitle":"Rendering Data","url":"/WebProgrammingForAppsAndServices/Bootstrap-UI-Implementation/bootstrap-rendering-data#the-javascript","content":" The next step in the development effort is to start working with JavaScript to obtain and render the data to the table as well as make the table searchable and interactive. For this example, we will place our JavaScript logic within a &lt;script&gt; element on the same HTML page as the rest of the example, rather than using an external .js file:  &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;!-- Bootstrap 5.1 CSS--&gt; &lt;link href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; integrity=&quot;sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3&quot; crossorigin=&quot;anonymous&quot; /&gt; &lt;!-- Bootstrap 5.1 JS Bundle --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js&quot; integrity=&quot;sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p&quot; crossorigin=&quot;anonymous&quot; &gt;&lt;/script&gt; &lt;script&gt; // Custom JS - included beneath Bootstrap &lt;/script&gt; &lt;title&gt;Bootstrap Practice&lt;/title&gt; &lt;/head&gt;   ","version":"Next","tagName":"h2"},{"title":"Fetching and Rendering the Data​","type":1,"pageTitle":"Rendering Data","url":"/WebProgrammingForAppsAndServices/Bootstrap-UI-Implementation/bootstrap-rendering-data#fetching-and-rendering-the-data","content":" The first step here is to write a function that will actually pull the data from the API. This will be done using &quot;fetch()&quot;, in it's simplest form, ie:  function populatePostsTable(userId = null) { let url = +userId // attempt to convert userId to a number ? `https://jsonplaceholder.typicode.com/posts?userId=${+userId}` : `https://jsonplaceholder.typicode.com/posts`; fetch(url) .then((res) =&gt; res.json()) .then((data) =&gt; { console.log(data); }); }   For this function we have included a single parameter &quot;userId&quot;, which is set to a default value of null. This is because the URL that we fetch our data from will change depending on whether or not we have a numeric &quot;userId&quot; value. Also, we are not yet generating any HTML or updating the DOM - this is purely a test to ensure that the function works as expected.  Next, since we wish the table to show the data once the page is first loaded, we must execute this function when the &quot;DOM is Ready&quot; - if you are familiar with jQuery, this would be the $(function(){ ... }) function. However, since we have removed the dependency on jQuery, we can use the following code instead:  // Execute when the DOM is 'ready' document.addEventListener('DOMContentLoaded', function () { populatePostsTable(); populatePostsTable(4); // test with User ID 4 (to be removed after testing) });   info When loading an external JavaScript file (only), the &quot;defer&quot; attribute may be used on the &lt;script&gt; element to achieve the same result, ie: &lt;script src=&quot;script.js&quot; defer&gt;&lt;/script&gt;   Generating HTML​  Once we are confident that our &quot;populatePostsTable&quot; is functioning as expected, the next step is to take the returned data, ie:  [ { &quot;userId&quot;: 1, &quot;id&quot;: 1, &quot;title&quot;: &quot;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&quot;, &quot;body&quot;: &quot;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&quot; }, { &quot;userId&quot;: 1, &quot;id&quot;: 2, &quot;title&quot;: &quot;qui est esse&quot;, &quot;body&quot;: &quot;est rerum tempore vitae\\nsequi sint nihil reprehenderit dolor beatae ea dolores neque\\nfugiat blanditiis voluptate porro vel nihil molestiae ut reiciendis\\nqui aperiam non debitis possimus qui neque nisi nulla&quot; } ]   and transform it into HTML to be included in the DOM, ie:  &lt;tr data-id=&quot;1&quot;&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;&quot;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&quot;&lt;/td&gt; &lt;td&gt; &quot;quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto&quot; &lt;/td&gt; &lt;/tr&gt; &lt;tr data-id=&quot;2&quot;&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;&quot;qui est esse&quot;&lt;/td&gt; &lt;td&gt; &quot;est rerum tempore vitae\\nsequi sint nihil reprehenderit dolor beatae ea dolores neque\\nfugiat blanditiis voluptate porro vel nihil molestiae ut reiciendis\\nqui aperiam non debitis possimus qui neque nisi nulla&quot; &lt;/td&gt; &lt;/tr&gt;   This is where knowledge of Template literals will come in handy.  You will recall (from examples above / online) that the syntax for Template literals is the following:  `string text ${expression} string text`;   where &quot;expression&quot; is a valid JavaScript expression, ie: &quot;any valid unit of code that resolves to a value&quot;. Therefore, if our task is to loop through our array of results and generate HTML, we can use the map() method of an array within our &quot;expression&quot; to process the post objects one at a time and generate html.  To see this strategy in action, let's first try a simple example, where we take an array of strings and convert them to a single string showing the html for an unordered-list:  let numbers = ['one', 'two', 'three']; let numberList = `&lt;ul&gt;${numbers.map((num) =&gt; `&lt;li&gt;${num}&lt;/li&gt;`)}&lt;/ul&gt;`; console.log(numberList);   Ths should show the following in the console:  &lt;ul&gt;&lt;li&gt;one&lt;/li&gt;,&lt;li&gt;two&lt;/li&gt;,&lt;li&gt;three&lt;/li&gt;&lt;/ul&gt;   This is very close, however you will notice that we have unnecessary commas (&quot;,&quot;) in our string output. This is because the map() method always returns an array and when that array is implicitly converted to a string, commas (',') are inserted. To overcome this, we must make one small change to our template literal, ie:  let numberList = `&lt;ul&gt;${numbers.map((num) =&gt; `&lt;li&gt;${num}&lt;/li&gt;`).join('')}&lt;/ul&gt;`;   By chaining the join('') method at end of the &quot;map&quot; operation, we can ensure that the array is joined using empty strings ('') instead of commas (',').  With this in mind, let's attempt to write a template string that will solve our problem, by converting the data from jsonplaceholder into a series of rows (&lt;tr&gt; elements) to be used in our &quot;postsTable&quot;:  let postRows = ` ${data.map(post =&gt; ( `&lt;tr data-id=${post.id}&gt; &lt;td&gt;${post.userId}&lt;/td&gt; &lt;td&gt;${post.title}&lt;/td&gt; &lt;td&gt;${post.body}&lt;/td&gt; &lt;/tr&gt;` )).join('')} `;   Updating the DOM​  With our postRows showing valid HTML, our next step is to add it to the DOM. Fortunately, all that needs to be done is for the correct DOM element to be selected and it's .innerHTML property set to our newly generated postRows HTML string:  document.querySelector('#postsTable tbody').innerHTML = postRows;   Click Events​  Once the elements are added to the DOM, the last thing that we must do is to associate each row with a &quot;click&quot; event (we will be using this later). This involves selecting the newly created &lt;tr&gt; elements, looping through each one and (using the familiar &quot;addEventListener&quot; function) registering a &quot;click&quot; event. For the time being, we will test this by outputting &quot;clicked&quot; to the console:  // add the &quot;click&quot; event listener to the newly created rows document.querySelectorAll('#postsTable tbody tr').forEach((row) =&gt; { row.addEventListener('click', (e) =&gt; { console.log('clicked'); }); });   ","version":"Next","tagName":"h3"},{"title":"Filtering the Table​","type":1,"pageTitle":"Rendering Data","url":"/WebProgrammingForAppsAndServices/Bootstrap-UI-Implementation/bootstrap-rendering-data#filtering-the-table","content":" Our next major task is to give the user the ability to search for a user ID using our search form in the navigation bar. To achieve this, we must first register an event to trigger when the &quot;searchForm&quot; is submitted:  caution Make sure this code is executed only when the &quot;DOM is Ready&quot;.  document.querySelector('#searchForm').addEventListener('submit', (event) =&gt; { // prevent the form from from 'officially' submitting event.preventDefault(); });   Here, we use the event.preventDefault(); function to ensure that the event's default action is not taken - ie: submitting the form by attempting to send a request back to the server.  What we actually want to do is to get the value of the only &lt;input&gt; field (id: &quot;userId&quot;). In this case, we can obtain its &quot;value&quot; by simply using the value attribute of the form field element. Once we have this, we can invoke the &quot;populatePostsTable()&quot; method with the value, which will refresh the table:  document.querySelector('#searchForm').addEventListener('submit', (event) =&gt; { // prevent the form from from 'officially' submitting event.preventDefault(); // populate the posts table with the userId value populatePostsTable(document.querySelector('#userId').value); });   ","version":"Next","tagName":"h3"},{"title":"Populating / Showing the Modal Window​","type":1,"pageTitle":"Rendering Data","url":"/WebProgrammingForAppsAndServices/Bootstrap-UI-Implementation/bootstrap-rendering-data#populating--showing-the-modal-window","content":" The final piece of interactivity that we will add to the table is to enable the user to click on a specific row to obtain additional information for a given post - in this case we will show all of the &quot;comments&quot; for a given post.  Getting the Data on &quot;Click&quot;​  To begin, we will be placing our code within the &quot;click&quot; eventListener callback for the &quot;row&quot;, which currently displays the text &quot;clicked&quot; in the console. However, instead of displaying &quot;clicked&quot;, we will instead display the &quot;data-id&quot; value of the row that was clicked. This can be accomplished by using the getAttribute() method of the element (row):  // add the &quot;click&quot; event listener to the newly created rows document.querySelectorAll('#postsTable tbody tr').forEach((row) =&gt; { row.addEventListener('click', (e) =&gt; { let clickedId = row.getAttribute('data-id'); console.log(clickedId); }); });   Once we have confirmed this works and the correct &quot;clickedId&quot; is displayed in the console, we can use this value to get all of the comments for a current post using:  https://jsonplaceholder.typicode.com/comments?postId=ID   To test this functionality, add the following &quot;fetch()&quot; call to the above logic and confirm that the correct comments are indeed output to the console:  fetch(`https://jsonplaceholder.typicode.com/comments?postId=${clickedId}`) .then((res) =&gt; res.json()) .then((data) =&gt; { console.log(data); });   You should see that comments for &quot;postId&quot; 1 are shown for the first row, comments for &quot;postId&quot; 5 are shown for the fifth row, etc.  Generating the List​  Next, we must convert this data into an HTML representation and add it to the DOM - specifically the &quot;modal-body&quot; &lt;div&gt; element of our &quot;commentsModal&quot;. A similar operation was required above when first converting the initial post data to valid &lt;tr&gt; elements and we will use the same logic here. However, instead of generating &lt;tr&gt; elements, we will instead generate an unordered list using Bootstrap's list-group and list-group-item classes:  let commentsList = ` &lt;ul class=&quot;list-group&quot;&gt; ${data.map(comment =&gt; (` &lt;li class=&quot;list-group-item&quot;&gt; ${comment.body}&lt;br /&gt;&lt;br /&gt; &lt;strong&gt;Name:&lt;/strong&gt; ${comment.name}&lt;br /&gt; &lt;strong&gt;Email:&lt;/strong&gt; ${comment.email}&lt;br /&gt; &lt;/li&gt; `)).join('')} &lt;/ul&gt; `;   Populating the Modal​  Finally, with the commentsList containing the correct HTML, we can populate the modal window and show it to the user. This will involve adding the commentsList to the &quot;modal-body&quot;:  document.querySelector('#commentsModal .modal-body').innerHTML = commentsList;   and using using the bootstrap.modal() function; open the modal window:  let modal = new bootstrap.Modal(document.getElementById('commentsModal'), { backdrop: 'static', keyboard: false, }); modal.show();  ","version":"Next","tagName":"h3"},{"title":"Continuous Integration","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Deployment-Automated-Testing/continuous-integration","content":"","keywords":"","version":"Next"},{"title":"Git / GitHub Review​","type":1,"pageTitle":"Continuous Integration","url":"/WebProgrammingForAppsAndServices/Deployment-Automated-Testing/continuous-integration#git--github-review","content":" If you have ever &quot;pushed&quot; code to GitHub, you are likely familiar with some of the common &quot;git&quot; commands:  caution If you do not currently have &quot;git&quot; installed on your system (verified using the command: git --version), you can install it using the instructions here.    git init: Initializes a brand new Git repository and begins tracking an existing directory. It adds a hidden subfolder within the existing directory that houses the internal data structure required for version control.  git init     git clone: Creates a local copy of a project that already exists remotely. The clone includes all the project's files, history, and branches.  git clone git://git.kernel.org/pub/scm/.../linux.git my-linux cd my-linux     git add: Stages a change. Git tracks changes to a developer's codebase, but it's necessary to stage and take a snapshot of the changes to include them in the project's history. This command performs staging, the first part of that two-step process. Any changes that are staged will become a part of the next snapshot and a part of the project's history. Staging and committing separately gives developers complete control over the history of their project without changing how they code and work.  git add .     git commit: Saves the snapshot to the project history and completes the change-tracking process. In short, a commit functions like taking a photo. Anything that's been staged with git add will become a part of the snapshot with git commit.  git commit -m &quot;initial commit&quot;     git status: Shows the status of changes as untracked, modified, or staged.  git status     git remote: Manage the set of repositories (&quot;remotes&quot;) whose branches you track.  git remote -v     git checkout: Switch branches or restore working tree files (the -b flag creates a new branch before switching to it)  git checkout -b new-feature     git branch: Shows the branches being worked on locally.  git branch     git merge: Merges lines of development together. This command is typically used to combine changes made on two distinct branches. For example, a developer would merge when they want to combine changes from a feature branch into the main branch for deployment.  git checkout main git merge new-feature     git pull: Updates the local line of development with updates from its remote counterpart. Developers use this command if a teammate has made commits to a branch on a remote, and they would like to reflect those changes in their local environment.  git pull origin main     git push: Updates the remote repository with any commits made locally to a branch.  git push origin main     For more information, see the full reference guide to Git commands.  To practice some of these commands, grab the example code for this week and open the &quot;app-with-tests&quot; folder in Visual Studio Code. Next, issue the command npm install to fetch the dependencies / rebuild the node_modules folder.  ","version":"Next","tagName":"h2"},{"title":"Hosting Your Code​","type":1,"pageTitle":"Continuous Integration","url":"/WebProgrammingForAppsAndServices/Deployment-Automated-Testing/continuous-integration#hosting-your-code","content":" Now that we have reviewed some of the basic &quot;git&quot; commands, it's time to host our code on GitHub. If you don't have an account on GitHub, create one now.  Create a GitHub Repository​  Sign in to your GitHub account.  Find and click a &quot;+&quot; button on the Navigation Bar. Then, choose &quot;New Repository&quot; from the dropdown menu.    Fill in the repository name text field with the name of your project. Also, make sure that the &quot;Private&quot; option is selected:    Once you're happy with the settings, hit the &quot;Create repository&quot; button.  Prepare Our Local Git Repo​  Open the terminal and change the current working directory to your app.  You can run git status to verify that Git is set up properly. If you see fatal: not a git repository (or any of the parent directories): .git error message, then your local Git repository does not exist and you need to initialize it using git init.  Now that we're sure that our local git repository is set up, we need to add and commit all of our code changes:  Add the files to the local repository by running git add .Commit the newly added files: git commit -m &quot;Initial commit&quot;.  Connect the Local Git Repository to GitHub​  Go to your GitHub repository and click the &quot;copy&quot; button in the &quot;Quick Setup&quot; block:    This will copy the URL of your remote GitHub repository.  Now, go back to your Terminal again and add this remote URL by running the following command:  git remote add origin URL   where URL is the remote repository URL that you have copied in the previous step.  If you run git remote -v, you should see something like this:  origin\tgit@github.com:patrick-crawford/my-app.git (fetch) origin\tgit@github.com:patrick-crawford/my-app.git (push)   Finally, commit your changes (if you have not yet done so) and push the code from your local repository to the remote one:  git push origin main   caution Your default branch may be &quot;main&quot; - to confirm which branch you are on, execute the command git status  You can verify that the code was pushed by going back to your Browser and opening your GitHub repository.    ","version":"Next","tagName":"h3"},{"title":"Automating Tasks​","type":1,"pageTitle":"Continuous Integration","url":"/WebProgrammingForAppsAndServices/Deployment-Automated-Testing/continuous-integration#automating-tasks","content":" GitHub has an amazing automation platform that we can use within our projects called &quot;GitHub Actions&quot;:  GitHub Actions is a continuous integration and continuous delivery (CI/CD) platform that allows you to automate your build, test, and deployment pipeline. You can create workflows that build and test every pull request to your repository, or deploy merged pull requests to production. GitHub Actions goes beyond just DevOps and lets you run workflows when other events happen in your repository. For example, you can run a workflow to automatically add the appropriate labels whenever someone creates a new issue in your repository. GitHub provides Linux, Windows, and macOS virtual machines to run your workflows, or you can host your own self-hosted runners in your own data center or cloud infrastructure.  To get started using GitHub actions, we begin by creating a &quot;workflow&quot; that responds to an event. This involves creating the following starter file:  File: .github/workflows/ci.yaml  name: CI on: [push]   Notice how we have named the file &quot;ci.yaml&quot;, ie: &quot;ci&quot; for &quot;continuous integration&quot; and the &quot;.yaml&quot; extension for a &quot;yaml&quot; file: &quot;a human-friendly data serialization language for all programming languages&quot;. You can think of it as an alternative to .json that is typically used for writing configuration files. The official documentation offers a &quot;Reference Card&quot; as a reference for the full syntax, however we will only be using a small subset of this - just enough to correctly configure our &quot;ci&quot; workflow. One of the major differences that you will notice right away is that that it uses whitespace instead of curly braces.  In the above file, we have two properties:  The workflow nameThe event to trigger the workflow, in this case &quot;push&quot; defined in an array for the property on. By using a &quot;push&quot; event, the workflow will run whenever code is &quot;pushed&quot; to the repository using git push.  While this is enough to register the action for our repository on GitHub, it will not run as we have not defined any &quot;jobs&quot;. As our first job, let's run a simple &quot;lint&quot; check using ESLint.  info Since version 11.0.0, Next.js provides an integrated ESLint experience out of the box (which we opted into when creating a new app). By executing the command &quot;npm run lint&quot; you can &quot;lint&quot; your code, which &quot;statically analyzes your code to quickly find problems&quot;. This is an important step in CI, as we do not want any JS errors potentially breaking our build further down in the pipeline.  Add the following code to update the &quot;ci.yaml&quot; file:  jobs: run-tests: name: Lint and Test runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v4 - name: Install packages run: npm ci - name: Run ESlint run: npm run lint   We have added quite a lot to the file, so let's discuss the purpose of each property before moving on and testing our workflow:  jobs: A workflow run is made up of one or more jobs, which run in parallel by default. run-tests: The id of our job - notice it is &quot;run-tests&quot;, this is because we will eventually be automating tests as part of our workflow name: The name of our job, which will be displayed in the Github GUI runs-on: Used to define the type of machine to run the job on, in this case we will use the extremely common &quot;ubuntu-latest&quot; (ubuntu 22.04 at time of writing) setting, however GitHub offers other GitHub-hosted runners, including: windows-latest and macos-latest, in addition to specific versions. steps: A job contains a sequence of tasks called steps. Steps can run commands, run setup tasks, or run an action in your repository, a public repository, or an action published in a Docker registry. Not all steps run actions, but all actions run as a step. info the following properties are prefixed with a &quot;-&quot; character, to indicate that they are part of a Block Sequence - name: Checkout code, uses: actions/checkout@v4: This defines the first step of our job, named &quot;Checkout code&quot;. It uses the &quot;Checkout V4&quot; Action, which: &quot;checks-out your repository under $GITHUB_WORKSPACE, so your workflow can access it.&quot; - name: Install packages, run: npm ci: This second step, named &quot;Install packages&quot; runs a special version of &quot;npm install&quot;; npm ci. The &quot;ci&quot; command is &quot;similar to npm install, except it's meant to be used in automated environments such as test platforms, continuous integration, and deployment -- or any situation where you want to make sure you're doing a clean install of your dependencies.&quot; - name: Run ESLint, run: npm run lint: This is the final &quot;linting&quot; step, as identified above. With the environment set up and the packages obtained, we should be able to successfully execute this command.  ","version":"Next","tagName":"h2"},{"title":"Running our First Workflow​","type":1,"pageTitle":"Continuous Integration","url":"/WebProgrammingForAppsAndServices/Deployment-Automated-Testing/continuous-integration#running-our-first-workflow","content":" Now that we have a complete workflow defined, ie:  File: .github/workflows/ci.yaml  name: CI on: [push] jobs: run-tests: name: Lint and Test runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v4 - name: Install packages run: npm ci - name: Run ESlint run: npm run lint   Let's check in our code using &quot;git&quot; and once again &quot;push&quot; it to GitHub.  Once this has completed, view your repository on https://github.com and navigate to the &quot;Actions&quot; tab to see the workflow status. Each workflow run is named after the commit message, in this case &quot;added ci.yaml&quot;.  info You may also click on the workflow run from this screen to see the detailed steps:  Next, let's see what happens if we introduce some code that causes ESLint to report an error:  File: &quot;pages/_app.js&quot;  import '@/styles/globals.css' export default function App({ Component, pageProps }) { return &lt;br /&gt;&lt;Component {...pageProps} /&gt; }   This should yield the following ESLint Error:  Error: Parsing error: Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment &lt;&gt;...&lt;/&gt;? (4:15)   With the broken code in place, push your updated code to GitHub and view the next workflow run in the &quot;Actions&quot; tab - it should appear directly above the previous workflow:    If you examine the detailed output, you should see error repeated as above.  ","version":"Next","tagName":"h3"},{"title":"Adding Unit / E2E Testing​","type":1,"pageTitle":"Continuous Integration","url":"/WebProgrammingForAppsAndServices/Deployment-Automated-Testing/continuous-integration#adding-unit--e2e-testing","content":" You will notice that our sample project &quot;app-with-tests&quot; has been configured to test the &quot;Home&quot; component using both &quot;Jest&quot; and &quot;Cypress&quot; Tests:  File: &quot;tests/index.test.js&quot;  This is simply the first &quot;Jest&quot; test that was covered when &quot;Unit Testing&quot; was first discussed, ie: asserting that the Home component renders at least one link to https://vercel.com within the first child element of the &quot;main&quot; section.  File: &quot;cypress/e2e/spec.cy.js&quot;  describe('check Not Found (404)', () =&gt; { it('should return status 404 when visiting /unknown', () =&gt; { // See Request: https://docs.cypress.io/api/commands/request and // Its: https://docs.cypress.io/api/commands/its for more information regarding this test cy.request({ url: '/unknown', failOnStatusCode: false }).its('status').should('equal', 404); }); });   This Cypress test uses a &quot;command&quot; that we haven't seen before: &quot;cy.request()&quot;. Essentially all that we are doing here is making a request to &quot;/unknown&quot;, knowing that we do not have a route defined for that path. The expected behaviour is that the status code for the returned page is &quot;404&quot;. The &quot;its()&quot; command is used to get a property value (&quot;status&quot;) of the returned object.  If we wish to include the execution of these tests as a part of our workflow, we must add the following additional steps to our &quot;Lint and Test&quot; job, defined in .github/workflows/ci.yaml:  - name: Run Jest Tests run: npm run ci:test - name: Run Cypress Tests uses: cypress-io/github-action@v6 with: build: npm run build start: npm start   Here, the syntax for the &quot;Jest&quot; test is straightforward, as it is the same command that we would run in the integrated terminal in Visual Studio Code. However, setting up the &quot;Cypress&quot; E2E test is less straightforward, since the app must technically be running to perform the tests.  To get this working, we have used a github action created for Cypress. We use &quot;with&quot; to provide a map of input parameters to the action, ie the &quot;build&quot; and &quot;start&quot; commands.  Once you have added the above code to your &quot;.github/workflows/ci.yaml&quot; file, check in the updated code and &quot;push&quot; it to GitHub to confirm that the updated workflow is indeed running the tests.    ","version":"Next","tagName":"h3"},{"title":"Merging Code from Other Branches​","type":1,"pageTitle":"Continuous Integration","url":"/WebProgrammingForAppsAndServices/Deployment-Automated-Testing/continuous-integration#merging-code-from-other-branches","content":" Since part of &quot;Continuous Integration&quot; is integrating code changes and merging them into a central repository, we must discuss what this looks like in GitHub and how our Action (workflow) can help ensure code correctness for our main / master branch.  First, let's work on a bug identified by the client; in this case, they have noted that there must be a &quot;:&quot; character after the text &quot;By&quot; before the &quot;Vercel&quot; logo. In addition to fixing this issue, let's break one of our tests to see how we may be alerted of the potential danger of merging this bug fix into the main branch:  To begin, issue the following command to checkout a new &quot;branch&quot; for the fix  git checkout -b fix/logo   You can verify that we have moved to the new branch by executing the command:  git branch   Now that we know we are working on the &quot;fix/logo&quot; branch and not the &quot;master&quot; branch, we can proceed to update the code next to the &quot;Vercel&quot; logo within the &quot;Home&quot; component:  File: &quot;pages/index.js&quot;  &lt;a className={styles.primary} href=&quot;https://abc.com/new?utm_source=create-next-app&amp;utm_medium=default-template&amp;utm_campaign=create-next-app&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; &gt; By: {' '} &lt;Image className={styles.logo} src=&quot;/vercel.svg&quot; alt=&quot;Vercel logomark&quot; width={20} height={20} /&gt; Deploy now &lt;/a&gt;   Notice how we have added the required &quot;:&quot; character in the appropriate place in the UI to fix the bug. However, we have also introduced a potential problem by changing the &quot;vercel.com&quot; link to &quot;abc.com&quot;, thus breaking our &quot;Jest&quot; unit test and making this bug fix unfit for merging with the &quot;master&quot; branch.  To see how we can be alerted of this, go ahead and execute the following commands to commit the code and push it to GitHub:  git add . git commit -m &quot;Fix - added : after By before logo&quot; git push origin fix/logo   After you have pushed your branch to GitHub using the above code, open your browser to view your code on https://github.com and navigate to the &quot;Pull Requests&quot; tab:    You will notice that GitHub has detected a recent push to the branch fix/logo and is suggesting that you make a &quot;pull request&quot;  info Pull requests let you tell others about changes you've pushed to a branch in a repository on GitHub. Once a pull request is opened, you can discuss and review the potential changes with collaborators and add follow-up commits before your changes are merged into the base branch. For more information, see the GitHub Documentation on Pull Requests  Click this button to open a &quot;pull request&quot;. At the next page, use the default values and create the request by pressing the &quot;Create pull request&quot; button.  This should take you to detailed information for the pull request where you can see that there is an issue: &quot;All checks have failed&quot;    It is from this screen that you can comment on the pull request, requesting that the developer fix the breaking code, etc.  To fix this code and make it fit for merging, change &quot;abc.com&quot; back to &quot;vercel.com&quot; and check in the branch once again using the previous commands, ie:  git add . git commit -m &quot;Fix - restored vercel.com link&quot; git push origin fix/logo   This will trigger the tests to once again run and update the pull request, indicating that &quot;All Checks have passed&quot; and the &quot;Merge pull request&quot; is now shown in green:    Go ahead and merge the request to update your &quot;master&quot; branch on GitHub with the bug fix. If you wish to update your local &quot;master&quot; branch with the fix, you can issue the commands:  git checkout main git pull origin main  ","version":"Next","tagName":"h2"},{"title":"Bootstrap Introduction","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Bootstrap-UI-Implementation/bootstrap-introduction","content":"","keywords":"","version":"Next"},{"title":"Including Bootstrap 5​","type":1,"pageTitle":"Bootstrap Introduction","url":"/WebProgrammingForAppsAndServices/Bootstrap-UI-Implementation/bootstrap-introduction#including-bootstrap-5","content":" The simplest way to include Bootstrap in our projects is to add the CDN links directly in our HTML files. Alternatively, you can download the Source Files and customize them yourself using Sass, or use a package manager (ie: npm) to install Bootstrap.  For simplicity, we will include the CDN links directly in our HTML document, ie:  &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;!-- Bootstrap 5.1 CSS--&gt; &lt;link href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; integrity=&quot;sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3&quot; crossorigin=&quot;anonymous&quot; /&gt; &lt;!-- Bootstrap 5.1 JS Bundle --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js&quot; integrity=&quot;sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p&quot; crossorigin=&quot;anonymous&quot; &gt;&lt;/script&gt; &lt;title&gt;Bootstrap Practice&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt;   ","version":"Next","tagName":"h2"},{"title":"Grid System​","type":1,"pageTitle":"Bootstrap Introduction","url":"/WebProgrammingForAppsAndServices/Bootstrap-UI-Implementation/bootstrap-introduction#grid-system","content":" Arguably one of Bootstrap's best features has been the responsive utilities and the responsive grid system. Once you have planned the layout for your application, this is typically the first place to start placing UI elements and organizing your layout.  If you have used Bootstrap before, the core concept should be familiar: Place your main content within a &quot;container&quot; element, each logical row of your layout within a &quot;row&quot; element and each column within a &quot;col&quot; element, for example:  &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col&quot;&gt;Column&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;Column&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;   The above code will render a single &quot;row&quot; with two columns of equal width within a &quot;container&quot;. The width of the columns will always remain side-by-side and of equal width regardless of the size of the browser window.  Notice how we did not have to specify the number of &quot;columns&quot;, each div takes up (from a total of 12). Since we have only 2 columns in the above example, Bootstrap automatically assigns each column a width of &quot;6&quot; (totaling 12 columns). If we wish to change this behaviour and have one of our columns shorter or longer than the other, then we can use the familiar &quot;column-counting&quot; pattern, ie:  &lt;div class=&quot;col-3&quot;&gt;Column&lt;/div&gt; &lt;div class=&quot;col-9&quot;&gt;Column&lt;/div&gt;   Using the above code, you can see that the 2nd column takes up 9 (of 12) columns, while the other column takes the remaining 3.  info To achieve two equal width columns, two &quot;col-6&quot; classes would work as well.  You will also notice at certain points the layout &quot;jumps&quot; and the width of both columns are either increased or decreased, while remaining in the center of the container. This is because bootstrap 5 uses 6 Responsive Breakpoints, essentially representing 6 typical viewport / device sizes. From the documentation, you can see that these breakpoints (the places that the layout &quot;jumps&quot; when resizing) fall at the following viewport widths:  Breakpoint\tClass infix\tDimensionsX-Small\tNone\t&lt;576px Small\tsm\t≥576px Medium\tmd\t≥768px Large\tlg\t≥992px Extra Large\txl\t≥1200px Extra Extra Large\txxl\t≥1400px  From the above table, we can see that Bootstrap 5 identifies a viewport width of anything less than 576px as &quot;X-Small&quot;, while everything between 576px and 767px is considered &quot;Small&quot; and so on. As we have done in previous versions of Bootstrap, we can use the &quot;infix&quot; value with a specified class name, to target certain viewport sizes in order to change the layout of our grid.  For example, say we wish for our two-column &quot;3, 9&quot; layout from above to change its column widths at a specific viewpoint. A common, simple case is to have the columns &quot;collapse&quot; into a single column at the &quot;Small&quot; size, thus making the UI easier to read on mobile browsers.  To achieve this using the above table for reference, we can use the following code to specify that we only wish our columns to remain at the &quot;3,9&quot; layout for sizes &quot;Medium&quot; and above:  &lt;div class=&quot;col-md-3&quot;&gt;Column&lt;/div&gt; &lt;div class=&quot;col-md-9&quot;&gt;Column&lt;/div&gt;   ","version":"Next","tagName":"h2"},{"title":"Additional Options​","type":1,"pageTitle":"Bootstrap Introduction","url":"/WebProgrammingForAppsAndServices/Bootstrap-UI-Implementation/bootstrap-introduction#additional-options","content":" The above code will give us all of the flexibility that we require for simple layouts, however Bootstrap 5 offers additional options such as:  Mix and Match - The &quot;col-&quot; classes can be applied multiple times to a div, allowing finer control over how the div will display within the grid at different viewport widths.Row Columns - Used to specify how many rows should be created when multiple &quot;col&quot; classes are used, allowing columns to carry over to additional rowsNesting - As in previous versions of Bootstrap, columns can be nested depending on your layout needs  ","version":"Next","tagName":"h3"},{"title":"Navigation Bar​","type":1,"pageTitle":"Bootstrap Introduction","url":"/WebProgrammingForAppsAndServices/Bootstrap-UI-Implementation/bootstrap-introduction#navigation-bar","content":" Another common starting point for any application is to design and code a navigation bar to make traversing your app simple and intuitive. Once again, Bootstrap provides an excellent starting point to create a clean, responsive navigation bar. To begin, you only need a single &lt;nav&gt; element (typically placed above our main &quot;container&quot;) containing a &quot;container-fluid&quot;:  &lt;nav class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt;&lt;/div&gt; &lt;/nav&gt;   Notice how our &lt;nav&gt; element has a number of classes added to it. Each of these classes provides the following look / functionality:  navbar - This is the main class defining / styling the navigation bar navbar-expand-lg - This class is used to set the viewport minimum width for a full sized navigation bar. Anything smaller than the &quot;lg&quot; size (992px) will cause the content of the navigation bar to collapse into a sub menu with a &quot;Hamburger&quot; Icon navbar-light - This controls the colour / brightness of the items on the navigation bar. &quot;navbar-light&quot; will give you darker text (to be used on a lighter background), whereas &quot;navbar-dark&quot; will give you lighter text (to be used on a darker background) bg-light - This controls the colour / brightness of the background of the navigation bar. &quot;bg-light&quot; will give you a light coloured background, whereas &quot;bg-dark&quot; will give you a darker one. You may also use one of Bootstrap's predefined theme colours, ie: &quot;bg-primary&quot;&quot;bg-secondary&quot;&quot;bg-success&quot;&quot;bg-danger&quot;&quot;bg-warning&quot;&quot;bg-info&quot;  ","version":"Next","tagName":"h2"},{"title":"Navigation Items​","type":1,"pageTitle":"Bootstrap Introduction","url":"/WebProgrammingForAppsAndServices/Bootstrap-UI-Implementation/bootstrap-introduction#navigation-items","content":" All of the various items placed on the navigation bar will be located within the &quot;container-fluid&quot; &lt;div&gt;. Why don't we expand our navigation bar to contain the items listed in the Bootstrap documentation:  &lt;nav class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Navbar&lt;/a&gt; &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-bs-toggle=&quot;collapse&quot; data-bs-target=&quot;#navbarSupportedContent&quot; aria-controls=&quot;navbarSupportedContent&quot; aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot; &gt; &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;navbarSupportedContent&quot;&gt; &lt;ul class=&quot;navbar-nav me-auto mb-2 mb-lg-0&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link active&quot; aria-current=&quot;page&quot; href=&quot;#&quot;&gt;Home&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;#&quot;&gt;Link&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item dropdown&quot;&gt; &lt;a class=&quot;nav-link dropdown-toggle&quot; href=&quot;#&quot; id=&quot;navbarDropdown&quot; role=&quot;button&quot; data-bs-toggle=&quot;dropdown&quot; aria-expanded=&quot;false&quot; &gt; Dropdown &lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot; aria-labelledby=&quot;navbarDropdown&quot;&gt; &lt;li&gt;&lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;hr class=&quot;dropdown-divider&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link disabled&quot;&gt;Disabled&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class=&quot;d-flex&quot;&gt; &lt;input class=&quot;form-control me-2&quot; type=&quot;search&quot; placeholder=&quot;Search&quot; aria-label=&quot;Search&quot; /&gt; &lt;button class=&quot;btn btn-outline-success&quot; type=&quot;submit&quot;&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt;   This is a great starting point for building your own navigation, since it contains starter code for many of the elements that you may wish to use in your own navigation bar, such as:  navbar-brand​  &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Navbar&lt;/a&gt;   This is the large text appearing at the left of the navigation bar (typically the title of the site / app)  navbar-toggler​  &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-bs-toggle=&quot;collapse&quot; data-bs-target=&quot;#navbarSupportedContent&quot; aria-controls=&quot;navbarSupportedContent&quot; aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot; &gt; &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt; &lt;/button&gt;   This is the &quot;Hamburger&quot; button that will toggle the visibility of the navigation items (see &quot;collapse&quot; below) if the viewport width falls below the &quot;navbar-expand-' value&quot; (in this case it is &quot;navbar-expand-lg&quot; - from above).  collapse​  &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;navbarSupportedContent&quot;&gt;...&lt;/div&gt;   This &lt;div&gt; is the container for the main navigational elements of our navigation bar. Notice the &quot;id&quot; value matches the &quot;data-bs-target&quot; property of the &quot;navbar-toggler&quot;, allowing this container to be shown/hidden if the &quot;Hamburger&quot; button is toggled.  navbar-nav​  &lt;ul class=&quot;navbar-nav me-auto mb-2 mb-lg-0&quot;&gt; ... &lt;/ul&gt;   Nested within the &quot;collapse&quot; container (above) is the unordered-list defining all of our navigation items. The additional classes added to the element are to help with the spacing.  nav-item​  &lt;li class=&quot;nav-item&quot;&gt;...&lt;/li&gt;   These are all of the actual links contained within the navigation bar. They may take the form of either:  &lt;a&gt; elements with the class &quot;nav-link&quot; (optionally &quot;active&quot; for the current element) &lt;a&gt; elements with the class &quot;nav-link&quot; and &quot;dropdown-toggle&quot; - to be used to create a &quot;dropdown&quot; menu within your navigation bar. The full code for the dropdown looks like:  &lt;a class=&quot;nav-link dropdown-toggle&quot; href=&quot;#&quot; id=&quot;navbarDropdown&quot; role=&quot;button&quot; data-bs-toggle=&quot;dropdown&quot; aria-expanded=&quot;false&quot; &gt; Dropdown &lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot; aria-labelledby=&quot;navbarDropdown&quot;&gt; &lt;li&gt;&lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;hr class=&quot;dropdown-divider&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;   form​  &lt;form class=&quot;d-flex&quot;&gt; &lt;input class=&quot;form-control me-2&quot; type=&quot;search&quot; placeholder=&quot;Search&quot; aria-label=&quot;Search&quot; /&gt; &lt;button class=&quot;btn btn-outline-success&quot; type=&quot;submit&quot;&gt;Search&lt;/button&gt; &lt;/form&gt;   Finally (outside of the &quot;navbar-nav&quot; unordered list), It is possible to have &lt;form&gt; elements nested within the navbar. This may be used if we wish to implement search or login functionality, for example.  ","version":"Next","tagName":"h3"},{"title":"Buttons​","type":1,"pageTitle":"Bootstrap Introduction","url":"/WebProgrammingForAppsAndServices/Bootstrap-UI-Implementation/bootstrap-introduction#buttons","content":" The bootstrap &quot;btn&quot; and &quot;btn-{colour}&quot; classes allow us to easily create consistent, clean buttons within the user interface that match current theme.  To create a button in Bootstrap, simply use the class &quot;btn&quot; and select a &quot;theme&quot; colour (these will be the same colours as the navbar background options), ie:  &lt;button class=&quot;btn btn-primary&quot;&gt;Button&lt;/button&gt;   will render a button with the &quot;primary&quot; colour as its background. If we want to use one of the other colours, one of the predefined theme colours can be used as a suffix for the &quot;btn-&quot; class, ie:    &lt;button class=&quot;btn btn-primary&quot;&gt;Primary&lt;/button&gt; &lt;button class=&quot;btn btn-secondary&quot;&gt;Secondary&lt;/button&gt; &lt;button class=&quot;btn btn-success&quot;&gt;Success&lt;/button&gt; &lt;button class=&quot;btn btn-danger&quot;&gt;Danger&lt;/button&gt; &lt;button class=&quot;btn btn-warning&quot;&gt;Warning&lt;/button&gt; &lt;button class=&quot;btn btn-info&quot;&gt;Info&lt;/button&gt; &lt;button class=&quot;btn btn-light&quot;&gt;Light&lt;/button&gt; &lt;button class=&quot;btn btn-dark&quot;&gt;Dark&lt;/button&gt;   In addition to the standard look above, Bootstrap also offers some customization options, including:  Rendering the buttons using only their outlineModifying the size of the buttonsShowing the button in a disabled stateRendering full-width block buttons  ","version":"Next","tagName":"h2"},{"title":"Dropdowns​","type":1,"pageTitle":"Bootstrap Introduction","url":"/WebProgrammingForAppsAndServices/Bootstrap-UI-Implementation/bootstrap-introduction#dropdowns","content":" One extremely useful variation on the button is the &quot;dropdown&quot; button, effectively creating a button that, when clicked, shows a menu containing more links / buttons. Dropdowns are widely used and allow us to preserve space on the user interface. To create a dropdown button in Bootstrap, the following code can be used:  info Both &lt;button&gt; and &lt;a&gt; can be used in the following example  &lt;div class=&quot;dropdown&quot;&gt; &lt;button class=&quot;btn btn-secondary dropdown-toggle&quot; type=&quot;button&quot; id=&quot;dropdownMenuButton1&quot; data-bs-toggle=&quot;dropdown&quot; aria-expanded=&quot;false&quot; &gt; Dropdown button &lt;/button&gt; &lt;ul class=&quot;dropdown-menu&quot; aria-labelledby=&quot;dropdownMenuButton1&quot;&gt; &lt;li&gt;&lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;   As with regular buttons, there are some options for customization for dropdowns, including:  Using different sizesCreating Split Buttons, where only a portion of the button is pressed to show the dropdown menu[&quot;Dark&quot;] dropdowns, where the background of the dropdown menu is a &quot;dark&quot; colour to match darker themesShowing the dropdown menu in different directions  ","version":"Next","tagName":"h2"},{"title":"Tables​","type":1,"pageTitle":"Bootstrap Introduction","url":"/WebProgrammingForAppsAndServices/Bootstrap-UI-Implementation/bootstrap-introduction#tables","content":" Like the above components, tables in Bootstrap are extremely easy to create, and provide lots of configuration options. All that is required is that you add the class &quot;table&quot; to your existing &lt;table&gt; element, ie:  &lt;table class=&quot;table&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Column One&lt;/th&gt; &lt;th&gt;Column Two&lt;/th&gt; &lt;th&gt;Column Three&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Cell A&lt;/td&gt; &lt;td&gt;Cell B&lt;/td&gt; &lt;td&gt;Cell C&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Cell D&lt;/td&gt; &lt;td&gt;Cell E&lt;/td&gt; &lt;td&gt;Cell F&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;   This will provide the default table style that is used by Bootstrap. However, there are a ton of configuration options such as:  Adding background colours to the entire, or specific cells / rows using the class name &quot;table-{colour}&quot;, where {colour} can be one of the theme colours, ie &quot;primary&quot; etcRendering the table using striped rows by adding the class &quot;table-striped&quot; alongside the &quot;table&quot; classHighlighting rows when the user moves their mouse over the table by adding the class &quot;table-hover&quot; alongside the &quot;table classAdding / removing borders to tables using the &quot;table-bordered&quot; / &quot;table-bordereless&quot; classesConfiguring the size and responsive behaviour of tables  ","version":"Next","tagName":"h2"},{"title":"Modal Windows​","type":1,"pageTitle":"Bootstrap Introduction","url":"/WebProgrammingForAppsAndServices/Bootstrap-UI-Implementation/bootstrap-introduction#modal-windows","content":" The final component that we will discuss here is the &quot;modal&quot; window. This is essentially an in-page dialog box that focuses the users attention on a specific task or piece(s) of data.  To create a modal window in Bootstrap, you can use the following code (typically placed at the bottom of your &lt;body&gt; element):  &lt;div class=&quot;modal fade&quot; tabindex=&quot;-1&quot; id=&quot;exampleModal&quot;&gt; &lt;div class=&quot;modal-dialog&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;h5 class=&quot;modal-title&quot;&gt;Modal title&lt;/h5&gt; &lt;button type=&quot;button&quot; class=&quot;btn-close&quot; data-bs-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;p&gt;Modal body text goes here.&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-secondary&quot; data-bs-dismiss=&quot;modal&quot;&gt;Close&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;Save changes&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;   This creates a small, invisible user interface element that looks like the following:    in order to actually show the modal window, a few different options may be used:  Add the data attributes: data-bs-toggle=&quot;modal&quot; data-bs-target=&quot;#exampleModal&quot; to an HTML element. This will instruct bootstrap to show the modal with id &quot;exampleModal&quot; (using the default options) when the element is clickedUsing JavaScript, the following function can be used, ie:  let myModal = new bootstrap.Modal(document.getElementById('exampleModal'), { backdrop: 'static', // default true - &quot;static&quot; indicates that clicking on the backdrop will not close the modal window keyboard: false, // default true - false indicates that pressing on the &quot;esc&quot; key will not close the modal window focus: true, // default true - this instructs the browser to place the modal window in focus when initialized }); myModal.show();   If we wish to hide the modal, myModal.hide() may be used. ","version":"Next","tagName":"h2"},{"title":"React Forms","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Forms-Introduction/react-forms","content":"","keywords":"","version":"Next"},{"title":"Controlled Components​","type":1,"pageTitle":"React Forms","url":"/WebProgrammingForAppsAndServices/Forms-Introduction/react-forms#controlled-components","content":" React has identified this need for greater control over form components and has introduced the term &quot;Controlled Components&quot;:  &quot;In HTML, form elements such as &lt;input&gt;, &lt;textarea&gt;, and &lt;select&gt; typically maintain their own state and update it based on user input. In React, mutable state is typically kept in the state property of components, and only updated with setState(). We can combine the two by making the React state be the 'single source of truth'. Then the React component that renders a form also controls what happens in that form on subsequent user input. An input form element whose value is controlled by React in this way is called a 'controlled component'&quot;.  A very simple example of a controlled component can be seen in the below example. Here, we have included a single &quot;input&quot; control that not only obtains its initial value from the state (&quot;userName&quot;), but also updates the state with any changes via the &quot;onChange&quot; event:  import { useState } from 'react'; export default function SimpleForm() { const [userName, setUserName] = useState('Homer Simpson'); function submitForm(e) { e.preventDefault(); // prevent the browser from automatically submitting the form console.log(`form submitted - userName: ${userName}`); } return ( &lt;form onSubmit={submitForm}&gt; User Name: &lt;input value={userName} onChange={(e) =&gt; setUserName(e.target.value)} /&gt; &lt;br /&gt; &lt;br /&gt; &lt;button type=&quot;submit&quot;&gt;Update User Name&lt;/button&gt; &lt;/form&gt; ); }   By ensuring that the initial value of the form control is set to the value currently in the state, as well as updating the state with the current value of the form field whenever it is changed, we can say that the state is the &quot;single source of truth&quot;. If the state always holds an &quot;up-to-date&quot; representation of the form, it can be used in the form submission handler to send the correct information to a Web API via an AJAX &quot;POST&quot; / &quot;PUT&quot;, etc. request.  While this certainly works for smaller forms, it does not necessarily scale well and adding common features such as validation, keeping track of visited fields, handling varied types of input fields / select-multiple, etc. adds extra complexity to the code.  It is for these reasons that complete, third-party solutions have been created as an alternative to working directly with &quot;Controlled Components&quot; in React. Some popular solutions include:  Formik: https://formik.org React Hook Form: https://react-hook-form.com  ","version":"Next","tagName":"h2"},{"title":"React Hook Form​","type":1,"pageTitle":"React Forms","url":"/WebProgrammingForAppsAndServices/Forms-Introduction/react-forms#react-hook-form","content":" For our purposes, we will be working with &quot;React Hook Form&quot;, as it provides excellent performance, greatly simplifies working with forms and has great support for schema / HTML standard validation and handling errors.  ","version":"Next","tagName":"h2"},{"title":"Getting Started​","type":1,"pageTitle":"React Forms","url":"/WebProgrammingForAppsAndServices/Forms-Introduction/react-forms#getting-started","content":" To get started working with React Hook Form, we first must install it as a dependency from npm:  npm i react-hook-form   After this, we simply have to import the &quot;useForm&quot; hook and we can get started writing forms:  import { useForm } from 'react-hook-form';   As a simple example, let's begin by re-writing the above &quot;Controlled Component&quot; code, to use &quot;react-hook-form&quot; and the &quot;useForm&quot; hook:  import { useForm } from 'react-hook-form'; export default function UserForm() { const { register, handleSubmit } = useForm({ defaultValues: { userName: 'Homer Simpson', }, }); function submitForm(data) { console.log(`form submitted - userName: ${data.userName}`); } return ( &lt;form onSubmit={handleSubmit(submitForm)}&gt; User Name: &lt;input {...register('userName')} /&gt; &lt;br /&gt; &lt;br /&gt; &lt;button type=&quot;submit&quot;&gt;Update User Name&lt;/button&gt; &lt;/form&gt; ); }   At first, you will notice one important difference - we did not import, nor use the &quot;useState&quot; hook at all in our solution. This is because React Hook Form manages its own internal state and if we wish to set an initial value for a form field, it can be done using either the &quot;defaultValue&quot; property on a specific form element, or by using the &quot;defaultValues&quot; property in the argument passed to the &quot;useForm&quot; hook (as above).  info While React Hook Form encourages the use of default values, it is also very likely that any initial form data will not be available until it has been obtained from a Web API. In this case it would be common practice to update the form from within the &quot;useEffect()&quot; hook, once the data has materialized. If this is the case, &quot;setValue&quot; may be used with a default value of &quot;&quot; for userName: const { register, handleSubmit, setValue } = useForm({ defaultValues: { userName: '', // the documentation encourages default values }, }); useEffect(() =&gt; { // set the userName value setValue('userName', 'Homer Simpson'); }, []);   You will also notice that our &quot;submitForm&quot; function has changed, as it no longer accepts the submit event &quot;e&quot;. With React Hook Form, the submit function is instead invoked by &quot;handleSubmit&quot;, which automatically passes the form data to the callback function (ie: &quot;submitForm&quot;).  info It is still possible to obtain the submit event, by referencing a 2nd parameter &quot;e&quot;, in the &quot;submitForm&quot; function, ie: function submitForm(data, e) {}   Finally, we made use of the &quot;register&quot; method to associate this control with React Hook Form. By &quot;registering&quot; a control with React Hook Form, we're essentially registering the onBlur and onChange callbacks, as well as setting the name property for the form control and assigning a &quot;ref&quot;. From the React Hook Form documentation:  const { onChange, onBlur, name, ref } = register('firstName'); &lt;input onChange={onChange} // assign onChange event onBlur={onBlur} // assign onBlur event name={name} // assign name prop ref={ref} // assign ref prop /&gt; // same as above &lt;input {...register('firstName')} /&gt;   ","version":"Next","tagName":"h3"},{"title":"Registering Multiple Form Controls​","type":1,"pageTitle":"React Forms","url":"/WebProgrammingForAppsAndServices/Forms-Introduction/react-forms#registering-multiple-form-controls","content":" As a more complete example, let's use the above methods to show a form containing all of the basic form controls (&lt;input /&gt;, &lt;select&gt;...&lt;/select&gt;, &lt;textarea&gt;...&lt;/textarea&gt;). We will also set the initial values of the form controls from an object defined in the &quot;useEffect&quot; hook:  import { useForm } from 'react-hook-form'; import { useEffect } from 'react'; export default function UserForm() { const { register, handleSubmit, setValue } = useForm({ defaultValues: { userName: &quot;&quot;, address: &quot;&quot;, campus: &quot;&quot;, program: [], parking: &quot;&quot;, active: false } }); useEffect(() =&gt; { let data = { userName: &quot;Homer Simpson&quot;, address: &quot;123 Main St, Springfield U.S.A&quot;, campus: &quot;newnham&quot;, program: ['CPA', 'CPP'], parking: &quot;semester&quot;, active: true } // set the values of each form field to match &quot;data&quot; for (const prop in data) { setValue(prop, data[prop]); } }, []) function submitForm(data) { console.log(data); } return ( &lt;form onSubmit={handleSubmit(submitForm)}&gt; User Name: &lt;br /&gt; &lt;input {...register(&quot;userName&quot;)} /&gt;&lt;br /&gt;&lt;br /&gt; Address: &lt;br /&gt; &lt;textarea {...register(&quot;address&quot;)}&gt;&lt;/textarea&gt;&lt;br /&gt;&lt;br /&gt; Campus: &lt;br /&gt; &lt;select {...register(&quot;campus&quot;)}&gt; &lt;option value=&quot;king&quot;&gt;King&lt;/option&gt; &lt;option value=&quot;SatY&quot;&gt;Seneca at York&lt;/option&gt; &lt;option value=&quot;newnham&quot;&gt;Newnham&lt;/option&gt; &lt;option value=&quot;markham&quot;&gt;Markham&lt;/option&gt; &lt;/select&gt;&lt;br /&gt;&lt;br /&gt; Program: &lt;br /&gt; &lt;select multiple {...register(&quot;program&quot;)}&gt; &lt;option value=&quot;DAD&quot;&gt;Database Application Developer&lt;/option&gt; &lt;option value=&quot;CPA&quot;&gt;Computer Programming &amp;amp; Analysis&lt;/option&gt; &lt;option value=&quot;CPP&quot;&gt;Computer Programming&lt;/option&gt; &lt;option value=&quot;DSA&quot;&gt;Honours Bachelor of Data Science and Analytics&lt;/option&gt; &lt;/select&gt;&lt;br /&gt;&lt;br /&gt; Parking: &lt;br /&gt; &lt;input type=&quot;radio&quot; value=&quot;daily&quot; {...register(&quot;parking&quot;)} /&gt; Daily&lt;br /&gt; &lt;input type=&quot;radio&quot; value=&quot;semester&quot; {...register(&quot;parking&quot;)} /&gt; Semester&lt;br /&gt; &lt;input type=&quot;radio&quot; value=&quot;year&quot; {...register(&quot;parking&quot;)} /&gt; Academic Year&lt;br /&gt;&lt;br /&gt; &lt;input type=&quot;checkbox&quot; {...register(&quot;active&quot;)} /&gt;Currently Active&lt;br /&gt;&lt;br /&gt; &lt;button type=&quot;submit&quot;&gt;Update User&lt;/button&gt; &lt;/form&gt; ); }   As you can see from the above code, there is no special syntax for registering one type of form control over another. All that is required is that the code:  {...register(fieldName)}   is placed on the form control, where &quot;fieldName&quot; is the name of the field that references the control.  Additionally, you will notice a small addition to the code in the &quot;useEffect&quot; hook:  // set the values of each form field to match &quot;data&quot; for (const prop in data) { setValue(prop, data[prop]); }   Here, we are looping through every property in the &quot;data&quot; object (using a &quot;for...in&quot; loop) and explicitly setting the value for every field in our form with the value of the matching property. This works, since the registered &quot;fieldname&quot; values in the form match the property names in the data object.  ","version":"Next","tagName":"h3"},{"title":"\"Watching\" Form Values​","type":1,"pageTitle":"React Forms","url":"/WebProgrammingForAppsAndServices/Forms-Introduction/react-forms#watching-form-values","content":" If you need to obtain the value of a form field as it's updated, it is possible to &quot;watch&quot; it and be updated with any changes. For example, if we wish to &quot;watch&quot; the &quot;userName&quot; field, such that we can show it to the user or use it to hide / show other fields in the form, all that is required is that we include &quot;watch&quot; and create a variable to hold the value, ie:  const { watch } = useForm();   const watchUserName = watch('userName');   &lt;p&gt;User Name: {watchUserName}&lt;/p&gt;   For more information / special cases, see the official documentation for &quot;watch&quot; ","version":"Next","tagName":"h3"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Handling-Events-Rendering-Data/example-code","content":"Example Code You may download the sample code for this topic here: Handling-Events-Rendering-Data","keywords":"","version":"Next"},{"title":"Form Validation","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Forms-Introduction/validation","content":"","keywords":"","version":"Next"},{"title":"Adding Validation Rules to \"register\"​","type":1,"pageTitle":"Form Validation","url":"/WebProgrammingForAppsAndServices/Forms-Introduction/validation#adding-validation-rules-to-register","content":" In addition to &quot;registering&quot; our form controls, the &quot;register&quot; function also accepts a second &quot;options&quot; parameter to configure how the control behaves, including setting validation rules.  For example, we will start with the following simple form:  import { useForm } from 'react-hook-form'; import { useEffect } from 'react'; export default function FormWithValidation() { const { register, handleSubmit, setValue } = useForm({ defaultValues: { firstName: &quot;&quot;, lastName: &quot;&quot;, age: 0 } }); useEffect(() =&gt; { let data = { firstName: &quot;Homer&quot;, lastName: &quot;Simpson&quot;, age: 42 } // set the values of each form field to match &quot;data&quot; for (const prop in data) { setValue(prop, data[prop]); } }, []); function submitForm(data) { console.log(data); } return ( &lt;form onSubmit={handleSubmit(submitForm)}&gt; First Name: &lt;br /&gt; &lt;input {...register(&quot;firstName&quot;)} /&gt;&lt;br /&gt;&lt;br /&gt; Last Name: &lt;br /&gt; &lt;input {...register(&quot;lastName&quot;)} /&gt;&lt;br /&gt;&lt;br /&gt; Age: &lt;br /&gt; &lt;input type=&quot;number&quot; {...register(&quot;age&quot;)} /&gt;&lt;br /&gt;&lt;br /&gt; &lt;button type=&quot;submit&quot;&gt;Update User&lt;/button&gt; &lt;/form&gt; ); }   Here, we ask the user to modify their first name, last name and age, starting from initial values obtained in the &quot;useEffect&quot; hook. At the moment, there are no restrictions on what the user may enter, apart from the restriction built in to the input type &quot;number&quot;.  If we wish to add specific validation rules for each form field individually, we can specify each validation rule as a property of the RegisterOptions parameter of the &quot;register&quot; method. For example, we can modify the 3 form fields above to use specific validation rules such as &quot;required&quot;, &quot;maxLength&quot;, &quot;pattern&quot;, &quot;min&quot;, &quot;max&quot;, etc.  &lt;form onSubmit={handleSubmit(submitForm)}&gt; First Name: &lt;br /&gt; &lt;input {...register(&quot;firstName&quot;, { required: true, maxLength: 20 })} /&gt;&lt;br /&gt;&lt;br /&gt; Last Name: &lt;br /&gt; &lt;input {...register(&quot;lastName&quot;, { pattern: /^[A-Za-z]+$/i })} /&gt;&lt;br /&gt;&lt;br /&gt; Age: &lt;br /&gt; &lt;input type=&quot;number&quot; {...register(&quot;age&quot;, { min: 18, max: 99 })} /&gt;&lt;br /&gt;&lt;br /&gt; &lt;button type=&quot;submit&quot;&gt;Update User&lt;/button&gt; &lt;/form&gt;   AFter this change has been made, the form should still appear the same, however if we try to break one of the validation rules (ie: removing the first name value) before submitting the form, we will notice that:  The (first) form field that is in violation of a validation rule is focusedThe &quot;submitForm&quot; function does not run  ","version":"Next","tagName":"h2"},{"title":"Custom Validation Rules​","type":1,"pageTitle":"Form Validation","url":"/WebProgrammingForAppsAndServices/Forms-Introduction/validation#custom-validation-rules","content":" In addition to the above &quot;native validation&quot;, React Hook Form also allows us to create our own validation rules by specifying one or more callback functions as properties within a &quot;validate&quot; parameter to RegisterOptions. As a simple example, say we wish to ensure that we are only accepting &quot;Age&quot; values that are even, in the above form. We can add the following custom &quot;onlyEven&quot; validation rule to our &quot;nunber&quot; field:  &lt;input type=&quot;number&quot; {...register(&quot;age&quot;, { min: 18, max: 99, validate: { onlyEven: v =&gt; v % 2 == 0 } })} /&gt;&lt;br /&gt;&lt;br /&gt;   ","version":"Next","tagName":"h3"},{"title":"Showing Errors​","type":1,"pageTitle":"Form Validation","url":"/WebProgrammingForAppsAndServices/Forms-Introduction/validation#showing-errors","content":" While restricting the form submission and automatically focusing the problematic field is an effective way to perform client side validation, we are missing an important piece: showing a description of the error to the user, so that they can correct the mistake.  In order to actually show the errors, we must first add the &quot;errors&quot; object from &quot;formState&quot;, to give us access to any errors in the form:  const { register, handleSubmit, setValue, formState: { errors } } = useForm({...});   This will give us access to the &quot;errors&quot; object, which will contain each form field that contains an error, as a property. Additionally, each specific validation error will also be identified for each form field using a &quot;type&quot; property. If there are no invalid fields, this object will be empty, ie &quot;&quot;.  Using this, we can easily inspect a specific form control to see if it contains any errors and if so, which rules have been violated. For example, if we wish to show errors for the &quot;firstName&quot; field, we could use the following code:  &lt;input {...register(&quot;firstName&quot;, { required: true, maxLength: 20 })} /&gt; {errors.firstName?.type === &quot;required&quot; &amp;&amp; &lt;span&gt;&lt;br /&gt;First Name is required&lt;/span&gt;} {errors.firstName?.type === &quot;maxLength&quot; &amp;&amp; &lt;span&gt;&lt;br /&gt;First Name Cannot contain more than 20 characters&lt;/span&gt;} &lt;br /&gt;&lt;br /&gt;   Notice how we use the &quot;optional chaining operator&quot; before checking the &quot;type&quot; of the error message. This ensures that we do not receive the following error if the form field is currently valid (ie: no errors):  TypeError: Cannot read properties of undefined (reading 'type')   Also, if you try running the example again, you should see that the error messages show up only after the form is first submitted. After this first submit, the errors are shown / hidden as the user modifies the form. This lets the user know immediately if they have corrected the error.  info In addition to the &quot;errors&quot; object, you can include additional objects such as &quot;dirtyFields&quot; and &quot;touchedFields&quot; to monitor which fields have been modified and visited.  ","version":"Next","tagName":"h2"},{"title":"Highlighting Fields​","type":1,"pageTitle":"Form Validation","url":"/WebProgrammingForAppsAndServices/Forms-Introduction/validation#highlighting-fields","content":" Given that the &quot;errors&quot; object contains property names of all form fields that are currently in violation of a validation rule, it is a simple task to conditionally add a CSS class to a form field that is in error. For example, if we had the class &quot;inputError&quot;, we could conditionally add it to the field using the code:  className={errors.firstName &amp;&amp; &quot;inputError&quot;}   Here, we check if the &quot;errors&quot; object contains a firstName property, and if it does, add the &quot;inputError&quot; class.  ","version":"Next","tagName":"h3"},{"title":"Disabling the \"submit\" Button​","type":1,"pageTitle":"Form Validation","url":"/WebProgrammingForAppsAndServices/Forms-Introduction/validation#disabling-the-submit-button","content":" Another interesting UI improvement that can be made using &quot;errors&quot; is conditionally disabling the &quot;submit&quot; button if the form is &quot;in error&quot; (has one or more fields with validation errors). This can be done by counting how many properties exist on the &quot;errors&quot; object using &quot;Object.keys()&quot;, since only form fields that are in error should have a corresponding property within the errors object, ie:  &lt;button type=&quot;submit&quot; disabled={Object.keys(errors).length &gt; 0}&gt;Update User&lt;/button&gt;  ","version":"Next","tagName":"h3"},{"title":"Conditionally Displaying Data","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Handling-Events-Rendering-Data/conditionally-displaying-data","content":"","keywords":"","version":"Next"},{"title":"Logical && Operator (If)​","type":1,"pageTitle":"Conditionally Displaying Data","url":"/WebProgrammingForAppsAndServices/Handling-Events-Rendering-Data/conditionally-displaying-data#logical--operator-if","content":" First, let's take a look at a situation where we may only want to render some data under a specific condition. For example, say we only want to show the 'user' name if the user is &quot;active&quot;. To accomplish this, we can leverage the &amp;&amp; Operator.  return &lt;div&gt;{users[0].active &amp;&amp; &lt;p&gt;{users[0].user} is Active!&lt;/p&gt;}&lt;/div&gt;   ","version":"Next","tagName":"h2"},{"title":"Ternary Operator (If-Else)​","type":1,"pageTitle":"Conditionally Displaying Data","url":"/WebProgrammingForAppsAndServices/Handling-Events-Rendering-Data/conditionally-displaying-data#ternary-operator-if-else","content":" Next, let's look at how we can use the ternary operator, ie: (age &gt; 18) ? &quot;adult&quot; : &quot;minor&quot; to render a different &lt;p&gt; element depending on whether or not the user is &quot;active&quot;.  return ( &lt;div&gt; {users[0].active ? &lt;p&gt;{users[0].user} is Active!&lt;/p&gt; : &lt;p&gt;{users[0].user} is Inactive!&lt;/p&gt;} &lt;/div&gt; );   ","version":"Next","tagName":"h2"},{"title":"Array.map() (Iteration)​","type":1,"pageTitle":"Conditionally Displaying Data","url":"/WebProgrammingForAppsAndServices/Handling-Events-Rendering-Data/conditionally-displaying-data#arraymap-iteration","content":" One extremely common task is iterating over a collection and outputting each element using a consistent format. This could be rows in a table, items in a list, other components, etc. To achieve this within our JSX code, we can use the Array.map() method, ie:  return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;User&lt;/th&gt; &lt;th&gt;Active&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; {users.map((user) =&gt; ( &lt;tr&gt; &lt;td&gt;{user.user}&lt;/td&gt; &lt;td&gt;{user.active ? 'yes' : 'no'}&lt;/td&gt; &lt;td&gt;{user.age}&lt;/td&gt; &lt;/tr&gt; ))} &lt;/tbody&gt; &lt;/table&gt; );   While this does work to render each user in its own &lt;tr&gt; element, we actually have one small problem. If you open the console in the browser, you will see an error: &quot;Warning: Each child in a list should have a unique &quot;key&quot; prop.&quot; According to the documentation:  Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity.  Normally, we would have a unique id to work with (ie &quot;_id&quot; from MongoDB), however with our list we don't have any &quot;stable&quot; id's to work with. In this case, we can make use of the 2nd parameter to the &quot;map()&quot; method - the &quot;index&quot;. This requires us to change our JSX to use the following code:  {users.map((user, index) =&gt; ( &lt;tr key={index}&gt; &lt;td&gt;{user.user}&lt;/td&gt; &lt;td&gt;{user.active ? 'yes' : 'no'}&lt;/td&gt; &lt;td&gt;{user.age}&lt;/td&gt; &lt;/tr&gt; ))}   ","version":"Next","tagName":"h2"},{"title":"Returning Null​","type":1,"pageTitle":"Conditionally Displaying Data","url":"/WebProgrammingForAppsAndServices/Handling-Events-Rendering-Data/conditionally-displaying-data#returning-null","content":" Finally, we can actually choose not to render anything by returning null, for example:  if (!loading) { return &lt;p&gt;Done Loading! - TODO: Show the data here&lt;/p&gt; } else { return null; // don't render anything - still loading }  ","version":"Next","tagName":"h2"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Introduction-JWT/example-code","content":"Example Code You may download the sample code for this topic here: Introduction-JWT","keywords":"","version":"Next"},{"title":"Adding API Data","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Handling-Events-Rendering-Data/adding-API-data","content":"","keywords":"","version":"Next"},{"title":"Hydration​","type":1,"pageTitle":"Adding API Data","url":"/WebProgrammingForAppsAndServices/Handling-Events-Rendering-Data/adding-API-data#hydration","content":" Notice how the documentation mentioned &quot;hydration&quot; in its description of what occurs when a page is loaded by the browser. This is not the first time that we have seen this mentioned in these notes - recall the code to initialize the &quot;date&quot; state for our &lt;Clock /&gt; component :  const [date, setDate] = useState(null); // Note: Never set this to unknown data obtained at run time (ie: new Date(), a random number, etc.) - see: https://nextjs.org/docs/messages/react-hydration-error   We were forced to set the initial value of &quot;date&quot; to &quot;null&quot; to avoid a potential hydration error. This is because the pre-rendered HTML is actually generated when the app does a new &quot;build&quot; (in &quot;dev&quot; mode, this is every time a change is made to your code). If we initialize the state to a dynamic value (ie: &quot;new Date()&quot;), then the page will be pre-rendered with a value that will be instantly out-of-date. When the page is then loaded at a different time, a hydration error occurs:  Unhandled Runtime Error Error: Text content does not match server-rendered HTML.   This is because the pre-rendered body of the page looks something like this:  &lt;p&gt; Locale: &lt;!-- --&gt;: &lt;!-- --&gt;1:43:08 PM&lt;!-- --&gt; &lt;!-- --&gt; &lt;/p&gt;   which instantly disagrees with the code generated on the first render, ie after &quot;hydration&quot; sometime later.  You will recall that to fix this issue, we placed our code to initialize the date value within the body of the &quot;useEffect&quot; hook's callback function:  useEffect(() =&gt; { setDate(new Date()); }, []);   The reason that this worked to solve the hydration error was because code in the callback defined in the useEffect hook only gets executed once the component is first &quot;mounted&quot; (ie: added to the DOM) after &quot;hydration&quot;. It is not executed when the pre-rendered HTML is being generated. This causes the pre-rendered body of the page to look like the following:  &lt;p&gt; Locale: &lt;!-- --&gt;: &lt;!-- --&gt; &lt;!-- --&gt; &lt;/p&gt;   which avoids the content mis-match when the component is rendered after &quot;hydration&quot;.  ","version":"Next","tagName":"h2"},{"title":"Fetching API Data after Hydration​","type":1,"pageTitle":"Adding API Data","url":"/WebProgrammingForAppsAndServices/Handling-Events-Rendering-Data/adding-API-data#fetching-api-data-after-hydration","content":" Now that we are familiar with the concepts of &quot;pre-rendering&quot; and &quot;hydration&quot;, it follows that a request for API data that must occur after hydration should be done within the &quot;useEffect&quot; hook as well. For example, consider the following &quot;Post&quot; component which fetches data from our familiar {JSON} Placeholder dataset:  import { useState, useEffect } from &quot;react&quot;; export default function Post() { const [post, setPost] = useState(); useEffect(() =&gt; { // NOTE: The callback function must not be &quot;async&quot; - Results in error: TypeError: destroy is not a function fetch(`https://jsonplaceholder.typicode.com/posts/1`).then(res =&gt; res.json()).then(data =&gt; { setPost(data); }) }, []); return ( &lt;&gt; &lt;strong&gt;User ID:&lt;/strong&gt; {post?.userId}&lt;br /&gt; &lt;strong&gt;Title:&lt;/strong&gt; {post?.title}&lt;br /&gt; &lt;strong&gt;Body:&lt;/strong&gt; {post?.body}&lt;br /&gt; &lt;/&gt; ) }   This component does not set any value for &quot;post&quot; in the state (leaving it 'undefined') and instead relies upon the callback function defined within &quot;useEffect&quot; to pull in the data and update the &quot;post&quot; value. This results in the pre-rendered HTML looking like the following:  &lt;strong&gt;User ID:&lt;/strong&gt; &lt;!-- --&gt;&lt;br&gt; &lt;strong&gt;Title:&lt;/strong&gt; &lt;!-- --&gt;&lt;br&gt; &lt;strong&gt;Body:&lt;/strong&gt; &lt;!-- --&gt;&lt;br&gt;   Once &quot;hydration&quot; occurs, the effect is executed and the &quot;post&quot; value is set (causing a render). This gives us:  &lt;strong&gt;User ID:&lt;/strong&gt; &lt;!-- --&gt;1&lt;!-- --&gt;&lt;br&gt; &lt;strong&gt;Title:&lt;/strong&gt; &lt;!-- --&gt;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&lt;!-- --&gt;&lt;br&gt; &lt;strong&gt;Body:&lt;/strong&gt; &lt;!-- --&gt;quia et suscipit suscipit recusandae consequuntur expedita et cum reprehenderit molestiae ut ut quas totam nostrum rerum est autem sunt rem eveniet architecto&lt;!-- --&gt;&lt;br&gt;   info When fetching data on the client-side (as above, in the &quot;useEffect&quot; hook), Next.js recommends that SWR be used instead, as it handles &quot;caching, revalidation, focus tracking, refetching on intervals, and more&quot;. Using SWR, the above component would look like: import useSWR from 'swr'; // define the &quot;fetcher&quot; function. This Can also be defined globally using SWRConfig (https://swr.vercel.app/docs/global-configuration) const fetcher = (url) =&gt; fetch(url).then((res) =&gt; res.json()); export default function Post() { const { data, error } = useSWR('https://jsonplaceholder.typicode.com/posts/1', fetcher); return ( &lt;&gt; &lt;strong&gt;User ID:&lt;/strong&gt; {data?.userId}&lt;br /&gt; &lt;strong&gt;Title:&lt;/strong&gt; {data?.title}&lt;br /&gt; &lt;strong&gt;Body:&lt;/strong&gt; {data?.body}&lt;br /&gt; &lt;/&gt; ); } For more information on using SWR, refer to the official SWR documentation.  ","version":"Next","tagName":"h2"},{"title":"Fetching API Data for Pre-Rendered HTML​","type":1,"pageTitle":"Adding API Data","url":"/WebProgrammingForAppsAndServices/Handling-Events-Rendering-Data/adding-API-data#fetching-api-data-for-pre-rendered-html","content":" If the data that is coming back from the API is not likely to change, we may wish to include it in the pre-rendered HTML to speed up load times and provide greater SEO.  Next.js provides this functionality via a mechanism called getStaticProps. This is essentially a function that Next.js runs on the server when the app is built in order to obtain data required to pre-render your pages. From our point of view, it is a function that we can export from any &quot;page&quot; component to provide data to any components on that page via &quot;props&quot;.  Warning: This will not work with custom components defined within the &quot;components&quot; folder.  At the moment, we really only have one &quot;page&quot; component - the &lt;Home /&gt; component declared in index.html. It should contain the &lt;Post /&gt; component, ie:  import Post from '@/components/Post'; export default function Home() { return ( &lt;&gt; &lt;Post /&gt; &lt;/&gt; ); }   if we wish to have the data for the &lt;Post /&gt; component fetched at build time, we must make use of the &quot;asynchronous&quot; getStaticProps() function in this file, ie:  import Post from '@/components/Post'; // This function gets called at build time export function getStaticProps() { // Call an external API endpoint to get posts return new Promise((resolve,reject)=&gt;{ fetch('https://jsonplaceholder.typicode.com/posts/1').then(res=&gt;res.json()).then(data=&gt;{ resolve({ props: { staticPost: data } }) }) }) } export default function Home(props) { console.log(props); // props.staticPost should contain our data return ( &lt;&gt; &lt;Post /&gt; &lt;/&gt; ); }   Here, we have exported an extra function above our &quot;Home&quot; component definition. The purpose of this function is to provide the exported page component (ie: &quot;Home&quot;, in this case) with additional props that contain data to be pre-rendered by the component and/or the child components. The function always returns a promise which resolves with an object that contains one of the following properties:  props: &quot;a key-value pair, where each value is received by the page component. It should be a serializable object so that any props passed, could be serialized with JSON.stringify.&quot; redirect: &quot;The redirect object allows redirecting to internal or external resources. It should match the shape of { destination: string, permanent: boolean }. notfound: &quot;allows the page to return a 404 status and 404 Page. With notFound: true, the page will return a 404 even if there was a successfully generated page before. This is meant to support use cases like user-generated content getting removed by its author.&quot;  info An optional &quot;revalidate&quot; is also available, which allows you to update static pages after you’ve built your site. See: Incremental Static Regeneration (ISR) for more information  Finally, since this function always returns a promise is often written using the async / await syntax, ie:  // This function gets called at build time export async function getStaticProps() { // Call an external API endpoint to get posts const res = await fetch('https://jsonplaceholder.typicode.com/posts/1'); const data = await res.json(); return { props: { staticPost: data } }; }   ","version":"Next","tagName":"h2"},{"title":"Passing the staticPost prop to \"Post\"​","type":1,"pageTitle":"Adding API Data","url":"/WebProgrammingForAppsAndServices/Handling-Events-Rendering-Data/adding-API-data#passing-the-staticpost-prop-to-post","content":" Now that we know we can fetch data at build time for &quot;page&quot; components, the final step is to refactor any components contained on the page that use that data to accept it as a property (props). In our case, this is the &lt;Post /&gt; component. At the moment, it is in charge of fetching its own data on demand at runtime (per request) by placing the &quot;fetch&quot; code within the &quot;useEffect&quot; callback:  import { useState, useEffect } from &quot;react&quot;; export default function Post() { const [post, setPost] = useState(); useEffect(() =&gt; { fetch(`https://jsonplaceholder.typicode.com/posts/1`).then(res =&gt; res.json()).then(data =&gt; { setPost(data); }) }, []); return ( &lt;&gt; &lt;strong&gt;User ID:&lt;/strong&gt; {post?.userId}&lt;br /&gt; &lt;strong&gt;Title:&lt;/strong&gt; {post?.title}&lt;br /&gt; &lt;strong&gt;Body:&lt;/strong&gt; {post?.body}&lt;br /&gt; &lt;/&gt; ) }   since we know that the same data is available in the parent component, we can refactor this code to use &quot;props&quot; instead:  export default function Post(props) { return ( &lt;&gt; &lt;strong&gt;User ID:&lt;/strong&gt; {props.post?.userId}&lt;br /&gt; &lt;strong&gt;Title:&lt;/strong&gt; {props.post?.title}&lt;br /&gt; &lt;strong&gt;Body:&lt;/strong&gt; {props.post?.body}&lt;br /&gt; &lt;/&gt; ) }   Finally, we must ensure that the &lt;Post /&gt; component actually receives the props from the parent &quot;page&quot; component:  export default function Home(props) { return ( &lt;&gt; &lt;Post post={props.staticPost} /&gt; &lt;/&gt; ); }   Now, if you try viewing the component again you should see the data as before, however now the pre-rendered content of the page contains the data:  &lt;strong&gt;User ID:&lt;/strong&gt; &lt;!-- --&gt;1&lt;!-- --&gt;&lt;br&gt; &lt;strong&gt;Title:&lt;/strong&gt; &lt;!-- --&gt;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&lt;!-- --&gt;&lt;br&gt; &lt;strong&gt;Body:&lt;/strong&gt; &lt;!-- --&gt;quia et suscipit suscipit recusandae consequuntur expedita et cum reprehenderit molestiae ut ut quas totam nostrum rerum est autem sunt rem eveniet architecto&lt;!-- --&gt;&lt;br&gt;  ","version":"Next","tagName":"h3"},{"title":"Handling User Events","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Handling-Events-Rendering-Data/handling-user-events","content":"","keywords":"","version":"Next"},{"title":"Adding Parameters​","type":1,"pageTitle":"Handling User Events","url":"/WebProgrammingForAppsAndServices/Handling-Events-Rendering-Data/handling-user-events#adding-parameters","content":" As you can see from the above example, our callback function &quot;increaseNumClicks&quot; is registered to the onClick event by passing the function only - the function is not actually invoked anywhere in our JSX. This works fine, but what if we wish to pass one or more parameters to the function, in addition to the SyntheticEvent (above)?  This can actually be achieved by registering the event as an anonymous function declared within the JSX, which invokes the callback function. For example:  function increaseNumClicks(e, message) { // 'e' is the current event object console.log(message); setNumClicks(numClicks + 1); } return &lt;button onClick={(e) =&gt; { increaseNumClicks(e, &quot;Hello&quot;) }}&gt;Clicks: {numClicks}&lt;/button&gt;   Here, we declare the callback function in place. It accepts a single parameter &quot;e&quot; as before, but the body of the function invokes the callback function. This allows us to continue to pass the SyntheticEvent (e) to our event handler &quot;increaseNumClicks&quot; as well as add any other parameter values. ","version":"Next","tagName":"h2"},{"title":"Developer tools used in this course","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Introduction/dev-tools","content":"","keywords":"","version":"Next"},{"title":"Dev tools summary​","type":1,"pageTitle":"Developer tools used in this course","url":"/WebProgrammingForAppsAndServices/Introduction/dev-tools#dev-tools-summary","content":" Some of the dev tools will be graphical user interface (GUI) apps that run on the base (device/host) operating system (including web browsers). Some will be command line interface (CLI) apps.  The following table shows the tasks to be done, and the apps that enable you to do the tasks, on macOS or Windows.  Task\tmacOS\tWindowsFile system GUI\tFinder\tFile Explorer File system CLI\tTerminal\tCommand Prompt (CMD) Editor\tVisual Studio Code\tVisual Studio Code Node.js, Git\tInstall these on macOS\tInstall these on Windows Web browser(s)including dev tools,debugger\tChrome, Firefox, Opera, Safari\tChrome, Firefox, Opera, Edge HTTP inspector\tVisual Studio Code Extension:Thunder Client\tVisual Studio Code Extension: Thunder Client Data generator\tmockaroo.com online\tmockaroo.com online  ","version":"Next","tagName":"h2"},{"title":"Dev tools usage notes​","type":1,"pageTitle":"Developer tools used in this course","url":"/WebProgrammingForAppsAndServices/Introduction/dev-tools#dev-tools-usage-notes","content":" As you can see from the summary, you will be using GUI versions of the following apps. Each is an app that is designed for the base operating system.  File systemCode editorBrowsers  ","version":"Next","tagName":"h2"},{"title":"Using terminal windows​","type":1,"pageTitle":"Developer tools used in this course","url":"/WebProgrammingForAppsAndServices/Introduction/dev-tools#using-terminal-windows","content":" Do not hesitate to use multiple terminal windows. During development, your professor typically uses a minimum of three, but often about five are opened. Each is opened at a different folder, and therefore is used for different purposes:  One or more is focused on the parent folder of the current app Used to create new apps and to run general commands Another is focused on the current app itself It's used to create new files and to run app-specific commands (e.g. npm start)  ","version":"Next","tagName":"h3"},{"title":"Creating folders on macOS​","type":1,"pageTitle":"Developer tools used in this course","url":"/WebProgrammingForAppsAndServices/Introduction/dev-tools#creating-folders-on-macos","content":" In your Documents folder, create a folder to hold your apps, maybe named dev. (Then inside that folder, each app will be in its own folder.)  ","version":"Next","tagName":"h3"},{"title":"Creating folders on Windows​","type":1,"pageTitle":"Developer tools used in this course","url":"/WebProgrammingForAppsAndServices/Introduction/dev-tools#creating-folders-on-windows","content":" Using File Explorer, create a new folder (maybe named dev) in the root of drive C:. In other words, c:\\dev. Inside that folder, we will be creating separate multiple apps (web APIs, React / Next.js apps, etc.).  ","version":"Next","tagName":"h3"},{"title":"Deleting old or unneeded app/project folders​","type":1,"pageTitle":"Developer tools used in this course","url":"/WebProgrammingForAppsAndServices/Introduction/dev-tools#deleting-old-or-unneeded-appproject-folders","content":" As you know, when you delete a folder (using Finder or File Explorer), the folder is just &quot;marked&quot; as deleted, and is then managed by the operating system's Trash folder (Unix) or Recycle Bin folder (Windows). Later, you can &quot;empty&quot; the Trash folder, which actually and permanently deletes the contents.  Why does this matter to us? Well, a typical Node.js + Express.js, or React / Next.js app has thousands of files and is hundreds of megabytes in size. If you create and then discard five (for example) apps per week, then a month later, you have a huge amount of wasted storage space, which takes a long time to actually delete (it can be minutes).  Therefore, if you want to immediately and permanently delete an old/dead/unneeded app folder:  On macOS Finder, use Option+Command+delete (instead of delete on its own)On Windows File Explorer, use Shift+delete (instead of delete on its own) ","version":"Next","tagName":"h3"},{"title":"JSON Web Tokens (JWT)","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Introduction-JWT/json-web-tokens-jwt","content":"","keywords":"","version":"Next"},{"title":"Securing routes with JWT​","type":1,"pageTitle":"JSON Web Tokens (JWT)","url":"/WebProgrammingForAppsAndServices/Introduction-JWT/json-web-tokens-jwt#securing-routes-with-jwt","content":" We have now identified that we would like to work with JWT to secure our routes. However, how do we go about implementing JWT generation and verification in our server.js? This will involve 3 key modules, obtained from NPM:  ","version":"Next","tagName":"h2"},{"title":"jsonwebtoken​","type":1,"pageTitle":"JSON Web Tokens (JWT)","url":"/WebProgrammingForAppsAndServices/Introduction-JWT/json-web-tokens-jwt#jsonwebtoken","content":" The &quot;jsonwebtoken&quot; module (available using npm install jsonwebtoken --save &amp; added to server.js using: const jwt = require('jsonwebtoken');). In our application, this module is used primarily to &quot;sign&quot; our JSON payload with a 'secret' and generate the token, ie:  let token = jwt.sign({ userName: 'bob' }, 'secret');   We can also use a 3rd parameter to specify options such as expiresIn (A numeric value is interpreted as a seconds count):  jwt.sign({ userName: 'bob' }, 'secret', { expiresIn: 60 * 60 });   For more information on the usage of this function including additional options, methods and errors/codes see the documentaiton for jsonwebtoken on npm  ","version":"Next","tagName":"h3"},{"title":"passport​","type":1,"pageTitle":"JSON Web Tokens (JWT)","url":"/WebProgrammingForAppsAndServices/Introduction-JWT/json-web-tokens-jwt#passport","content":" The &quot;passport&quot; module (available using npm install passport --save &amp; added to server.js using const passport = require(&quot;passport&quot;);) is described as the following:  Passport is Express-compatible authentication middleware for Node.js. Passport's sole purpose is to authenticate requests, which it does through an extensible set of plugins known as strategies. Passport does not mount routes or assume any particular database schema, which maximizes flexibility and allows application-level decisions to be made by the developer. The API is simple: you provide Passport a request to authenticate, and Passport provides hooks for controlling what occurs when authentication succeeds or fails.  In our application, we will be using the following methods:  &quot;initialize&quot;: This method is invoked when we add the passport middleware using the familiar app.use() method, ie: app.use(passport.initialize()); &quot;authenticate&quot;: The &quot;authenticate&quot; method is used as a middleware function that can be used for each of our routes that we wish to secure. For example: app.get(&quot;/api/vehicles&quot;, passport.authenticate('jwt', { session: false }), (req, res) =&gt; { // ... } &quot;use&quot;: The &quot;use&quot; method is where we specify our &quot;strategy&quot; for authenticating our routes. This is done near the top of server.js after the &quot;strategy&quot; is configured, ie: passport.use(strategy); info Passport currently supports over 480 different authentication strategies including Facebook, Google and many others  ","version":"Next","tagName":"h3"},{"title":"passport-jwt​","type":1,"pageTitle":"JSON Web Tokens (JWT)","url":"/WebProgrammingForAppsAndServices/Introduction-JWT/json-web-tokens-jwt#passport-jwt","content":" Since we will be using JWT, our strategy will be &quot;passport-jwt&quot; (available using npm install passport-jwt --save &amp; added to server.js using const passportJWT = require(&quot;passport-jwt&quot;);). Using &quot;passportJWT&quot;, we can specify the &quot;strategy&quot; using a set of options (defined in our server as an object called jwtOptions: let jwtOptions = {};), such as the &quot;secretOrKey&quot;, as well as specifying how to read the jwt from the authentication header.  For example, once we have a reference to the &quot;passport-jwt&quot; module (ie: &quot;passwordJWT&quot;, from above), we can use the following code to configure our strategy:  // JSON Web Token Setup let ExtractJwt = passportJWT.ExtractJwt; let JwtStrategy = passportJWT.Strategy; // Configure its options let jwtOptions = { jwtFromRequest: ExtractJwt.fromAuthHeaderWithScheme('jwt'), secretOrKey: '&amp;0y7$noP#5rt99&amp;GB%Pz7j2b1vkzaB0RKs%^N^0zOP89NT04mPuaM!&amp;G8cbNZOtH', }; // IMPORTANT - this secret should be a long, unguessable string // (ideally stored in a &quot;protected storage&quot; area on the web server). // We suggest that you generate a random 50-character string // using the following online tool: // https://lastpass.com/generatepassword.php let strategy = new JwtStrategy(jwtOptions, function (jwt_payload, next) { console.log('payload received', jwt_payload); if (jwt_payload) { // The following will ensure that all routes using // passport.authenticate have a req.user._id, req.user.userName, req.user.fullName &amp; req.user.role values // that matches the request payload data next(null, { _id: jwt_payload._id, userName: jwt_payload.userName, fullName: jwt_payload.fullName, role: jwt_payload.role, }); } else { next(null, false); } });   There's a lot going on in the above code, but the key pieces involve first defining the jwtOptions (using the jwtFromRequest and secretOrKey properties) and then defining the &quot;strategy&quot; as a (JwtStrategy) middleware function using the jwtOptions and providing a callback function. The callback function simply checks that there is indeed a valid jwt_payload and if so, invoke the next() method with the payload data as it's second parameter. If the jwt_payload is invalid, the next() method will be called without the payload data, which will cause our server to return a 401 (Unauthorized) error.  ","version":"Next","tagName":"h3"},{"title":"Adding the code to server.js​","type":1,"pageTitle":"JSON Web Tokens (JWT)","url":"/WebProgrammingForAppsAndServices/Introduction-JWT/json-web-tokens-jwt#adding-the-code-to-serverjs","content":" With all of the individual pieces of our JWT solution identified, it's now time to update server.js:  ","version":"Next","tagName":"h2"},{"title":"Step 1: Installation​","type":1,"pageTitle":"JSON Web Tokens (JWT)","url":"/WebProgrammingForAppsAndServices/Introduction-JWT/json-web-tokens-jwt#step-1-installation","content":" As you will recall (from above), our JWT enabled server.js will require 3 modules: &quot;jwt&quot;, &quot;passport&quot; &amp; &quot;passport-jwt&quot; to function correctly. Using npm, install them into the project:  Terminal npm install jsonwebtoken --save npm install passport --save npm install passport-jwt --save   ","version":"Next","tagName":"h3"},{"title":"Step 2: Requiring the Modules​","type":1,"pageTitle":"JSON Web Tokens (JWT)","url":"/WebProgrammingForAppsAndServices/Introduction-JWT/json-web-tokens-jwt#step-2-requiring-the-modules","content":" After installation, add the modules to our list of imports at the top of server js:  server.js const jwt = require('jsonwebtoken'); const passport = require('passport'); const passportJWT = require('passport-jwt');   ","version":"Next","tagName":"h3"},{"title":"Step 3: Configuring the \"Strategy\"​","type":1,"pageTitle":"JSON Web Tokens (JWT)","url":"/WebProgrammingForAppsAndServices/Introduction-JWT/json-web-tokens-jwt#step-3-configuring-the-strategy","content":" With our modules added, we can now add the code to configure the JWT &quot;strategy&quot;. Recall, this involves creating a jwtOptions object that we can pass to the jwtStrategy constructor, along with a callback function that looks at the &quot;jwt_payload&quot; parameter. For our purposes, we can use the code exactly as it has been identified above, placed before our first &quot;app.use()&quot; statement. However, a new &quot;secretOrKey&quot; property should be generated (optionally using the &quot;Generate Password&quot; Tool from LastPass).  caution If the &quot;user&quot; has different properties (ie, something other than, &quot;_id&quot;, &quot;userName&quot;, &quot;fullName&quot; and &quot;role&quot;), the data passed in the next() function should be modified to reflect the correct properties.  How to add the strategy:  In server.js, add this code before the first usage of app.use():  server.js, before the first app.use() statement // JSON Web Token Setup let ExtractJwt = passportJWT.ExtractJwt; let JwtStrategy = passportJWT.Strategy; // Configure its options let jwtOptions = { jwtFromRequest: ExtractJwt.fromAuthHeaderWithScheme('jwt'), secretOrKey: '&amp;0y7$noP#5rt99&amp;GB%Pz7j2b1vkzaB0RKs%^N^0zOP89NT04mPuaM!&amp;G8cbNZOtH', }; // IMPORTANT - this secret should be a long, unguessable string // (ideally stored in a &quot;protected storage&quot; area on the web server). // We suggest that you generate a random 50-character string // using the following online tool: // https://lastpass.com/generatepassword.php let strategy = new JwtStrategy(jwtOptions, function (jwt_payload, next) { console.log('payload received', jwt_payload); if (jwt_payload) { // The following will ensure that all routes using // passport.authenticate have a req.user._id, req.user.userName, req.user.fullName &amp; req.user.role values // that matches the request payload data next(null, { _id: jwt_payload._id, userName: jwt_payload.userName, fullName: jwt_payload.fullName, role: jwt_payload.role, }); } else { next(null, false); } });   ","version":"Next","tagName":"h3"},{"title":"Step 4: Set the Strategy & Add the Middleware​","type":1,"pageTitle":"JSON Web Tokens (JWT)","url":"/WebProgrammingForAppsAndServices/Introduction-JWT/json-web-tokens-jwt#step-4-set-the-strategy--add-the-middleware","content":" The last step needed to tell our server that we wish to use Passport (with the &quot;JWT&quot; strategy), by adding the function as middleware to our server using app.use():  server.js // tell passport to use our &quot;strategy&quot; passport.use(strategy); // add passport as application-level middleware app.use(passport.initialize());   ","version":"Next","tagName":"h3"},{"title":"Step 5: Generating & Sending the JWT​","type":1,"pageTitle":"JSON Web Tokens (JWT)","url":"/WebProgrammingForAppsAndServices/Introduction-JWT/json-web-tokens-jwt#step-5-generating--sending-the-jwt","content":" At this point, we're all set to work with JWT. We have the correct modules added and the Passsport middleware is configured and added to our application. However, before we can protect our routes (see below), we need to first send the token back to the client. Currently, our api/login route simply sends the following data with a 200 status code to indicate that the login was indeed successful:  { &quot;message&quot;: &quot;login successful&quot; }   If we wish to grant this user access to our (soon to be) protected routes, we must also provide the JWT as a means of identification. Using the sign() method of the included jsonwebtoken module, we can generate it and send it back to the client alongside the &quot;message&quot;.  To accomplish this, we need to add the following code to our &quot;/api/login&quot; route at the top of our userService.checkUser(req.body).then( ... ) callback:  server.js let payload = { _id: user._id, userName: user.userName, fullName: user.fullName, role: user.role, }; let token = jwt.sign(payload, jwtOptions.secretOrKey);   This will generate a JWT for us using the user's &quot;_id&quot;, &quot;userName&quot;, &quot;fullName&quot; and &quot;role&quot; properties, encrypted with our &quot;secretOrKey&quot; (identified when we configured our passport strategy in jwtOptions).  Once we have the token, we can send it back along with the message to the user using res.json() (typically using the property: &quot;token&quot;):  server.js res.json({ message: 'login successful', token: token });   ","version":"Next","tagName":"h3"},{"title":"Step 6: Protecting Route(s) using the Passport Middleware​","type":1,"pageTitle":"JSON Web Tokens (JWT)","url":"/WebProgrammingForAppsAndServices/Introduction-JWT/json-web-tokens-jwt#step-6-protecting-routes-using-the-passport-middleware","content":" In order to restrict access to our /api/vehicles route, we need to employ the Passport middleware &quot;authenticate&quot; function (identified above in our authenticate() example).  This simply involves adding the code:  passport.authenticate('jwt', { session: false })   as a middleware function to any routes that we wish to protecet (ie: our /api/vehicles route):  server.js app.get(&quot;/api/vehicles&quot;, passport.authenticate('jwt', { session: false }), (req, res) =&gt; { // ... }   You will notice that we provide the option &quot;session: false&quot;. This is because we require credentials to be supplied with each request, rather than set up a session. For more information and configuration options, see the Passport.js documentation, under &quot;Authenticate&quot;.  ","version":"Next","tagName":"h3"},{"title":"Testing the New Functionality​","type":1,"pageTitle":"JSON Web Tokens (JWT)","url":"/WebProgrammingForAppsAndServices/Introduction-JWT/json-web-tokens-jwt#testing-the-new-functionality","content":" We have now completed all of the changes that are required on our server.js and are ready to test our Simple API and see if this technology really works to protect our routes.  To test this, we must insure the following series of actions yields the expected results (listed below):  Action: Attempt to access the route /api/vehicles as before (without supplying a JWT). Expected Result: Server returns a 401 error code and the text &quot;unauthorized&quot;. Action: Log in as user &quot;bob&quot; (as above) and copy the value of the returned &quot;token&quot; property. Action: Attempt to access the route /api/vehicles as before, only this time add the header &quot;Authorization&quot; with the value &quot;JWT&quot; followed by a space, followed by the returned &quot;token&quot; that was sent when &quot;bob&quot; logged in (above) Expected Result: Vehicle data is returned Action: Attempt to access the route /api/vehicles again, only this time slightly modify the JWT (ie: remove/add a character). Expected Result: Server returns a 401 error code and the text &quot;unauthorized&quot;. ","version":"Next","tagName":"h2"},{"title":"Web API With Authentication","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Introduction-JWT/web-api-with-authentication","content":"","keywords":"","version":"Next"},{"title":"Quick note on \"CORS\"​","type":1,"pageTitle":"Web API With Authentication","url":"/WebProgrammingForAppsAndServices/Introduction-JWT/web-api-with-authentication#quick-note-on-cors","content":" At this point, you may be asking &quot;What is 'cors' and why do we need this module?&quot;. CORS stands for &quot;Cross-Origin Resource Sharing&quot; and it is essentially a way to enable JavaScript to make an AJAX call from one origin (domain) to a server on a different domain. This is not permitted by default, as browsers restrict these types of requests for security reasons. If we did not enable CORS, we could not use AJAX to make requests from our localhost to our API, if our API is running online.  In addition to simply allowing all AJAX requests from outside domains, the CORS module also allows you to &quot;whitelist&quot; certain domains, thereby allowing access for specific domains, while restricting access from all others.  More details can be found on MDN under &quot;Cross-Origin Resource Sharing (CORS)&quot; and the &quot;cors&quot; module on NPM  ","version":"Next","tagName":"h2"},{"title":"Account Management & Security​","type":1,"pageTitle":"Web API With Authentication","url":"/WebProgrammingForAppsAndServices/Introduction-JWT/web-api-with-authentication#account-management--security","content":" With our extremely simple &quot;vehicles&quot; API in place and producing data, we can now move on to discuss how we might protect this data from unwanted (unauthorized) access. This will include creating routes that allow users to register accounts (persisted in MongoDB with encrypted passwords) as well as logging in to the system.  ","version":"Next","tagName":"h2"},{"title":"MongoDB Atlas & MongoDB​","type":1,"pageTitle":"Web API With Authentication","url":"/WebProgrammingForAppsAndServices/Introduction-JWT/web-api-with-authentication#mongodb-atlas--mongodb","content":" As mentioned above, we will be persisting registered accounts using MongoDB in the cloud database platform: MongoDB Atlas. If you're not familiar with MongoDB Atlas at this point, you may review the basic setup here:  MongoDB Atlas Tutorial  Once your cluster is up and running correctly (ie: A &quot;Database User&quot; has been created, IP Access is &quot;Allowed from Anywhere&quot;, etc):  In MongoDB, setup a new &quot;simple-API-users&quot; database with a &quot;users&quot; collection for the simple API. Obtain a copy of the connection string - this should look something like:  mongodb+srv://user:&lt;password&gt;@cluster0-abc1.mongodb.net/?retryWrites=true&amp;w=majority   Add the text: simple-API-users in the above connection string after the last part of the url before the query parameters, ie: mongodb.net/simple-API-users. In addition, you must update the values for user and &lt;password&gt; to match the credentials that you created for the &quot;Database User&quot;. For example:  mongodb+srv://user:&lt;password&gt;@cluster0-abc1.mongodb.net/simple-API-users?retryWrites=true&amp;w=majority   Keep track of your connection string, as we will be using it in the next piece:  ","version":"Next","tagName":"h3"},{"title":"Updating the \"user-service\"​","type":1,"pageTitle":"Web API With Authentication","url":"/WebProgrammingForAppsAndServices/Introduction-JWT/web-api-with-authentication#updating-the-user-service","content":" To keep our DB authentication piece clean, we will be making use of the promise-based &quot;user-service&quot; module, defined in the user-service.js file.  In the user-services.js file, you will see a space for your MongoDB connection string. Enter it now before proceeding.  Observe the definition of the &quot;user&quot; Schema (userSchema). The schema consists of 4 simple fields:  userName: A (unique) string representing the user's login/user name password: The user's password fullName: Ths user's full name role: The user's role, ie &quot;administrator&quot;, &quot;data-entry&quot;, &quot;maintenance&quot;, etc. (the user's role will define exactly what in the API the user has access to. For our example we will not be using this field, as every user will have access to all vehicles)  Below this, you should note that there are 3 exported functions:  connect(): This function simply ensures that we can connect to the DB and if successful, assign the &quot;User&quot; object as a &quot;User&quot; model, using the &quot;users&quot; collection (specified by userSchema). registerUser(userData): Ensures that the provided passwords match and that the user name is not already taken. If the userData provided meets this criteria, add the user to the system. checkUser(userData): This function ensures that the user specified by &quot;userData&quot; is in the system and has the correct password (used for logging in)  Lastly, before we can move on to test the application (below) we must update our &quot;server.js&quot; to &quot;connect&quot; to our user service before we start the server.  To do this, go to the server.js file, and wrap the existing app.listen() function within the userService.connect() function:  server.js // wrap the existing app.listen in a userService.connect() call: userService.connect().then(()=&gt;{ app.listen(HTTP_PORT, ()=&gt;{console.log(&quot;API listening on: &quot; + HTTP_PORT)}); }) .catch((err)=&gt;{ console.log(&quot;unable to start the server: &quot; + err); process.exit(); });   ","version":"Next","tagName":"h3"},{"title":"Hashed Passwords with bcrypt (bcryptjs)​","type":1,"pageTitle":"Web API With Authentication","url":"/WebProgrammingForAppsAndServices/Introduction-JWT/web-api-with-authentication#hashed-passwords-with-bcrypt-bcryptjs","content":" Up to this point, our user service has been designed to store passwords as plain text. This is a serious security concern as passwords must always be encrypted. To achieve this, we will be making use of the password-hashing function: &quot;bcrypt&quot;.  For our project, we will use the &quot;bcryptjs&quot; library, a npm package that implements the bcrypt algorithm in Javascript.  In your project, use npm to install bcryptjs:  Terminal npm install bcryptjs   At the top of user-service.js, &quot;require&quot; the bcrypt module:  user-service.js const bcrypt = require('bcryptjs');   After importing bcryptjs into the user-service.js file, we can use library's hash() function to create a hashed version of a plan text password. Here's how the function works:  // Encrypt the plain text: &quot;myPassword123&quot; bcrypt.hash('myPassword123', 10).then((hash) =&gt; { // Hash the password using a Salt that was generated using 10 rounds // TODO: Store the resulting &quot;hash&quot; value in the DB });   Apply this process to our &quot;registerUser&quot; function (thereby hashing the provided password when registering the user), our code will look like this:  user-service.js module.exports.registerUser = function (userData) { return new Promise(function (resolve, reject) { if (userData.password != userData.password2) { reject(&quot;Passwords do not match&quot;); } else { bcrypt.hash(userData.password, 10).then(hash=&gt;{ // Hash the password using a Salt that was generated using 10 rounds userData.password = hash; let newUser = new User(userData); newUser.save().then(() =&gt; { resolve(&quot;User &quot; + userData.userName + &quot; successfully registered&quot;); }).catch(err =&gt; { if (err.code == 11000) { reject(&quot;User Name already taken&quot;); } else { reject(&quot;There was an error creating the user: &quot; + err); } }); }).catch(err =&gt; reject(err)); } }); };   This makes the code a little longer and harder to follow, but we are really only adding the bcrypt.hash() method to our existing function.  If we wish to compare a plain text password to a hashed password, we can use bcrypt's compare() method with the following logic:  // Pull the password &quot;hash&quot; value from the DB and compare it to &quot;myPassword123&quot; (match) bcrypt.compare('myPassword123', hash).then((res) =&gt; { // if res === true, the passwords match });   If we apply this to our &quot;checkUser&quot; function (thereby comparing the DB's hashed password with the provided password), our code will look like this:  user-service.js module.exports.checkUser = function (userData) { return new Promise(function (resolve, reject) { User.find({ userName: userData.userName }) .limit(1) .exec() .then((users) =&gt; { if (users.length == 0) { reject(&quot;Unable to find user &quot; + userData.userName); } else { bcrypt.compare(userData.password, users[0].password).then((res) =&gt; { if (res === true) { resolve(users[0]); } else { reject(&quot;Incorrect password for user &quot; + userData.userName); } }); } }).catch((err) =&gt; { reject(&quot;Unable to find user &quot; + userData.userName); }); }); };   Not much has changed here. Instead of simply comparing userData.password with users[0].password directly, we use the bcrypt.compare() method.  ","version":"Next","tagName":"h3"},{"title":"Adding & Testing Authentication Routes​","type":1,"pageTitle":"Web API With Authentication","url":"/WebProgrammingForAppsAndServices/Introduction-JWT/web-api-with-authentication#adding--testing-authentication-routes","content":" Now that we have a working &quot;user&quot; service that will handle registering and validating user information, we will add new API routes (/api/) for authentication to our server application.  Since our new routes will be accepting input (via JSON, posted to the route), we will need to configure our server to correctly parse &quot;JSON&quot; formatted data. This can be accomplished by adding express.json() built-in middleware before our route definitions:  server.js app.use(express.json());   With the middleware correctly configured, we can reliably assume that the &quot;body&quot; property of the request (req) will contain the properties and values of the data sent from the AJAX request.  info We do not yet have a UI to gather user information for registration and validation, so we must make use of an API testing tool such as the Thunder Client Extension to make requests and provide POST data when testing our new routes.  Creating a register user route​  Start by creating a route for registering new users: /api/register  This route simply collects user registration information sent using POST to the API in the form of a JSON-formatted string, ie:  { &quot;userName&quot;: &quot;bob&quot;, &quot;password&quot;: &quot;myPassword&quot;, &quot;password2&quot;: &quot;myPassword&quot;, &quot;fullName&quot;: &quot;Robert Wiley&quot;, &quot;role&quot;: &quot;administrator&quot; }   Fortunately, our userService.registerUser() function is perfectly set up to handle this type of data. It will validate whether password &amp; password2 match and check that the user name &quot;bob&quot; is not taken. If the data meets these requirements, the provided password will be hashed and the user will be entered into the system. Therefore, our new /api/register route is very simple; it must simply pass the posted data to the userService for processing and report back when it has completed, ie:  server.js app.post('/api/register', (req, res) =&gt; { userService .registerUser(req.body) .then((msg) =&gt; { res.json({ message: msg }); }) .catch((msg) =&gt; { res.status(422).json({ message: msg }); }); });   info The 422 error code communicates back to the client that the server understands the content type of the request and the syntax is correct but was unable to process the data (see: 422 Unprocessable Entity).  To test this new route:  Stop and start your API (server.js) again and proceed to make the following request in your API testing tool (example: Thunderclient):  Make sure POST is selected in the request type dropdownIn the address bar, type: &quot;http://localhost:8080/api/register&quot;In the Headers tab, ensure that &quot;Content-Type&quot; is selected with a value of &quot;application/json&quot;In the Body tab, copy and paste our information for user &quot;bob&quot; in the provided text area:  { &quot;userName&quot;: &quot;bob&quot;, &quot;password&quot;: &quot;myPassword&quot;, &quot;password2&quot;: &quot;myPassword&quot;, &quot;fullName&quot;: &quot;Robert Wiley&quot;, &quot;role&quot;: &quot;administrator&quot; }   Once the request is processed, it should return with a status 200 and the JSON:  { &quot;message&quot;: &quot;User bob successfully registered&quot; }   In the database, a user document will be inserted into collection.  Creating a login route​  In addition to adding users to the system, we must also be able to authenticate users and allow them to &quot;login&quot; before being granted access to the data: /api/login  In this case, all of the work required for authenticating user data is done in the &quot;dataAuth.checkUser()&quot; method. So like &quot;/api/register&quot;, our &quot;/api/login&quot; route will once again pass the posted data to the userService for processing and report back when it has completed, ie:  server.js app.post('/api/login', (req, res) =&gt; { userService .checkUser(req.body) .then((user) =&gt; { res.json({ message: 'login successful' }); }) .catch((msg) =&gt; { res.status(422).json({ message: msg }); }); });   To test this new route:  Stop and start your API (server.js) and make another request using your API testing tool. We will keep most of the values the same, with the following exceptions:  In the address bar, type: &quot;http://localhost:8080/api/login&quot;In the Body tab, copy and paste our information for user &quot;bob&quot; in the provided text area:  { &quot;userName&quot;: &quot;bob&quot;, &quot;password&quot;: &quot;myPassword&quot; }   When you're sure you've entered everything correctly and your server is running, hit the blue Send button to send the POST data to the API.  Once the request is processed, it should return with a status 200 and the JSON:  { &quot;message&quot;: &quot;login successful&quot; }   Try entering incorrect credentials in the request body (ie: a different &quot;userName&quot;, or an incorrect &quot;password&quot;) to verify that our service is indeed functioning properly and will not send the &quot;login successful&quot; message to unauthorized users.  In your API testing tool, update the Body with username bob, but an incorrect password:  { &quot;userName&quot;: &quot;bob&quot;, &quot;password&quot;: &quot;1234&quot; }   Once the request is processed, it should return with a status 422 (Unprocessable Entity) and the JSON:  { &quot;message&quot;: &quot;Incorrect password for user bob&quot; }  ","version":"Next","tagName":"h3"},{"title":"Web Services Introduction","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Introduction/web-services-reintroduction","content":"","keywords":"","version":"Next"},{"title":"What is a web service?​","type":1,"pageTitle":"Web Services Introduction","url":"/WebProgrammingForAppsAndServices/Introduction/web-services-reintroduction#what-is-a-web-service","content":" A web service is an application that runs on a web server, and is accessed programmatically.  When we parse this short sentence, and consider the meanings behind the simple words, we reveal some very important concepts:  HTTP is the protocol, enabling wide use and scalabilityHumans don't use a web service directly - instead, the application they are using creates and sends a request to the web service, and handles the response in a way that's meaningful to the applicationA web service's functionality is discoverable, and typically known as an application programming interface (API)  Web services can be developed on any web-connected technology platform, in any language, and can be used on any kind of device.  ","version":"Next","tagName":"h2"},{"title":"What's the difference between a web app, and a web service?​","type":1,"pageTitle":"Web Services Introduction","url":"/WebProgrammingForAppsAndServices/Introduction/web-services-reintroduction#whats-the-difference-between-a-web-app-and-a-web-service","content":" Study this diagram to understand the differences, and then be prepared to explain them to someone else:    ","version":"Next","tagName":"h2"},{"title":"Give me a brief history lesson on web services​","type":1,"pageTitle":"Web Services Introduction","url":"/WebProgrammingForAppsAndServices/Introduction/web-services-reintroduction#give-me-a-brief-history-lesson-on-web-services","content":" With the rise of the web's use and popularity in the 1990s, efforts were made to define and specify web services.  This led to the de facto standardization of SOAP XML web services. Often described as &quot;big web services&quot;, or &quot;legacy web services&quot;, SOAP XML web services are the implementation of remote procedure calls on the web. This kind of web service typically has one specific endpoint address, and requestors must create and send a data package (which conforms to a data format named SOAP), and then process the response (which also conforms to SOAP).  However, other efforts took advantage of the web and its existing features and benefits. In other words, they simply followed the HTTP specification and its ex post facto architecture definition, to create true and pure web services. These kinds of web services, often termed &quot;Web API&quot;, &quot;RESTful web services&quot;, or &quot;HTTP services&quot;, exploded in use and popularity from about 2005 onwards, and are now the preferred design approach.  ","version":"Next","tagName":"h2"},{"title":"Web services development and deployment environment​","type":1,"pageTitle":"Web Services Introduction","url":"/WebProgrammingForAppsAndServices/Introduction/web-services-reintroduction#web-services-development-and-deployment-environment","content":" This course will use the following frameworks and tools:  Node.jsExpress.jsMongoDBVisual Studio Code  Each web service that you create will be treated as a separate and distinct program, and not bundled in with the front end client (browser) app that you may be working on. It will be concerned only with listening then responding to requests that come in.  During development, you will use an HTTP inspector app, like Thunder Client, to create and send requests to a web service.  Thunder Client Documentation  Then, you will be creating separate web app clients, which send requests to your web service.  Each program can be individually and separately deployed to any device platform that meets your needs.  ","version":"Next","tagName":"h3"},{"title":"Terminology​","type":1,"pageTitle":"Web Services Introduction","url":"/WebProgrammingForAppsAndServices/Introduction/web-services-reintroduction#terminology","content":" As your web programming competency grows, it is important to know and be able to correctly use some common web programming terms.  ","version":"Next","tagName":"h2"},{"title":"Web app, and web service​","type":1,"pageTitle":"Web Services Introduction","url":"/WebProgrammingForAppsAndServices/Introduction/web-services-reintroduction#web-app-and-web-service","content":" If you create a server-based program, and it is intended to be used mostly by web browsers, we typically call that a web app.  Alternatively, if you create a server-based program, and it is intended to be used programmatically (by iOS and Android apps, or by JavaScript in a browser, or by an &quot;HTTP client&quot; module in a native Windows, macOS, or Linux app, we typically call that a web service.  ","version":"Next","tagName":"h3"},{"title":"Resource​","type":1,"pageTitle":"Web Services Introduction","url":"/WebProgrammingForAppsAndServices/Introduction/web-services-reintroduction#resource","content":" A resource is a digital asset.  Familiar examples include a document, or an image.  How do you identify a resource? By using its URI (uniform resource identifier). The URI standard is described in RFC 3986, and also in a Wikipedia article.  What is the format, or representation, of the resource? Well, it depends on the design of the web service, and sometimes the needs of the requestor.  ","version":"Next","tagName":"h3"},{"title":"Representation​","type":1,"pageTitle":"Web Services Introduction","url":"/WebProgrammingForAppsAndServices/Introduction/web-services-reintroduction#representation","content":" As defined above, a resource is a digital asset.  A representation is a digital asset that is formatted as a specific internet media type.  The concrete or real form of a representation &quot;is a sequence of bytes, plus ... metadata to describe those bytes&quot;. From Roy Fielding, &quot;Architectural Styles and the Design of Network-based Software Architectures&quot;, section 5.2.1.2  Think about a scenario where a web service was used to manage students in a course. Each student is a resource - a digital asset - that can be identified by a URI.  If a user requested a specific resource through a web browser, you would expect that the resource would be represented by some HTML that included the student's name, student ID, and so on.  Alternatively, it's also possible to request the same specific resource - using the same URI - but also specify that it be returned in a data format (like JSON or XML, discussed later). The server will return a data representation of the resource.  Or, maybe the request specified that the student's photo be returned as the resource's representation. Again, the same URI is used.  So, in summary, a resource's representation can vary to meet the needs of the web service programmer or the web service user. The requestor and responder use a feature called content negotiation to make this happen.  Every representation is defined by an internet media type.    ","version":"Next","tagName":"h3"},{"title":"Internet media type​","type":1,"pageTitle":"Web Services Introduction","url":"/WebProgrammingForAppsAndServices/Introduction/web-services-reintroduction#internet-media-type","content":" An internet media type is defined as a data format for a representation of a resource on the internet.  The data formats are standardized, published, and well-known, by the IANA (the Internet Assigned Numbers Authority).  This Wikipedia article is an acceptable introduction to internet media types.  For web service programmers, two important internet media types are used as data formats, JSON and XML.  Both are plain-text data formats. They are somewhat human-readable.  Later, you will probably learn how to work with non-text media types. From now on, we will typically work with plain-text JSON.  ","version":"Next","tagName":"h3"},{"title":"Get started with JSON​","type":1,"pageTitle":"Web Services Introduction","url":"/WebProgrammingForAppsAndServices/Introduction/web-services-reintroduction#get-started-with-json","content":" JSON is an initialism for JavaScript Object Notation.  It is a lightweight data-interchange format. It is language-independent, however it uses conventions that were first suggested by the JavaScript object literal or initializer. JSON has become the de facto data-interchange format standard.  Here's an overview of JSON from Wikipedia.  Here's the official web site for JSON, by Douglas Crockford.  Although JSON is historically derived from JavaScript object literals, there are a few notable differences to programmers who are new to JSON:  In JSON, each property name must be surrounded by quotes (typically double-quotes). In pure JavaScript, this is optional for single-word property names. In JSON, there is no Date type. Dates are expressed as strings, almost always in ISO 8601 format. In contrast, JavaScript does have a Date object (not a type, but an object).  While we're on the topic of data types, the property values will be any of about five types:  stringnumber (integer or decimal)object (i.e. )array (i.e. [ ] )null  String values must be surrounded by quotes.  The web services that you create in this course will rely on the JSON internet media type.  ","version":"Next","tagName":"h2"},{"title":"State​","type":1,"pageTitle":"Web Services Introduction","url":"/WebProgrammingForAppsAndServices/Introduction/web-services-reintroduction#state","content":" Let's discuss state in this section of the notes, and in the next section.  ","version":"Next","tagName":"h2"},{"title":"Data​","type":1,"pageTitle":"Web Services Introduction","url":"/WebProgrammingForAppsAndServices/Introduction/web-services-reintroduction#data","content":" In this section, we are interested in the state of the data elements in a distributed system. (In the next section, we will be interested in the state of the interaction among programs in a distributed system.)  In a web app or web service context, the meaning of the word state is the current value of a resource.  At the server, a resource could be in the form of an item in a persistent store (i.e. a database system), or it could be in the form of an item that is generated upon request. That difference doesn't matter; what matters is that when a resource is requested, its current state is sent, or transferred, as the response.  A resource's state can be changed (or modified), of course. The stimulus for the change can originate from anywhere in the distributed system, ranging from server-based batch or automatic processes that modify the persistent store (apart from or separately from the web app or web service), through to client-sent requests that are received by a web app or web service.  Does this work the other way, when a client app changes the state of an resource? Yes. A client can send a request that includes a representation of a resource. (For example, an HTTP POST or PUT request.) The new or updated state of the resource is transferred, from the client app to the server (web app or web service). Upon acceptance (and validation etc.), the server appends to or updates the resource in the persistent store.  ","version":"Next","tagName":"h3"},{"title":"Interaction​","type":1,"pageTitle":"Web Services Introduction","url":"/WebProgrammingForAppsAndServices/Introduction/web-services-reintroduction#interaction","content":" In this section, we are interested in the state of the interaction among programs in a distributed system. (In the previous section, we were interested in the state of the data elements in a distributed system.)  One of the characteristics of a web app or web service is that it can be used by a single client app, or by theoretically unlimited numbers of client apps.  Does the server keep track of the interaction state with each client? No. This responsibility is borne by the client app. This design feature is one of most important parts of the web.  &quot;Each request from client to server must contain all of the information necessary to understand the request, and cannot take advantage of any stored context on the server. Session state is kept entirely on the client.&quot; (Roy Fielding, PhD thesis, section 3.4.3)  The main point is that the server effectively treats every request as separate/discrete/atomic, and does not actively maintain any notion of a logical session over time. In other words, no interaction state maintenance or management is done at the server.  Therefore, if the interaction state of a (message exchange) session is important to maintain, it's done by the client.  ","version":"Next","tagName":"h3"},{"title":"REST​","type":1,"pageTitle":"Web Services Introduction","url":"/WebProgrammingForAppsAndServices/Introduction/web-services-reintroduction#rest","content":" Now we can circle back to REST. It is an acronym for REpresentational State Transfer.  The implementation / description of a &quot;REST API&quot; can be simply described &quot;as a way to use the HTTP protocol with a standard message format to perform operations on data&quot;. However, while that explanation is clear and understandable when first learning about REST, it embeds a much deeper understanding that can come only through more learning and experience. If a student is serious about a career that includes web programming, then it is essential to study Roy Fielding's PhD dissertation from the year 2000, Architectural Styles and the Design of Network-based Software Architectures.  More information about Roy Fielding is here.  Will we be creating &quot;REST APIs&quot;? Yes, if we follow all the guidance and practices. However, that will come only with more knowledge and experience.  As a result, it may be more accurate and safer to use the term &quot;web API&quot; when naming or describing our web service work.  ","version":"Next","tagName":"h2"},{"title":"Web API​","type":1,"pageTitle":"Web Services Introduction","url":"/WebProgrammingForAppsAndServices/Introduction/web-services-reintroduction#web-api","content":" The term &quot;web API&quot; captures the essence of &quot;REST API&quot; above, but it uses a more generic and easier to understand or explain word. Arguably, every computer user has a reasonably accurate knowledge of the word &quot;web&quot;, so that word doesn't have to be explained. The expansion of the &quot;API&quot; initialism is also easy to understand or explain. It's just a bit better (and safer) than using &quot;REST&quot;, and avoids the immediate need to cover large chunks of a 180-page PhD dissertation.  So, let's define &quot;web API&quot; as an API to a web app or web service.  ","version":"Next","tagName":"h3"},{"title":"In summary​","type":1,"pageTitle":"Web Services Introduction","url":"/WebProgrammingForAppsAndServices/Introduction/web-services-reintroduction#in-summary","content":" In this document, we have defined and explained a web service.  Terminology was introduced, argued, and explained.  Now, you're ready to take the next step, and create web services that support the main focus of this course, which is front end client-side browser apps. ","version":"Next","tagName":"h2"},{"title":"Creating and Testing a Web Service","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Introduction/creating-testing-web-service","content":"","keywords":"","version":"Next"},{"title":"Confirm that your tooling is ready​","type":1,"pageTitle":"Creating and Testing a Web Service","url":"/WebProgrammingForAppsAndServices/Introduction/creating-testing-web-service#confirm-that-your-tooling-is-ready","content":" Before writing and running the app, confirm that your computer's tooling is ready.  ","version":"Next","tagName":"h2"},{"title":"If your system does not yet have the Node.js app dev ecosystem​","type":1,"pageTitle":"Creating and Testing a Web Service","url":"/WebProgrammingForAppsAndServices/Introduction/creating-testing-web-service#if-your-system-does-not-yet-have-the-nodejs-app-dev-ecosystem","content":" Install Node.js (which also installs npm). Verify its status:  node --version npm --version   ","version":"Next","tagName":"h3"},{"title":"If your system does not have the developer tools​","type":1,"pageTitle":"Creating and Testing a Web Service","url":"/WebProgrammingForAppsAndServices/Introduction/creating-testing-web-service#if-your-system-does-not-have-the-developer-tools","content":" Install gitInstall more browsers (assume that Safari is already there; add Chrome, Firefox, and Opera)Install Visual Studio Code (aka VS Code)  ","version":"Next","tagName":"h3"},{"title":"Create a project to hold the web service​","type":1,"pageTitle":"Creating and Testing a Web Service","url":"/WebProgrammingForAppsAndServices/Introduction/creating-testing-web-service#create-a-project-to-hold-the-web-service","content":" Using Terminal, navigate to the file system location that will hold the project. Create a new folder to hold the project.  Navigate into that folder. Create an empty server.js file. Create an empty index.html file. It's also a good idea to create an empty README.md file.  Now, initialize the folder as a Node.js app:  npm init   Make sure you specify server.js as its entry point. Add your name as the author name, and add a description if you wish. The other settings can stay at the suggested default values.  Add Express.js:  npm install express   Now, edit the project.  code .   Open the server.js file for editing. Make it do something. For example:  console.log('Hello, world!');   Back in Terminal, run the app:  node server.js   It should respond with the console message, and then terminate.  ","version":"Next","tagName":"h2"},{"title":"Write a simple web server​","type":1,"pageTitle":"Creating and Testing a Web Service","url":"/WebProgrammingForAppsAndServices/Introduction/creating-testing-web-service#write-a-simple-web-server","content":" Our goal is to create an app that will handle these requests:  Get allGet oneAdd newEdit existingDelete item  This goal will work for a web service that handles ANY kind of data. Obviously, a more complex data model will have more request handlers, but they all share the same core design, and handle these five - or variants of these five - requests.  The core getting-started code looks something like the following.  // Setup const express = require('express'); const path = require('path'); const app = express(); const HTTP_PORT = process.env.PORT || 8080; // Add support for incoming JSON entities app.use(express.json()); // Deliver the app's home page to browser clients app.get('/', (req, res) =&gt; { res.sendFile(path.join(__dirname, '/index.html')); }); // Get all app.get('/api/items', (req, res) =&gt; { res.json({ message: 'fetch all items' }); }); // Get one app.get('/api/items/:itemId', (req, res) =&gt; { res.json({ message: `get item with identifier: ${req.params.itemId}` }); }); // Add new // This route expects a JSON object in the body, e.g. { &quot;firstName&quot;: &quot;Peter&quot;, &quot;lastName&quot;: &quot;McIntyre&quot; } app.post('/api/items', (req, res) =&gt; { // MUST return HTTP 201 res.status(201).json({ message: `added a new item: ${req.body.firstName} ${req.body.lastName}` }); }); // Edit existing // This route expects a JSON object in the body, e.g. { &quot;id&quot;: 123, &quot;firstName&quot;: &quot;Peter&quot;, &quot;lastName&quot;: &quot;McIntyre&quot; } app.put('/api/items/:itemId', (req, res) =&gt; { res.json({ message: `updated item with identifier: ${req.params.itemId} to ${req.body.firstName} ${req.body.lastName}`, }); }); // Delete item app.delete('/api/items/:itemId', (req, res) =&gt; { res.status(200).json({ message: `deleted item with identifier: ${req.params.itemId}` }); }); // Resource not found (this should be at the end) app.use((req, res) =&gt; { res.status(404).send('Resource not found'); }); // Tell the app to start listening for requests app.listen(HTTP_PORT, () =&gt; { console.log('Ready to handle requests on port ' + HTTP_PORT); });   ","version":"Next","tagName":"h2"},{"title":"Edit server.js​","type":1,"pageTitle":"Creating and Testing a Web Service","url":"/WebProgrammingForAppsAndServices/Introduction/creating-testing-web-service#edit-serverjs","content":" Edit server.js so that it holds the code shown above.  ","version":"Next","tagName":"h3"},{"title":"Make a simple home page (HTML)​","type":1,"pageTitle":"Creating and Testing a Web Service","url":"/WebProgrammingForAppsAndServices/Introduction/creating-testing-web-service#make-a-simple-home-page-html","content":" Edit index.html. Use the html:5 Emmet snippet to help with this task.  ","version":"Next","tagName":"h3"},{"title":"Run the app​","type":1,"pageTitle":"Creating and Testing a Web Service","url":"/WebProgrammingForAppsAndServices/Introduction/creating-testing-web-service#run-the-app","content":" In Terminal, run the app.  ","version":"Next","tagName":"h3"},{"title":"Testing our API using the Thunder Client Extension​","type":1,"pageTitle":"Creating and Testing a Web Service","url":"/WebProgrammingForAppsAndServices/Introduction/creating-testing-web-service#testing-our-api-using-the-thunder-client-extension","content":" Thunder Client is a Visual Studio Code extension that enables web programmers to interact with a web service (aka web API) without the need to install additional software.  This kind of extension enables us to focus on web service creation - which is a server-focused development effort - without the additional burden of creating a separate client/requestor app that interacts with the web service. It is the client app as we test and interact with the web service.  Its user interface gives us the ability to &quot;compose&quot; a request. Then, we can send the request. Finally, we can inspect the response. The extension saves a history of requests, making it easy to see that you're making progress.  ","version":"Next","tagName":"h2"},{"title":"Start Up​","type":1,"pageTitle":"Creating and Testing a Web Service","url":"/WebProgrammingForAppsAndServices/Introduction/creating-testing-web-service#start-up","content":" After installing the extension, you can get started by clicking on the new &quot;thunderbolt&quot; icon in the left sidebar. This should show you the following screen, with the option to create a new request.    ","version":"Next","tagName":"h3"},{"title":"Important features​","type":1,"pageTitle":"Creating and Testing a Web Service","url":"/WebProgrammingForAppsAndServices/Introduction/creating-testing-web-service#important-features","content":" Once you click the &quot;New Request&quot; button, you will notice that the screen is populated with additional information. For beginners, there are two important features:  Request and response areas - enables you to inspect the contents of both the request and the response (right pane)List of past requests - saves all requests as a history under the &quot;Activity&quot; tab (left pane)    ","version":"Next","tagName":"h3"},{"title":"What is an HTTP request?​","type":1,"pageTitle":"Creating and Testing a Web Service","url":"/WebProgrammingForAppsAndServices/Introduction/creating-testing-web-service#what-is-an-http-request","content":" As you know, HTTP is a message-passing protocol, between two endpoints. One end will send a request, and the other will send a response.  The requester can be a browser (which is what all students have experience with), or it can be a component in an app. For example, almost every smartphone app includes a component - generically known as an HTTP client - that enables it to communicate with a web service.  HTTP defines several kinds of requests. At a minimum, a simple &quot;get me some data&quot; request must include the HTTP method (e.g. GET, POST, etc.), and a URL. Other kinds of requests must include other metadata.  Remember, RFC 7231 is the authoritative resource for the HTTP protocol.  Compose a request - GET​  To compose an HTTP GET request, two settings are required:  HTTP method, GETURL of the collection or object  Other settings may be required (e.g. security-related info, etc.), and we'll see those in the future.    Compose a request - POST​  A POST request is designed to enable the requestor to &quot;add&quot; a new item to the collection that is represented by the URL. Obviously, when compared to a GET request, more is required.  To compose an HTTP POST request, four settings are required:  HTTP method, POSTURL of the collectionA header that defines the content type of the data we're sendingData (the new item)  As above, other settings may be required, but these will enable you to get started.  The image below shows a simple post request, with metadata for the first three settings. Notice that you must select the &quot;Headers&quot; tab to get to the data-entry panel. The header we want is Content-Type, and its value will be application/json, because that's what we're sending    The image below shows how to enter metadata for the fourth setting. Select the &quot;Body&quot; tab and then in the text entry area, add the JSON that correctly defines a new item for the collection.    ","version":"Next","tagName":"h3"},{"title":"More about Thunder Client​","type":1,"pageTitle":"Creating and Testing a Web Service","url":"/WebProgrammingForAppsAndServices/Introduction/creating-testing-web-service#more-about-thunder-client","content":" The official help docs on Github will enable you to become more comfortable using the extension:  Getting started  ","version":"Next","tagName":"h3"},{"title":"Add some data (simple arrays)​","type":1,"pageTitle":"Creating and Testing a Web Service","url":"/WebProgrammingForAppsAndServices/Introduction/creating-testing-web-service#add-some-data-simple-arrays","content":" You obviously noticed that the server's functions were not really handling any data. The requests and responses were simple strings. We'll change that now, and use real data.  We have to do two tasks:  Add some dataEdit the functions  ","version":"Next","tagName":"h2"},{"title":"Add simple string data​","type":1,"pageTitle":"Creating and Testing a Web Service","url":"/WebProgrammingForAppsAndServices/Introduction/creating-testing-web-service#add-simple-string-data","content":" Let's add a super-simple array of strings, for example the names of colours. Somewhere in the server.js file, create a variable to hold the data, something like this:  // Array of strings let colours = ['Red', 'Green', 'Blue', 'Yellow', 'Aqua', 'Fuschia'];   Change the &quot;get all&quot; function, and this time return the data.  What about the other functions? Yes, they need some work.  If we assume that itemId is the array element or index, then we can code a &quot;get one&quot;. For example, the function body looks like the following:  // Extract the item identifier let itemId = req.params.itemId; // Make sure it's valid if (itemId &gt; colours.length) { res.status(404).send('Resource not found'); } else { res.json(colours[itemId]); }   Next, if we assume that we pass in a simple JSON object with one key-value pair (and the key name is &quot;colourName&quot;), then we can code an &quot;add new&quot;. For example, the function body looks like the following:  // Extract the incoming data from { &quot;colourName&quot;: &quot;Purple&quot; } let newItem = req.body.colourName; // Add another item to the array colours.push(newItem); // Return the result; RFC 7231 tells us that it must return HTTP status 201 res.status(201).json({ message: `added ${newItem} as item identifier ${colours.length}` });   ","version":"Next","tagName":"h3"},{"title":"Add some data (objects)​","type":1,"pageTitle":"Creating and Testing a Web Service","url":"/WebProgrammingForAppsAndServices/Introduction/creating-testing-web-service#add-some-data-objects","content":" We will leave this as an in-class hands-on task (in our computer-lab session).  ","version":"Next","tagName":"h2"},{"title":"Generate a substantial amount of data​","type":1,"pageTitle":"Creating and Testing a Web Service","url":"/WebProgrammingForAppsAndServices/Introduction/creating-testing-web-service#generate-a-substantial-amount-of-data","content":" One of the new skills that a web programming student should add is the ability to generate and use a large amount of data. This is especially important for web programmers, because the result of the work we do is so visual in nature. It is always a good idea to use and show good solid credible data, instead of the simple placeholder data (e.g. abc, 123, foo, bar, etc.) that is so common in entry-level programming work.  Here, we will introduce you to, or remind you about, the Mockaroo service:  Need some mock data to test your app? Mockaroo lets you generate up to 1,000 rows of realistic test data in CSV, JSON, SQL, and Excel formats.  Problem solved.  Generate some data. Make sure you configure enough fields to give you a rich variety of data. For the professor's in-class demonstration example, here are a few notable choices we made:  Birth date was within a range and in ISO 8601 formatCredit score was an integer within a rangeRating was a number within a range with two decimal places150 rows were returnedData format was JSON  Here's a screen capture. (Right-click and then open it in a new tab/window to see it full size.)    ","version":"Next","tagName":"h3"},{"title":"Use the data in your web service​","type":1,"pageTitle":"Creating and Testing a Web Service","url":"/WebProgrammingForAppsAndServices/Introduction/creating-testing-web-service#use-the-data-in-your-web-service","content":" The data comes to your system as a standard download. Open it for editing. Copy it.  In your code, similar to what you did above, assign the JSON as the value of a new variable.  let people = // your pasted JSON goes here   Don't forget the statement's trailing semicolon.  Now you have a rich body of data, with which you can do the standard get all, get one, add new, edit existing, and delete item tasks.  ","version":"Next","tagName":"h3"},{"title":"Update the code in the functions​","type":1,"pageTitle":"Creating and Testing a Web Service","url":"/WebProgrammingForAppsAndServices/Introduction/creating-testing-web-service#update-the-code-in-the-functions","content":" Obviously, the code in the functions needs updating, to work with the new data.  Get all is easy to fix.  If you want sorted data - for example by last name then first name - more work needs to be done. The built-in JavaScript array sort() function mutates the existing array. Maybe that's not such a good idea. Therefore, before sorting, copy the array to a new array, with something like this:  let c = data.map((p) =&gt; p);   Then, the &quot;c&quot; array can be mutated, with something like this:  c.sort(function (a, b) { return a.lastName.localeCompare(b.lastName) || a.firstName.localeCompare(b.firstName) || 0; }); // or, using arrow function syntax... c.sort((a, b) =&gt; { return a.lastName.localeCompare(b.lastName) || a.firstName.localeCompare(b.firstName) || 0; });   Finally, the sorted &quot;c&quot; array can be returned.  Do you want to sort an array of numbers? The &quot;compare&quot; is an arithmetic subtraction compare. Look at the MDN docs for more, but briefly: let numbers = [4, 2, 5, 1, 3]; numbers.sort((a, b) =&gt; a - b);   Or, if the numbers were in a property of an array of objects: // assume the array &quot;c&quot; of people/person objects // and we want to sort on credit score c.sort((a, b) =&gt; a.creditScore - b.creditScore);   Get one is also relatively easy to fix.  Compared to the &quot;colours&quot; array above, where it was easy to &quot;find&quot; the value we wanted, this &quot;people&quot; array has objects as elements in the array. We want to support finding a matching identifier (i.e. the &quot;id&quot; field).  This needs a function (an arrow function, specifically). For example:  let o = data.find((p) =&gt; p.id == itemId);   Then, if &quot;o&quot; is &quot;undefined&quot;, return HTTP 404. Otherwise return the object &quot;o&quot;.  You can do the others on your own (i.e. add new, edit existing, delete item). Doing this will remind you of your work with JavaScript arrays, and enhance those skills.  Looking for a more challenging task?  Try adding another function to handle a request for people with a high credit score (e.g. a creditScore value over 600). We can suggest the filter() function can help with that.  Try adding another function to return only the full names of the people objects. We suggest the map() function can help with that. (Bonus, sort the results.)  Try adding another function that will enable a find by last name (case insensitive).  Doing these additional tasks will prepare you for more interesting work with data and its transformations.  Enjoy! ","version":"Next","tagName":"h3"},{"title":"Welcome to Web Programming for Apps and Services","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Introduction/welcome","content":"","keywords":"","version":"Next"},{"title":"Course introduction​","type":1,"pageTitle":"Welcome to Web Programming for Apps and Services","url":"/WebProgrammingForAppsAndServices/Introduction/welcome#course-introduction","content":" In this course, you will learn to create web client (front end, in the browser) apps that work with a web service (back end, in the server). The apps will enable entry-level functionality, which can be hosted on-premise or in the cloud.  Throughout the learning process, you will learn foundational concepts, skills, and technologies that will enable you to create high-quality intermediate and advanced-level web applications in the future. These foundations will include:  JavaScriptWeb API (web services) on a modern server stack (Node.js, Express.js, and MongoDB)The concept (and application) of front end web client developmentThe React and Next.js libraries  ","version":"Next","tagName":"h2"},{"title":"How can you get started?​","type":1,"pageTitle":"Welcome to Web Programming for Apps and Services","url":"/WebProgrammingForAppsAndServices/Introduction/welcome#how-can-you-get-started","content":" Get familiar with the course content online.  Using your own personal computer  The student will use a number of applications and development tools, including:  A modern web app execution environment (Node.js, Express.js, MongoDB)Visual Studio CodeVarious code generators  During the course, the professor(s) will guide the student in the installation, configuration, and use of the software.  Please be aware of the following: If you have problems or difficulties using your own personal computer for course work, your professor will not be able to provide technical support. In a problem scenario, you are still expected to complete your work on time. A problematic personal computer cannot be used as an excuse for delays in completing the course work.  ","version":"Next","tagName":"h2"},{"title":"How to use these course notes​","type":1,"pageTitle":"Welcome to Web Programming for Apps and Services","url":"/WebProgrammingForAppsAndServices/Introduction/welcome#how-to-use-these-course-notes","content":" Every class/session will reference the notes posted here  Before you come into a class, you are expected to read and process the topics covered in the notes.  The format and style of the notes pages will vary. At times, they will be terse, with headings and keywords that are intended to guide the student through the topics. At other times, they will be lengthy, with narrative that explains and supports the topics. Expect a full range of formats and styles between these extremes.  Class/sessions are important. The notes do not attempt to capture everything that must be communicated in the process of learning a topic.  ","version":"Next","tagName":"h2"},{"title":"What do we expect from you?​","type":1,"pageTitle":"Welcome to Web Programming for Apps and Services","url":"/WebProgrammingForAppsAndServices/Introduction/welcome#what-do-we-expect-from-you","content":" Before the class in which there's a test, we expect you to prepare for the class. This means:  Read and study the notesRead and study the linked documentsMake your own notes, including questions that you have  In other words, do not come into the classroom expecting somehow to soak up knowledge like a sponge. You need to prepare before class, so that you understand the topics and their context.  In the Lecture class, we expect you to be an engaged and actively-learning participant. This means:  Listening effectivelyAsking and answering questionsWriting notesDoing the in-class exercises and activities  Before the lab session of the week, we also expect you to prepare for the class. This means:  Being prepared to split your time between new topic learning, and working hands-on with the topic or the current assignmentAsking and answering questionsWriting notesRead and study the current assignmentPractice its contents, and/or get started on its contents  Regarding the workload, it will simply not be possible to confine this course's learning experience to the scheduled class time. We expect you to spend some of the in-class time working on the assignments, but you must spend time out-of-class to complete the work.  That being said, you will encounter problems and delays. Please follow a general rule: If you cannot solve the problem within 20 to 30 minutes, then stop and set it aside. Seek help from your professor, during class time, or during the designated help time or office hours. Alternatively, seek help from a classmate who knows the solution to the problem.  Do not waste time. Do not attempt to wrestle the problem to the ground. Others will not think any less of you when you ask for help. You're here to learn, so take advantage of the course's resources and delivery to help you learn. ","version":"Next","tagName":"h2"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Managing-Application-State/example-code","content":"Example Code You may download the sample code for this topic here: Managing-Application-State","keywords":"","version":"Next"},{"title":"Introducing Jotai","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Managing-Application-State/introducing-jotai","content":"","keywords":"","version":"Next"},{"title":"Getting Started​","type":1,"pageTitle":"Introducing Jotai","url":"/WebProgrammingForAppsAndServices/Managing-Application-State/introducing-jotai#getting-started","content":" To begin working with Jotai, all we need to do is install it using npm, ie:  npm i jotai   ","version":"Next","tagName":"h2"},{"title":"Defining Application Level State​","type":1,"pageTitle":"Introducing Jotai","url":"/WebProgrammingForAppsAndServices/Managing-Application-State/introducing-jotai#defining-application-level-state","content":" In Jotai, state values are defined as &quot;atoms&quot;, essentially units of state that are both updatable and subscribable. When an atom is updated, any subscribed component will be re-rendered with the new value. This makes working with atoms very familiar, as the syntax and behaviour very closely resembles working with local state in components using the &quot;useState&quot; hook.  To define atoms in Next.js, we will place them in a separate file, ie: &quot;store.js&quot;. Since each atom represents a different unit of state, we can define as many as we wish in this file, ie:  File: &quot;my-app/store.js&quot;  import { atom } from 'jotai'; export const countAtom = atom(0); export const countryAtom = atom('Japan'); export const citiesAtom = atom(['Tokyo', 'Kyoto', 'Osaka']); export const mangaAtom = atom({ 'Dragon Ball': 1984, 'One Piece': 1997, 'Naruto': 1999 });   Here, we have defined 4 atoms with varying default values from numbers, strings, arrays and objects. Each of these atoms can be directly referenced from any component in the tree and may be used just like &quot;useState&quot; (see below).  ","version":"Next","tagName":"h2"},{"title":"Async Default Values​","type":1,"pageTitle":"Introducing Jotai","url":"/WebProgrammingForAppsAndServices/Managing-Application-State/introducing-jotai#async-default-values","content":" There may be situations where you cannot hard-code default values into your atoms and instead must fetch them from an API, file, etc. To accommodate this, Jotai allows atoms to be defined using an &quot;async function&quot;, ie:  export const postAtom = atom((async () =&gt; { const res = await fetch('https://jsonplaceholder.typicode.com/posts/1'); const data = await res.json(); return data; })());   ","version":"Next","tagName":"h3"},{"title":"Reading / Writing State​","type":1,"pageTitle":"Introducing Jotai","url":"/WebProgrammingForAppsAndServices/Managing-Application-State/introducing-jotai#reading--writing-state","content":" To use any of the atoms defined in our &quot;store.js&quot; file, we must import both the &quot;useAtom&quot; function (from 'jotai') as well as the specific atom that we wish to read from / write to. For example, if we wish to reference the &quot;countryAtom&quot; (defined above with a default value of &quot;Japan&quot;), we can use the following code:  import { useAtom } from 'jotai'; import { countryAtom } from '@/store'; export default function Country() { const [country, setCountry] = useAtom(countryAtom); return &lt;&gt;Country: {country}&lt;/&gt; }   Notice how &quot;useAtom&quot; functions in a very similar way to &quot;useState&quot;. We can access the state directly from the atom and when it's updated (using &quot;setCountry&quot;, in this case) any other components rendering the value from the countryAtom will also get updated.  ","version":"Next","tagName":"h2"},{"title":"\"Component Tree\" Example​","type":1,"pageTitle":"Introducing Jotai","url":"/WebProgrammingForAppsAndServices/Managing-Application-State/introducing-jotai#component-tree-example","content":" Now that we understand how state management works in Jotai, let's update our &quot;Component Tree&quot; example from the previous section to use it.  info We do not need to modify the file &quot;/pages/_app.js&quot; as in previous examples. Instead we will create a new file: &quot;store.js&quot;.  File: &quot;my-app/store.js&quot;  import { atom } from 'jotai'; export const countAtom = atom(0);   File: &quot;/components/Component3.js&quot;  import { useAtom } from 'jotai'; import { countAtom } from '@/store'; export default function Component3() { const [count, setCount] = useAtom(countAtom); return &lt;&gt;Value: {count}&lt;/&gt; }   File: &quot;/components/ComponentC.js&quot;  import { useAtom } from 'jotai'; import { countAtom } from '@/store'; export default function ComponentC() { const [count, setCount] = useAtom(countAtom); return &lt;button onClick={(e) =&gt; setCount(count + 1)}&gt;Increase Value&lt;/button&gt; }   As you can see, we only had to create / modify 3 files:  store.js: Defines our atoms (global state with optional default values)component3.js: The component using the atom to display its valuecomponentC.js: The component using the atom to modify its value  This is much cleaner than our previous approaches, with the added bonus of having the syntax feel very familiar. Additionally, our application / site no longer suffers from the performance hit caused by re-rendering all of the components in the tree; only &quot;Component3&quot; and &quot;ComponentC&quot; are re-rendered when the state changes.  For more information including handling special cases, etc. please reference the &quot;official Jotai documentation&quot;. ","version":"Next","tagName":"h2"},{"title":"Shared State with Props & Context","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Managing-Application-State/shared-state-props-context","content":"","keywords":"","version":"Next"},{"title":"Prop Drilling​","type":1,"pageTitle":"Shared State with Props & Context","url":"/WebProgrammingForAppsAndServices/Managing-Application-State/shared-state-props-context#prop-drilling","content":" Using what we know so far, there is a way to implement the concept of an application level state in our application / site. What we must do, is declare the state in a top-level component and pass it down from component to component via &quot;props&quot;, so that it may be accessed by the nested component that requires it. This is informally known as &quot;prop drilling&quot;, since we're &quot;drilling&quot; through multiple components via &quot;props&quot; to deliver the state to the nested component. For example, consider the following tree of components:        In this case, both &quot;ComponentA&quot; and &quot;Component1&quot; are rendered by the &quot;Home&quot; component. &quot;ComponentA&quot; renders &quot;ComponentB&quot;, which renders &quot;ComponentC&quot; and likewise, &quot;Component1&quot; renders &quot;Component2&quot;, which renders &quot;Component3&quot;.  Now, say there's a button on &quot;ComponentC&quot; that increments a counter value by 1. We have seen this before when introducing &quot;user events&quot; with &quot;onClick&quot;. However, the difference here is that the component responsible for displaying the counter value as it increases is actually &quot;Component3&quot;, not &quot;ComponentC&quot;, where the button is rendered.  To solve this, we do not declare the &quot;count&quot; state in &quot;ComponentC&quot; with the button, but instead declare it in a top level component.  You will recall from the discussion on &quot;Layouts &amp; Pages&quot; that Next.js actually has a high-level component declared in &quot;pages/_app.js&quot; - this is where we placed our &lt;layout&gt;...&lt;/layout&gt; component so that it will be available on all pages. This is also where we will declare our counter state and pass it to page components via props, ie:  File: &quot;/pages/_app.js&quot;  import '@/styles/globals.css'; import { useState } from 'react'; export default function App({ Component, pageProps }) { const [count, setCount] = useState(0); // declare high-level &quot;count&quot; state return &lt;Component {...pageProps} count={count} setCount={setCount} /&gt; // pass it as props to the page components }   Here, we declare the state in &quot;App&quot; and ensure that it can be accessed by passing the values as props &quot;count&quot; and &quot;setCount&quot;, respectfully.  Now, in the &quot;Home&quot; component when we render &quot;ComponentA&quot; and &quot;Component1&quot;, we will continue to pass the props so that &quot;ComponentB&quot; and &quot;Component2&quot; have access, and so on. We are passing (&quot;drilling&quot;) the state through every component via &quot;props&quot; until it reaches a component that requires it.  File: &quot;/pages/index.js&quot;  &lt;Component1 count={props.count} /&gt; &lt;ComponentA setCount={props.setCount} /&gt;   The &quot;Home&quot; component (declared in &quot;index.js&quot;) simply passes the &quot;count&quot; and &quot;setCount&quot; properties to the appropriate components, so that in addition to rendering &quot;Component2&quot;, &quot;Component1&quot; takes the &quot;count&quot; prop and passes it on, until it can be used by &quot;Component3&quot;. The same is true for &quot;ComponentA&quot;, however it takes the &quot;setCount&quot; prop and passes it on, until it can be used by &quot;ComponentC&quot;.  Let's skip ahead and look at the final components; &quot;ComponentC&quot; and &quot;Component3&quot; to see how they make use of the &quot;count&quot; and &quot;setCount&quot; props that have been passed down to them:  File: &quot;/components/Component3.js&quot;  export default function Component3(props) { return &lt;&gt;Value: {props.count}&lt;/&gt; }   File: &quot;/components/ComponentC.js&quot;  export default function ComponentC(props) { return &lt;button onClick={(e) =&gt; props.setCount(n =&gt; n + 1)}&gt;Increase Value&lt;/button&gt; }   info If the new state is computed using the previous state, you can pass a function to setState, which receives the previous value.  As you can see, &quot;count&quot; and &quot;setCount&quot; can be accessed directly from the &quot;props&quot; object, since it has been passed down from component to component.  ","version":"Next","tagName":"h2"},{"title":"Problems with Prop Drilling​","type":1,"pageTitle":"Shared State with Props & Context","url":"/WebProgrammingForAppsAndServices/Managing-Application-State/shared-state-props-context#problems-with-prop-drilling","content":" Depending on the complexity of the layout / application, &quot;prop drilling&quot; can add extra properties to components that do not actually need them; the only reason they were passed the props, is to hand them off to their child components. This makes components harder to reuse and adds an extra dependency between components that we would like to avoid. This can also get very cumbersome if we have many application level state values to manage.  Additionally, there is an impact on performance when using this method of passing state from component to component. Every time the state is accessed / changed in a child component, every parent component in the &quot;prop&quot; chain (ie: &quot;Home&quot;, &quot;Component1&quot;, &quot;Component2&quot;, &quot;Component3&quot;, &quot;ComponentA&quot;, &quot;ComponentB&quot;, &quot;ComponentC&quot;) also gets rendered.  ","version":"Next","tagName":"h3"},{"title":"Context​","type":1,"pageTitle":"Shared State with Props & Context","url":"/WebProgrammingForAppsAndServices/Managing-Application-State/shared-state-props-context#context","content":" As we have seen, our first approach to solving &quot;application level&quot; state works, but causes organizational and performance problems with our application / site. It is for these reasons that as of React 16, &quot;Context&quot; was introduced:  &quot;In a typical React application, data is passed top-down (parent to child) via props, but such usage can be cumbersome for certain types of props (e.g. locale preference, UI theme) that are required by many components within an application. Context provides a way to share values like these between components without having to explicitly pass a prop through every level of the tree.&quot;  This is certainly an improvement to &quot;prop drilling&quot;, so let's implement it in our scenario above. As before, we will declare a &quot;count&quot; state in App, but instead of passing various &quot;props&quot; we will instead create &quot;Context&quot; objects and wrap our &lt;Component {...pageProps} /&gt; with &quot;Provider&quot; components:  File: &quot;/pages/_app.js&quot;  import '@/styles/globals.css'; import { useState, createContext } from 'react'; export const CountContext = createContext(); export const SetCountContext = createContext(); export default function App({ Component, pageProps }) { const [count, setCount] = useState(0); return ( &lt;&gt; &lt;CountContext.Provider value={count}&gt; &lt;SetCountContext.Provider value={setCount}&gt; &lt;Component {...pageProps} /&gt; &lt;/SetCountContext.Provider&gt; &lt;/CountContext.Provider&gt; &lt;/&gt; ); }   Notice how we create and export a new &quot;Context&quot; object for every value that we wish to make &quot;global&quot; to our application (ie: accessible by deeply nested components, such as &quot;Component3&quot; and &quot;ComponentC&quot;). We then wrap our &lt;Component {...pageProps} /&gt; with the associated &quot;Provider&quot; components with a &quot;value&quot; prop, to make the context values available to child components (pages).  This eliminates the need for &quot;prop drilling&quot;, so we do not need to update any components except the components that must make use of the context, ie: &quot;Component3&quot; and &quot;ComponentC&quot;:  File: &quot;/components/Component3.js&quot;  import { useContext } from 'react'; import { CountContext } from '@/pages/_app'; export default function Component3() { const count = useContext(CountContext); return &lt;&gt;Value: {count}&lt;/&gt; }   File: &quot;/components/ComponentC.js&quot;  import { useContext } from 'react'; import { SetCountContext } from '@/pages/_app'; export default function ComponentC() { const setCount = useContext(SetCountContext); return &lt;button onClick={(e) =&gt; setCount(n =&gt; n + 1)}&gt;Increase Value&lt;/button&gt;; }   For both functions, we must import &quot;useContext&quot; from 'react', as well as the specific &quot;Context&quot; object that is required by the component, ie: &quot;CountContext&quot; or &quot;SetCountContext&quot;. We invoke the &quot;useContext&quot; function with a specific &quot;Context&quot; object to retrieve the value from the &quot;Provider&quot; component (included in &quot;App&quot;), which can then be used within our component.  ","version":"Next","tagName":"h2"},{"title":"Problems with Context​","type":1,"pageTitle":"Shared State with Props & Context","url":"/WebProgrammingForAppsAndServices/Managing-Application-State/shared-state-props-context#problems-with-context","content":" Unfortunately, while this does avoid the need to pass props through unrelated components (&quot;prop drilling&quot;), it still suffers from some organizational and performance issues. For example, what happens when the &quot;application state&quot; gets complicated, causing the providers to build up? This can result in what is known as &quot;provider hell&quot;, ie:  &lt;AContext.Provider value={&quot;A&quot;}&gt; &lt;BContext.Provider value={&quot;B&quot;}&gt; &lt;CContext.Provider value={&quot;C&quot;}&gt; &lt;DContext.Provider value={&quot;D&quot;}&gt; &lt;EContext.Provider value={&quot;E&quot;}&gt; &lt;Component {...pageProps} /&gt; &lt;/AContext.Provider&gt; &lt;/BContext.Provider&gt; &lt;/CContext.Provider&gt; &lt;/DContext.Provider&gt; &lt;/EContext.Provider&gt;   Additionally, the same performance problem exists, ie: every time the state is accessed / changed in a child component using context, every parent component back to the &quot;Provider&quot; (ie: &quot;Home&quot;, &quot;Component1&quot;, &quot;Component2&quot;, &quot;Component3&quot;, &quot;ComponentA&quot;, &quot;ComponentB&quot;, &quot;ComponentC&quot;) also gets rendered.  ","version":"Next","tagName":"h3"},{"title":"Alternatives​","type":1,"pageTitle":"Shared State with Props & Context","url":"/WebProgrammingForAppsAndServices/Managing-Application-State/shared-state-props-context#alternatives","content":" If neither of the above built-in strategies work for your specific application, don't worry; there exist many 3rd party alternatives. Some of the more popular state management libraries include:  Redux / Redux Toolkit: &quot;The official, opinionated, batteries-included toolset for efficient Redux development. Includes utilities to simplify common use cases like store setup, creating reducers, immutable update logic, and more.&quot; Recoil: &quot;A state management library for React. Recoil works and thinks like React. Add some to your app and get fast and flexible shared state.&quot; Jotai: &quot;Jotai takes a bottom-up approach to React state management with an atomic model inspired by Recoil. One can build state by combining atoms and renders are optimized based on atom dependency. This solves the extra re-render issue of React context and eliminates the need for the memoization technique.&quot; Zustand: &quot;A small, fast and scalable bearbones state-management solution. Has a comfy api based on hooks, isn't boilerplatey or opinionated, but still just enough to be explicit and flux-like.&quot; MobX: &quot;MobX is a battle tested library that makes state management simple and scalable by transparently applying functional reactive programming (TFRP).&quot; HookState: &quot;The most straightforward, extensible and incredibly fast state management that is based on React state hook&quot; ","version":"Next","tagName":"h2"},{"title":"Dynamic Routes","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Pages-Routing/dynamic-routes","content":"","keywords":"","version":"Next"},{"title":"Reading Route Parameters​","type":1,"pageTitle":"Dynamic Routes","url":"/WebProgrammingForAppsAndServices/Pages-Routing/dynamic-routes#reading-route-parameters","content":" In order to actually read and display a route parameter (product &quot;id&quot; in the above case), the &quot;router&quot; object once must again be obtained using the &quot;useRouter&quot; hook from &quot;next/router&quot;:  File: &quot;pages/product/[id].js&quot;  import { useRouter } from 'next/router'; export default function Product() { const router = useRouter(); const { id } = router.query; return &lt;p&gt;Product: {id}&lt;/p&gt; }   Here, we have made use of the &quot;query&quot; property of router to obtain an object containing a property: &quot;id&quot; that matches the filename: [id].js&quot;  ","version":"Next","tagName":"h2"},{"title":"Reading Query Parameters​","type":1,"pageTitle":"Dynamic Routes","url":"/WebProgrammingForAppsAndServices/Pages-Routing/dynamic-routes#reading-query-parameters","content":" Reading query parameters follows the exact same procedure. Let's see how we go about reading the &quot;page&quot; and &quot;category&quot; query parameters as specified above:  import { useRouter } from 'next/router' export default function Products() { const router = useRouter() const { page } = router.query; const { category } = router.query; if (page &amp;&amp; category) { return &lt;p&gt;Products for page: {page} &amp;amp; category: {category}&lt;/p&gt; } else { return &lt;p&gt;Page and/or Category Parameters Missing&lt;/p&gt; } }   Once again we have made use of the &quot;query&quot; property of router to obtain an object containing properties that match each query parameter. However, since these are technically optional parameters (it is possible to navigate to the route without them), we should check to make sure they exist before we render any data related to them.  info If there are duplicate values for a query parameter, ie: &quot;category=stationary&amp;category=office&quot;, then the &quot;category&quot; property will contain an array containing the values: [&quot;stationary&quot;, &quot;office&quot;]  ","version":"Next","tagName":"h2"},{"title":"Dynamic Routes with 'getStaticProps'​","type":1,"pageTitle":"Dynamic Routes","url":"/WebProgrammingForAppsAndServices/Pages-Routing/dynamic-routes#dynamic-routes-with-getstaticprops","content":" If you wish to use 'getStaticProps' with dynamic routes, things become slightly more complicated. In a route that always fetches data from the same API endpoint, having the data available for pre-rendering is straightforward since the &quot;fetch&quot; statement always pulls data from the same location. However, if the route is dynamic, it becomes more difficult to pull the data ahead of time using 'getStaticProps'. To solve this problem, Next.js has an asynchronous &quot;getStaticPaths&quot; function that must be used in addition to &quot;getStaticProps&quot;. To see how this works, consider the following example:  File: &quot;pages/post/[id].js&quot;  export async function getStaticPaths() { // pre-render and support post/1 through post/5 only return { paths: [ { params: { id: &quot;1&quot; } }, { params: { id: &quot;2&quot; } }, { params: { id: &quot;3&quot; } }, { params: { id: &quot;4&quot; } }, { params: { id: &quot;5&quot; } } ], fallback: false // any pages not identified above, will result in a 404 error, ie post/6 } } export async function getStaticProps(context) { const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${context.params.id}`) const data = await res.json() return { props: { post: data } } } export default function Post(props) { return &lt;&gt; &lt;p&gt;&lt;strong&gt;User ID:&lt;/strong&gt; {props.post.userId}&lt;/p&gt; &lt;p&gt;&lt;strong&gt;ID:&lt;/strong&gt; {props.post.id}&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; {props.post.title}&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Body:&lt;/strong&gt; {props.post.body}&lt;/p&gt; &lt;/&gt; }   Here, we have a component &quot;Post&quot; that is located within the &quot;pages&quot; directory at &quot;pages/post/[id].js&quot;. We also have &quot;getStaticProps&quot; as we have seen it before, except in this case it accepts a &quot;context&quot; parameter that provides the function with one of the id's in the list of paths returned from the &quot;getStaticPaths&quot; function (ie: context.params.id).  All of the supported route parameters are included in the &quot;paths&quot; property of the return value for the &quot;getStaticPaths&quot; function - if the user tries to access a route containing a parameter that is not listed in &quot;paths&quot;, a 404 error will be returned. This is because an additional &quot;fallback&quot; property has explicitly been set to false. If this functionality is not desired, then fallback can be set to true (see: the official documentation for &quot;fallback: true&quot; for more information).  Finally, you will notice that in our &quot;Post&quot; component, we do not have to explicitly read the route parameter using the &quot;useRouter&quot; hook (as above). The &quot;post&quot; property in &quot;props&quot; will automatically contain the data for the correct &quot;id&quot; parameter.  ","version":"Next","tagName":"h2"},{"title":"Custom Error Pages​","type":1,"pageTitle":"Dynamic Routes","url":"/WebProgrammingForAppsAndServices/Pages-Routing/dynamic-routes#custom-error-pages","content":" Finally, you may have noticed by now that Next.js provides its own 404 and 500 error pages. However, it is possible to create your own as well. In this case all that is required is that you create a &quot;404.js&quot; or &quot;500.js&quot; file in the &quot;pages&quot; directory, ie:  File: &quot;pages/404.js&quot;  export default function Custom404() { return &lt;h1&gt;404 - Page Not Found&lt;/h1&gt; }   File: &quot;pages/500.js&quot;  export default function Custom500() { return &lt;h1&gt;500 - Server-side error occurred&lt;/h1&gt; }  ","version":"Next","tagName":"h2"},{"title":"Implementation: Shopping Cart","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Managing-Application-State/implementation-shopping-cart","content":"","keywords":"","version":"Next"},{"title":"Getting Started​","type":1,"pageTitle":"Implementation: Shopping Cart","url":"/WebProgrammingForAppsAndServices/Managing-Application-State/implementation-shopping-cart#getting-started","content":" To begin, we will use the &quot;shopping-state-missing&quot; example from the sample code: Managing-Application-State as a starting point.  Once you have the source code downloaded:  Open the &quot;shopping-state-missing&quot; folder in your code editor (ie: &quot;Visual Studio Code&quot;)Open the &quot;my-app&quot; folder in the integrated terminalRun the command &quot;npm install&quot; (alternatively: &quot;npm i&quot;) to install the dependenciesBuild / Run the site with the usual command: &quot;npm run dev&quot;Browse the site  ","version":"Next","tagName":"h2"},{"title":"File Structure​","type":1,"pageTitle":"Implementation: Shopping Cart","url":"/WebProgrammingForAppsAndServices/Managing-Application-State/implementation-shopping-cart#file-structure","content":" The project currently contains the following &quot;components&quot; / &quot;pages&quot; structure:  components/Layout.js: The main / shared layout for the site. This contains the navbar as well as the headline &quot;Online Shopping&quot;. components/ProductBox.js: This is the component responsible for rendering a specific product on the &quot;/products&quot; page. It takes a product as a property and renders the details (image, description, price, etc.) in a &lt;div&gt;...&lt;/div&gt; element with a maximum width of &quot;300px&quot;. Additionally, it contains buttons that either link to the specific product details page (&quot;/products/[id]&quot;), or invoke an &quot;addToCart()&quot; function with the current product object. Currently, &quot;addToCart()&quot; simply outputs the product to the console with the message: &quot;TODO: Add to Cart&quot;. pages/Products/[id].js: This page renders additional details for a specific product (brand, rating, stock, etc.), based on the &quot;id&quot; parameter. Like &quot;ProductBox&quot;, it contains an &quot;addToCart&quot; function that has not yet been implemented as well as a button that links back to the product list (&quot;/products&quot;). Additionally, it makes use of &quot;getStaticPaths()&quot; and &quot;getStaticProps()&quot; in order to pre-render the 30 potential products available. pages/Products/index.js: This is the page that renders a single &quot;ProductBox&quot; for all 30 available products in a grid using Flexbox. Like the &quot;Products/[id]&quot; page, it makes use of &quot;getStaticProps()&quot; in order to pre-render the 30 products to be displayed. pages/_app.js: Contains the boilerplate code for a Next.js app, with the addition of the &lt;Layout&gt;...&lt;/Layout&gt; component. pages/cart.js: Currently only shows the text &quot;Cart&quot; - this is where we will eventually render the products currently contained within the &quot;cart&quot; pages/index.js: Simply renders the &quot;Home&quot; component on the default route &quot;/&quot; - currently contains a short description of the demo.  ","version":"Next","tagName":"h3"},{"title":"Adding \"Cart\" state with Jotai​","type":1,"pageTitle":"Implementation: Shopping Cart","url":"/WebProgrammingForAppsAndServices/Managing-Application-State/implementation-shopping-cart#adding-cart-state-with-jotai","content":" Before we begin, we must install Jotai using the command:  npm i jotai   Next, if would like to make our &quot;cart&quot; (ie: a list of &quot;products&quot; that the user wishes to purchase) available anywhere within the site, we should create an &quot;atom&quot; to store the values. Additionally, let's also include Product 1 (iPhone 9) and Product 2 (iPhone X) as default values for the cart:  File: &quot;/my-app/store.js&quot;  import { atom } from 'jotai'; async function defaultValues() { const results = []; // Fetch Product 1 const prod1Result = await fetch('https://dummyjson.com/products/1'); const prod1 = await prod1Result.json(); results.push(prod1); // Fetch Product 2 const prod2Result = await fetch('https://dummyjson.com/products/2'); const prod2 = await prod2Result.json(); results.push(prod2); return results; } export const cartListAtom = atom(defaultValues());   As before, we have created a &quot;store.js&quot; file, imported the &quot;atom&quot; function from 'jotai' and defined and exported an atom (&quot;cartListAtom&quot;). The default value for the atom is an array of products, obtained by invoking the asynchronous &quot;defaultValues()&quot; function.  ","version":"Next","tagName":"h2"},{"title":"Updating \"Layout\"​","type":1,"pageTitle":"Implementation: Shopping Cart","url":"/WebProgrammingForAppsAndServices/Managing-Application-State/implementation-shopping-cart#updating-layout","content":" The first component that we would like to update to use the newly created &quot;cartListAtom&quot; is &quot;Layout&quot;. Here, we will show how many products have been added to the cart in parentheses next to the &quot;Shopping Cart&quot; link:  File: &quot;/components/Layout.js&quot;  import Link from 'next/link'; import { useAtom } from 'jotai'; import { cartListAtom } from '@/store'; export default function Layout(props) { const [cartList, setCartList] = useAtom(cartListAtom); return ( &lt;&gt; &lt;div style={{ padding: &quot;10px&quot; }}&gt; &lt;h2&gt;Online Shopping&lt;/h2&gt; &lt;Link href=&quot;/&quot;&gt;Home&lt;/Link&gt; | &lt;Link href=&quot;/products&quot;&gt;Products&lt;/Link&gt; | &lt;Link href=&quot;/cart&quot;&gt;Shopping Cart &lt;span&gt;({cartList.length})&lt;/span&gt;&lt;/Link&gt; &lt;hr /&gt; {props.children} &lt;/div&gt; &lt;/&gt; ) }   Notice how we updated the component to use both &quot;useAtom&quot; from 'jotai' and &quot;cartListAtom&quot; from '@/store' (our store.js file containing the atom definition). In the component, we use &quot;useAtom&quot; in the same way that we use &quot;useState&quot; only the &quot;default value&quot; is the atom &quot;cartListAtom&quot;. This gives us full read/write access to the atom, shared by the rest of the site.  If we refresh the site after making this change, we should see that the &quot;Shopping Cart&quot; link has been updated to read &quot;Shopping Cart (2)&quot;.  ","version":"Next","tagName":"h3"},{"title":"Updating \"addToCart()\" Functions​","type":1,"pageTitle":"Implementation: Shopping Cart","url":"/WebProgrammingForAppsAndServices/Managing-Application-State/implementation-shopping-cart#updating-addtocart-functions","content":" The next piece that we should update is the &quot;addToCart()&quot; functions that exist in both &quot;/pages/products/[id].js&quot; and &quot;/components/ProductBox.js&quot; files.  In both cases, we must add the cartListAtom from the correct &quot;store&quot; location, as well as the useAtom function:  import { useAtom } from 'jotai'; import { cartListAtom } from '@/store';   One we have the atom, we must reference it in the component using the syntax:  const [cartList, setCartList] = useAtom(cartListAtom);   Finally, we can update the &quot;addToCart()&quot; function to add the product to the cart:  function addToCart(product) { setCartList([...cartList, product]); }   Since we are modifying the current list of items, we must use &quot;spread syntax&quot; to include all of the previous products in the list, in addition to the product to specify the state.  If we refresh the site now, we should be able to click any &quot;Add to Cart&quot; button, and see the &quot;Shopping Cart&quot; number increase in the navigation bar.  ","version":"Next","tagName":"h3"},{"title":"Updating the \"cart\" Page​","type":1,"pageTitle":"Implementation: Shopping Cart","url":"/WebProgrammingForAppsAndServices/Managing-Application-State/implementation-shopping-cart#updating-the-cart-page","content":" The final piece of functionality that we must add is to show all of the products currently within the cart on the &quot;cart&quot; page, as well as a total cost for all of the products within the cart.  Once again, to gain access to the products in the cart, we must add the cartListAtom from the &quot;store&quot; as well as the useAtom function:  import { useAtom } from 'jotai'; import { cartListAtom } from '@/store';   Followed by the code to reference it in the component:  const [cartList, setCartList] = useAtom(cartListAtom);   With this in place, the following JSX code can be added to render the products in a list:  return ( &lt;&gt; &lt;br /&gt; &lt;ul&gt; {cartList.map((product, index) =&gt;( &lt;li key={index}&gt; &lt;strong&gt;{product.title}&lt;/strong&gt;: {product.description}&lt;br /&gt; &lt;strong&gt;${product.price.toFixed(2)}&lt;/strong&gt; &lt;br /&gt;&lt;br /&gt; &lt;/li&gt; ))} &lt;/ul&gt; &lt;hr /&gt; &lt;ul&gt; &lt;li&gt; &lt;strong&gt;Total: ${cartList.reduce((total, prod) =&gt; total + prod.price, 0).toFixed(2)}&lt;/strong&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/&gt; )   With this complete, we can now browse the site and add products to the cart. To view all of the items in the cart the &quot;cart&quot; page should now show an updated list with a total cost. ","version":"Next","tagName":"h3"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Pages-Routing/example-code","content":"Example Code You may download the sample code for this topic here: Pages-Routing","keywords":"","version":"Next"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Performance-Optimizations/example-code","content":"Example Code You may download the sample code for this topic here: Performance-Optimizations","keywords":"","version":"Next"},{"title":"Analyzing Performance","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Performance-Optimizations/analyzing-performance","content":"","keywords":"","version":"Next"},{"title":"Core Web Vitals​","type":1,"pageTitle":"Analyzing Performance","url":"/WebProgrammingForAppsAndServices/Performance-Optimizations/analyzing-performance#core-web-vitals","content":" In May of 2020, Google introduced &quot;Core Web Vitals&quot;, a subset of their &quot;Web Vitals&quot; metrics, designed to focus on distinct facets of the user experience:  Core Web Vitals are the subset of Web Vitals that apply to all web pages, should be measured by all site owners, and will be surfaced across all Google tools. Each of the Core Web Vitals represents a distinct facet of the user experience, is measurable in the field, and reflects the real-world experience of a critical user-centric outcome. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability  By providing a guideline and metrics for creating performant web sites, Google has made it easier for developers to identify and fix potential problems:  Site owners should not have to be performance gurus in order to understand the quality of experience they are delivering to their users. The Web Vitals initiative aims to simplify the landscape, and help sites focus on the metrics that matter most.  Additionally, &quot;Core Web Vitals&quot; have been added to Google's &quot;page experience signals&quot;, which have an impact on how your site is ranked in Google. Therefore it is imperative that we understand Core Web Vitals and how we can measure and improve them.  Next.js has provided an excellent introduction for these metrics in their documentation:  ","version":"Next","tagName":"h2"},{"title":"Largest Contentful Paint (LCP)​","type":1,"pageTitle":"Analyzing Performance","url":"/WebProgrammingForAppsAndServices/Performance-Optimizations/analyzing-performance#largest-contentful-paint-lcp","content":" The Largest Contentful Paint (LCP) metric looks at the loading performance of your page. LCP measures the time it takes to get the largest element on the page visible within the viewport. This could be a large text block, video, or image that takes up the primary real estate on the page.  As the DOM is rendered, the largest element on the page may change. The Largest Contentful Paint doesn't stop counting until the largest image or element is seen on-screen.  According to Google, sites should strive to have Largest Contentful Paint take 2.5 seconds or less.    ","version":"Next","tagName":"h3"},{"title":"First Input Delay (FID)​","type":1,"pageTitle":"Analyzing Performance","url":"/WebProgrammingForAppsAndServices/Performance-Optimizations/analyzing-performance#first-input-delay-fid","content":" The First Input Delay (FID) metric measures the time from when a user first interacts with a page (i.e. when they click a link, tap on a button, or use a custom, JavaScript-powered control) to the time when the browser is actually able to begin processing event handlers in response to that interaction.  The First Input Delay (FID) metric helps measure your user's first impression of your site's interactivity and responsiveness.  According to Google, sites should strive to have a First Input Delay of 100 milliseconds or less.    ","version":"Next","tagName":"h3"},{"title":"Cumulative Layout Shift (CLS)​","type":1,"pageTitle":"Analyzing Performance","url":"/WebProgrammingForAppsAndServices/Performance-Optimizations/analyzing-performance#cumulative-layout-shift-cls","content":" The Cumulative Layout Shift (CLS) metric is a measure of your site’s overall layout stability. A site that unexpectedly shifts layout as the page loads can lead to accidental user error and distraction.  Cumulative Layout Shift (CLS) occurs when elements have been shifted after initially being rendered by the DOM. For example, a button rendered to the screen after a text block, which then causes the block to shift downward would be considered a layout shift.  A combination of impact and distance is considered when calculating CLS.  According to Google, sites should should strive to have a CLS score of 0.1 or less    ","version":"Next","tagName":"h3"},{"title":"Introduction to Lighthouse​","type":1,"pageTitle":"Analyzing Performance","url":"/WebProgrammingForAppsAndServices/Performance-Optimizations/analyzing-performance#introduction-to-lighthouse","content":" Now that we are aware of what the &quot;Core Web Vitals&quot; are in a nutshell, how do we go about measuring them? Fortunately, Google has created a tool called &quot;Lighthouse&quot;, which not only measures Core Web Vitals, but other important metrics as well:  Lighthouse is an open-source, automated tool for improving the quality of web pages. You can run it against any web page, public or requiring authentication. It has audits for performance, accessibility, progressive web apps, SEO and more. You can run Lighthouse in Chrome DevTools, from the command line, or as a Node module. You give Lighthouse a URL to audit, it runs a series of audits against the page, and then it generates a report on how well the page did. From there, use the failing audits as indicators on how to improve the page. Each audit has a reference doc explaining why the audit is important, as well as how to fix it.  While Lighthouse is integrated directly into the Chrome DevTools (available in the &quot;Lighthouse&quot; panel), you may wish to access lighthouse in one of the other methods specified above. For more information, see:  Using the Node CLIAs a Node ModuleUsing the online tool: PageSpeed Insights  info Lighthouse is also available as a GitHub action, which allows us to use it in our CI pipeline. Using this, It is possible to set minimum acceptable scores for various performance metrics, which result in errors if not met. This can help to reduce performance-related bugs from being introduced into production. See the documentation for the CI Action for more information.  ","version":"Next","tagName":"h2"},{"title":"Analyzing Page Load​","type":1,"pageTitle":"Analyzing Performance","url":"/WebProgrammingForAppsAndServices/Performance-Optimizations/analyzing-performance#analyzing-page-load","content":" While we can run Lighthouse on any page, it would be best to see what kind of results we would obtain from a simple Next.js app without any additional optimizations (discussed in: Improving / Optimizing Performance). To begin, download the Example Code and open the folder &quot;app&quot; in Visual Studio Code. Here you will find the familiar &quot;my-app&quot; folder containing a Next.js app.  As usual, before proceeding, you will need to change to the &quot;my-app&quot; folder and execute the commands:  npm install npm run dev   Since we will be using &quot;Lighthouse&quot; to measure the performance of this app, we should ideally be opening it in Google Chrome.  Once it's running, you will notice that it's a fairly simple app that shows a searchable accordion list of films in a collection. To obtain the data, It pulls the films from an &quot;/api/movies&quot; endpoint, specified in our &quot;pages/api/movies.js&quot; file.  Let's go ahead and see how well this app performs in Lighthouse:  Open a new &quot;incognito&quot; window in Google Chrome and navigate to the locally running app: http://localhost:3000 Open the &quot;Developer Tools&quot; and Switch to the &quot;Lighthouse&quot; tab For this first run, check the &quot;Performance&quot;, &quot;Accessability&quot;, &quot;Best Practices&quot; and &quot;SEO&quot; Categories:    Click the Analyze Page Load button and wait for the audit to finish.    It appears that things are looking pretty good, except for the performance section. If we look at the code for the app, it doesn't seem like there's all that much we can do to improve performance, at first glance. However, Next.js has some built-in techniques and components that we can use to optimize our initial page load and help to improve that result.  Important Note: The performance numbers will improve if we do a production build before starting the app (using npm start) and testing it with Lighthouse. However, the above report does shine some light on potential areas of improvement that we should explore before going to production. ","version":"Next","tagName":"h3"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/React-NextJS-Introduction/example-code","content":"Example Code You may download the sample code for this topic here: React-NextJS-Introduction","keywords":"","version":"Next"},{"title":"Improving / Optimizing Performance","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Performance-Optimizations/improving-optimizing-performance","content":"","keywords":"","version":"Next"},{"title":"Using the <Image /> Component​","type":1,"pageTitle":"Improving / Optimizing Performance","url":"/WebProgrammingForAppsAndServices/Performance-Optimizations/improving-optimizing-performance#using-the-image--component","content":" The custom Image component included with Next.js is an alternative to the native &lt;img /&gt; element and offers a number of optimizations, including:  Improved Performance: Always serve correctly sized image for each device, using modern image formatsVisual Stability: Prevent Cumulative Layout Shift automaticallyFaster Page Loads: Images are only loaded when they enter the viewport, with optional blur-up placeholdersAsset Flexibility: On-demand image resizing, even for images stored on remote servers  Let's update our app to use the Image component and look at some of its main features:  Add the correct &quot;import&quot; statement for the Image component  import Image from 'next/image';   Remove the current &lt;img ... /&gt; component and replace it with the following:  &lt;Image src=&quot;/theatre-bkrd.jpg&quot; alt=&quot;theatre background&quot; className={styles.headerImage} sizes=&quot;100vw&quot; width={800} height={232} priority /&gt;   Notice that we have provided a number of additional properties to the &quot;Image&quot; element, specifically:  sizes=&quot;100vw&quot;   This property provides information on how wide the image should be at different breakpoints, for more information on the &quot;sizes&quot; property, see: &quot;sizes&quot; in the Image documentation  width={800} height={232}   These properties represent the original width in pixels.  priority   When set, priority will mark the image as &quot;priority&quot; causing it to preload. Using &quot;priority&quot; in this case was recommended as this image was detected as the &quot;Largest Contentful Paint (LCP)&quot; element, as seen in the browser console: &quot;Image with src &quot;/theatre-bkrd.jpg&quot; was detected as the Largest Contentful Paint (LCP). Please add the &quot;priority&quot; property if this image is above the fold&quot;  If you inspect the image in the browser console, you should see that it now has a number of extra properties, including  srcset: This is the &quot;source set&quot;, which identifies different urls for images to be served at different viewport widths (breakpoints). By default the following device sizes are used: 640, 750, 828, 1080, 1200, 1920, 2048, 3840. You can see how Next.js has associated each device size with a url based on our original url, ie: the 640 width is set to serve: &quot;/_next/image?url=%2Ftheatre-bkrd.jpg&amp;w=640&amp;q=75&quot;, whereas the 750 width is set to serve: &quot;_next/image?url=%2Ftheatre-bkrd.jpg&amp;w=750&amp;q=75&quot;. If you try opening each of these images, you will see that Next.js has correctly scaled them to match the widths. info Next.js will only scale images down in size (not up), therefore the image for the 2048 width: &quot;_next/image?url=%2Ftheatre-bkrd.jpg&amp;w=2048&amp;q=75&quot;, simply renders our original image (800px x 232px). You will also notice that the source images have additional query parameter: &quot;q&quot;. This represents the &quot;quality&quot; of the image, as Next.js will automatically optimize the original image to provide varying levels of quality. By default the quality setting is set to 75, however it can be changed using the quality property. decoding: Next.js sets the decoding value to &quot;async&quot;, which is done to &quot;reduce delay in presenting other content&quot;.  Remote Images​  If you attempt to use a remote image with the Image component, ie:  &lt;Image src=&quot;https://www.senecapolytechnic.ca/content/dam/projects/seneca/campus-photos/magna-hall_tile.jpg&quot; className={styles.headerImage} width={600} height={386} /&gt;   You will see the following error:  Error: Invalid src prop (https://www.senecapolytechnic.ca/content/dam/projects/seneca/campus-photos/magna-hall_tile.jpg) on `next/image`, hostname &quot;www.senecapolytechnic.ca&quot; is not configured under images in your `next.config.mjs` See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host   If we navigate to the link in &quot;more info&quot;, we will see that the error occurred because the &quot;src&quot; value uses a hostname in the URL that isn't defined in the images.remotePatterns in next.config.mjs. This is done to ensure that only images from approved domains are able to use the Next.js image optimization API.  To solve this problem, open the &quot;next.config.mjs&quot; file, and update the nextConfig object to include an &quot;images&quot; property with &quot;remotePatterns&quot;:  File: &quot;next.config.mjs&quot;  /** @type {import('next').NextConfig} */ const nextConfig = { //... images: { remotePatterns: [ { protocol: 'https', hostname: 'www.senecapolytechnic.ca', pathname: '/**', }, ], }, }; export default nextConfig;   ","version":"Next","tagName":"h3"},{"title":"Dynamically Importing Libraries​","type":1,"pageTitle":"Improving / Optimizing Performance","url":"/WebProgrammingForAppsAndServices/Performance-Optimizations/improving-optimizing-performance#dynamically-importing-libraries","content":" Next.js supports &quot;Lazy Loading&quot; for external libraries with &quot;import&quot; as well as images. In larger apps, this can have an impact on metrics such as Largest Contentful Paint (LCP) and First Input Delay (FID) due to the smaller bundle size that is required on the first page load.  You will notice that our example includes the library &quot;lodash&quot; near the top of the index.js file as:  import _ from 'lodash';   However, the only lodash function that is used is within the &quot;filterResults(data, searchText)&quot; function:  function filterResults(data, searchText) { setFilteredResults( _.filter(data, (movie) =&gt; movie.title.toLowerCase().includes(searchText.toLowerCase())) ); }   This function only gets invoked once the user starts typing in the &quot;search&quot; field. As such, we can potentially improve our performance by only loading the &quot;lodash&quot; library when it's required (ie: once the user starts typing).  info Technically, lodash is not required in this case, as the native &quot;filter()&quot; method would also work here. However, this example highlights the syntax for dynamic imports, so we'll keep it in.  To dynamically import &quot;_&quot; from lodash we first remove it from the top of the file:  // import _ from 'lodash';   and insert it in our &quot;filterResults&quot; function using &quot;await&quot; and &quot;default&quot;, ie:  async function filterResults(data, searchText) { const _ = (await import('lodash')).default; setFilteredResults( _.filter(data, (movie) =&gt; movie.title.toLowerCase().includes(searchText.toLowerCase())) ); }   Notice how we updated our filterResults to use &quot;async&quot; - this was required as we must use &quot;await&quot; to wait for &quot;lodash&quot; to finish importing before we can use it in the &quot;setFilterResults&quot; function.  You can confirm that this is working if you open the &quot;network&quot; tab in the Developer Tools and refresh the app. You should see &quot;node_modules_lodash_lodash_js.js&quot; appear in the list once you start typing:    ","version":"Next","tagName":"h3"},{"title":"Dynamically Importing Components​","type":1,"pageTitle":"Improving / Optimizing Performance","url":"/WebProgrammingForAppsAndServices/Performance-Optimizations/improving-optimizing-performance#dynamically-importing-components","content":" Components can also be dynamically imported to reduce the initial bundle size and improve your performance.  In our application we use a number of components to render the UI, primarily from 'react-bootstrap&quot;: &quot;Container&quot;, &quot;Row&quot;, &quot;Col&quot;, &quot;Card&quot; and &quot;Accordion&quot;. In addition to these, we also include a custom component: &quot;StarRating&quot; that is only visible once a user clicks on an accordion header to view the content (Rating and Plot Summary). Like our above &quot;lodash&quot; example, this is a perfect candidate for dynamic loading, as it is not visible / required until a user initiates the an action.  If we wish to dynamically load the &quot;StarRating&quot; component, we must update our code as follows:  As before, remove the initial import:  // import StarRating from '@/components/StarRating';   Import the &quot;dynamic&quot; function from 'next/js'  import dynamic from 'next/dynamic';   Import the &quot;StarRating&quot; component using the &quot;dynamic&quot; function (included above), making sure to set the loading property:  const StarRating = dynamic(() =&gt; import('@/components/StarRating'), { loading: () =&gt; &lt;&gt;Loading...&lt;/&gt;, });   Create a flag in the &quot;state&quot; to track when the accordion has been opened:  const [accordionOpened, setAccordionOpened] = useState(false);   Add an &quot;onSelect&quot; event to the &lt;Accordion className=&quot;mt-4&quot;&gt;...&lt;/Accordion&gt; element so that we can execute code once the user opens the accordion.  &lt;Accordion className=&quot;mt-4&quot; onSelect={accordionSelected}&gt; ... &lt;/Accordion&gt;   Write the &quot;accordionSelected&quot; function to set the &quot;accordionOpened&quot; flag to true (after 200 seconds, to ensure that the animation is completed)  function accordionSelected(eventKey, e) { setTimeout(() =&gt; { setAccordionOpened(true); }, 200); // allow for the accordion animation to complete }   Ensure that the &quot;StarRating&quot; component is only shown once the &quot;accordionOpened&quot; flag has been set:  &lt;strong&gt;Rating:&lt;/strong&gt; {accordionOpened &amp;&amp; &lt;StarRating rating={movie.rating} /&gt;}   Once again, you can confirm that this is working if you open the &quot;network&quot; tab in the Developer Tools and refresh the app. You should see &quot;components_StarRating_js.js&quot; appear in the list once you open the first accordion section:    Additionally, you should temporarily see the text &quot;Loading...&quot; in place of the star rating the first time this component is loaded.  ","version":"Next","tagName":"h3"},{"title":"Refactoring to use SSG​","type":1,"pageTitle":"Improving / Optimizing Performance","url":"/WebProgrammingForAppsAndServices/Performance-Optimizations/improving-optimizing-performance#refactoring-to-use-ssg","content":" If at all possible, we would ideally like to pre-render as much of the page as we can. This can help reduce the time to first render and improve application performance. The home page for our practice &quot;app&quot; is a good candidate for SSG, since this is simply a static list of movies that isn't likely to change frequently. We have seen how this works when discussing Handling Events &amp; Rendering Data, so let's take what we have learned there and apply it to our Film Collection app as a final optimization before going to production:  Remove the import for useSWR as we will no longer need it:  //import useSWR from 'swr';   Remove the 'fetcher' definition used by SWR:  // const fetcher = (url) =&gt; fetch(url).then((res) =&gt; res.json());   Import the same &quot;getMovieData()&quot; function that your API uses to fetch the movie data. This will be used by &quot;getStaticProps&quot;, since this function is also executed on the server.  import getMovieData from '@/lib/movieData';   Add a &quot;getStaticProps&quot; function above the &quot;Home&quot; component definition:  export function getStaticProps() { const data = getMovieData(); return { props: { staticMovies: data } }; }   Update the &quot;Home&quot; component function definition to accept &quot;props&quot; (specifically, the &quot;staticMovies&quot; prop)  export default function Home({staticMovies})   Remove the &quot;useSWR&quot; function call (since we will no longer be needing it to obtain the data):  //const { data, error } = useSWR(`/api/movies`, fetcher);   Update the &quot;useState()&quot; hook for &quot;filteredResults&quot; to use &quot;staticMovies&quot; as the default value:  const [filteredResults, setFilteredResults] = useState(staticMovies);   Update our &quot;useEffect()&quot; hook to only watch for changes in &quot;searchText&quot; (since we no longer have &quot;data&quot; from SWR)  useEffect(() =&gt; { if (searchText) filterResults(staticMovies, searchText); }, [searchText]);   To confirm this is working, once again refresh the page. You can either view the Page Source directly to see all of the movie details in HTML, or view the &quot;localhost&quot; entry in the &quot;network tab&quot; of the Developer Tools. If you &quot;Preview&quot; the results, you will see an unstyled version of the page with the details for each movie visible.  ","version":"Next","tagName":"h3"},{"title":"Final Lighthouse Run​","type":1,"pageTitle":"Improving / Optimizing Performance","url":"/WebProgrammingForAppsAndServices/Performance-Optimizations/improving-optimizing-performance#final-lighthouse-run","content":" As a final check before our production build, let's re-run Lighthouse to confirm that our optimizations have helped to improve the Core Web Vitals of our app:   ","version":"Next","tagName":"h3"},{"title":"Layouts & Pages","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Pages-Routing/layouts-and-pages","content":"","keywords":"","version":"Next"},{"title":"Adding a Route​","type":1,"pageTitle":"Layouts & Pages","url":"/WebProgrammingForAppsAndServices/Pages-Routing/layouts-and-pages#adding-a-route","content":" Each &quot;route&quot; in our application / site is defined by the name of the file within the &quot;pages&quot; folder. In this case, we only have one route &quot;/&quot; because there is only one file in the &quot;pages&quot; folder: index.js (not including &quot;_app.js&quot; which is used to initialize pages - discussed later on).  We will be adding another route at &quot;/about&quot;. When complete, our application will have two routes:  Route: &quot;/&quot; - Renders component from &quot;pages/index.js&quot;Route &quot;/about&quot; - Renders component from &quot;pages/about.js&quot;  Here's how to add the /about route:  In the project's pages folder, add a file called: about.js  Pages folder structure 📂 pages ┣ 📂api ┣ 📂dashboard ┣ 📂fonts ┃ _app.js ┣ _document.js ┣ about.js &lt;-- added this file ┗ index.js   In the about.js file, add this code:  /pages/about.js export default function About() { return ( &lt;&gt; &lt;p&gt;About&lt;/p&gt; &lt;/&gt; ); }   caution The name of the exported component does not need to match the file name, since it is the file name that defines the route. However, the name of the component must be capitalized as usual.  In the browser, visit the /about route. The page contents will appear.  ","version":"Next","tagName":"h2"},{"title":"Nested Routes​","type":1,"pageTitle":"Layouts & Pages","url":"/WebProgrammingForAppsAndServices/Pages-Routing/layouts-and-pages#nested-routes","content":" It is sometimes necessary to define routes that are &quot;nested&quot; ie: &quot;/dashboard/preferences&quot;. To achieve this, we simply need to recreate the nested route as a nested folder structure within the pages folder. Additionally, if we place an index.js file nested within another folder, Next.js will automatically serve that component as the default route for that folder.  Let's expand our current list of routes to add two &quot;dashboard&quot; routes:  Route: &quot;/dashboard&quot; - Renders component from &quot;pages/dashboard/index.js&quot;Route &quot;/dashboard/preferences&quot; - Renders component from &quot;pages/dashboard/preferences.js&quot;  In the pages folder, add a folder called dashboard  📂 pages ┣ 📂 api ┣ 📂 dashboard &lt;-- create this folder ┣ 📂 fonts ┣ index.js ┗ ... etc   Within the pages/dashboard folder, add two new components:  File: &quot;pages/dashboard/index.js&quot;File: &quot;pages/dashboard/preferences.js&quot;  📂 pages ┣ 📂 api ┣ 📂 dashboard ┃ ┣ index.js &lt;-- add this file ┃ ┗ preferences.js &lt;-- add this file ┣ 📂 fonts ┣ index.js ┗ ... etc   In each file, add the code for a new endpoint:  Code snippet for the dashboard/index.js page:  pages/dashboard/index.js export default function DashboardHome() { return ( &lt;&gt; &lt;p&gt;Dashboard Home&lt;/p&gt; &lt;/&gt; ); }   Code for the dashboard/preferences page:  pages/dashboard/preferences.js export default function DashboardPreferences() { return ( &lt;&gt; &lt;p&gt;Dashboard Preferences&lt;/p&gt; &lt;/&gt; ); }   When complete, the application has this updated list of routes:  Route: &quot;/&quot; - Renders component from &quot;pages/index.js&quot;Route &quot;/about&quot; - Renders component from &quot;pages/about.js&quot;Route: &quot;/dashboard&quot; - Renders component from &quot;pages/dashboard/index.js&quot;Route &quot;/dashboard/preferences&quot; - Renders component from &quot;pages/dashboard/preferences.js&quot;  ","version":"Next","tagName":"h2"},{"title":"Layouts​","type":1,"pageTitle":"Layouts & Pages","url":"/WebProgrammingForAppsAndServices/Pages-Routing/layouts-and-pages#layouts","content":" If we have components that are re-used across multiple pages (ie: a common &quot;navbar&quot; / &quot;footer&quot;), we can place these in a custom &quot;Layout&quot; component, which can then be specified for the whole application. Let's begin by creating a very simple layout without any extra components.  In the project's components folder, add a new file called layout.js:  📦 my-app ┣ 📂 components ┃ ┗ layout.js &lt;-- add this file ┣ 📂pages ┣ 📂public ┣ 📂styles ┣ README.md ┣ package-lock.json ┗ ... etc   caution Since layouts are not &quot;pages&quot;, they must not be placed within the &quot;pages&quot; folder - instead, place them in a &quot;components&quot; folder, as we have previously done.  In the components/layout.js file, add this code:  components/layout.js export default function Layout(props) { return ( &lt;&gt; &lt;h1&gt;Pages / Routing in Next.js&lt;/h1&gt; &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt; | &lt;a href=&quot;/about&quot;&gt;About&lt;/a&gt; | &lt;a href=&quot;/dashboard&quot;&gt;Dashboard&lt;/a&gt; | &lt;a href=&quot;/dashboard/preferences&quot;&gt;Dashboard Preferences&lt;/a&gt; &lt;hr /&gt; &lt;br /&gt; {props.children} &lt;br /&gt; &lt;/&gt; ); }   You will notice that this looks exactly like any other custom component that we have created before, except instead of rendering specific data passed to props (or within the &quot;state&quot; of the component), it renders &quot;props.children&quot;. This is essentially a placeholder that renders the children of the component at a specific point in the layout. When using &quot;props.children&quot;, we will be including the component using the form &quot;&lt;Layout&gt;&lt;/Layout&gt;&quot; instead of the &quot;self-closing&quot; notation (ie: &lt;Layout /&gt;) that we have used so far.  To include this layout in all our pages, we must open the aforementioned &quot;_app.js&quot; file located within the &quot;pages&quot; folder and &quot;wrap&quot; the &lt;Component {...pageProps} /&gt; with our new layout:  pages/_app.js import Layout from '@/components/layout'; import '@/styles/globals.css'; export default function App({ Component, pageProps }) { return ( &lt;Layout&gt; &lt;Component {...pageProps} /&gt; &lt;/Layout&gt; ); }   Navigate to the website. You will see a common navigation bar with links to all our newly created routes.  info It is also possible to configure layouts on a page-by-page basis. See the official documentation for more information.  ","version":"Next","tagName":"h2"},{"title":"Client-Side Page Transitions​","type":1,"pageTitle":"Layouts & Pages","url":"/WebProgrammingForAppsAndServices/Pages-Routing/layouts-and-pages#client-side-page-transitions","content":" When browsing the site, you may have noticed that each route takes a moment to load, despite the fact there is little difference between the UI / DOM for each route. This is because the entirety of the app (ie: all .js files) is downloaded each time a new route is accessed - this can be confirmed by viewing the network activity in the dev tools. Fortunately, Next.js provides a mechanism to transition between pages without reloading every .js file for the application. This is known as &quot;client-side routing&quot; / &quot;client-side route transitions&quot;.  ","version":"Next","tagName":"h2"},{"title":"Link Component​","type":1,"pageTitle":"Layouts & Pages","url":"/WebProgrammingForAppsAndServices/Pages-Routing/layouts-and-pages#link-component","content":" Client-side routing can be achieved by replacing anchor tags (&lt;a&gt;...&lt;/a&gt;) with custom &quot;Link&quot; Components (&lt;Link&gt;...&lt;/Link&gt;) containing the &quot;href&quot; attribute. Let's test this by refactoring our Layout to use &quot;Link&quot;:  components/layout.js import Link from 'next/link'; export default function Layout(props) { return ( &lt;&gt; &lt;h1&gt;Pages / Routing in Next.js&lt;/h1&gt; &lt;Link href=&quot;/&quot;&gt;Home&lt;/Link&gt; | &lt;Link href=&quot;/about&quot;&gt;About&lt;/Link&gt; | &lt;Link href=&quot;/dashboard&quot;&gt;Dashboard&lt;/Link&gt; | &lt;Link href=&quot;/dashboard/preferences&quot;&gt;Dashboard Preferences&lt;/Link&gt; &lt;hr /&gt; &lt;br /&gt; {props.children} &lt;br /&gt; &lt;/&gt; ); }   You will find that the page transitions are much faster and that only the relevant .js is loaded when each route is first accessed. Once that route is accessed for a second time, nothing is download from the server - loading the required .js files on demand is known as &quot;Lazy Loading&quot;.  It is also important to note that the &quot;Link&quot; component accepts the following props (from the official documentation):  href - The path or URL to navigate to. This is the only required prop replace - Replace the current history state instead of adding a new url into the stack. Defaults to false scroll - Scroll to the top of the page after a navigation. Defaults to true prefetch - Prefetch the page in the background. Defaults to true. Any &lt;Link /&gt; that is in the viewport (initially or through scroll) will be preloaded. Prefetch can be disabled by passing prefetch=. When prefetch is set to false, prefetching will still occur on hover. Pages using Static Generation will preload JSON files with the data for faster page transitions. Prefetching is only enabled in production. shallow - Update the path of the current page without rerunning getStaticProps, getServerSideProps or getInitialProps. Defaults to false locale - The active locale is automatically prepended. locale allows for providing a different locale. When false href has to include the locale as the default behavior is disabled. onNavigate - An event handler called during client-side navigation. The handler receives an event object that includes a preventDefault() method, allowing you to cancel the navigation if needed.  ","version":"Next","tagName":"h3"},{"title":"useRouter Hook​","type":1,"pageTitle":"Layouts & Pages","url":"/WebProgrammingForAppsAndServices/Pages-Routing/layouts-and-pages#userouter-hook","content":" If we wish to achieve the same effect from within our component logic (such as in an &quot;onClick&quot; event handler), we must make use of the &quot;useRouter&quot; hook from &quot;next/router&quot;:  import { useRouter } from 'next/router';   This hook will be used to obtain a &quot;router&quot; object from within our component by invoking &quot;useRouter()&quot;:  const router = useRouter();   The router object itself has many useful properties, such as:  pathname: The current route - the path of the page in /pages. query: The query string parsed to an object, including dynamic route parameters. It will be an empty object during prerendering if the page doesn't have data fetching requirements. Defaults to  However, at the moment we are most interested in the &quot;push&quot; method to transition to a new route:  router.push('/'); // navigate to the home route &quot;/&quot;   This method accepts three arguments, ie:  url: The URL to navigate to (either as a string or urlObject) as: Optional decorator for the path that will be shown in the browser URL bar. options: Optional object with the following configuration options: scroll: Optional boolean, controls scrolling to the top of the page after navigation. Defaults to true shallow: Update the path of the current page without rerunning getStaticProps, getServerSideProps or getInitialProps. Defaults to false locale: Optional string, indicates locale of the new page ","version":"Next","tagName":"h3"},{"title":"React Introduction","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/React-NextJS-Introduction/react-introduction","content":"","keywords":"","version":"Next"},{"title":"MVVM​","type":1,"pageTitle":"React Introduction","url":"/WebProgrammingForAppsAndServices/React-NextJS-Introduction/react-introduction#mvvm","content":" From the official Knockout documentation:  Model: your application’s stored data. This data represents objects and operations in your business domain (e.g., bank accounts that can perform money transfers) and is independent of any UI. When using KO, you will usually make Ajax calls to some server-side code to read and write this stored model data.  View Model: a pure-code representation of the data and operations on a UI. For example, if you’re implementing a list editor, your view model would be an object holding a list of items, and exposing methods to add and remove items. Note that this is not the UI itself: it doesn’t have any concept of buttons or display styles. It’s not the persisted data model either - it holds the unsaved data the user is working with. When using KO, your view models are pure JavaScript objects that hold no knowledge of HTML. Keeping the view model abstract in this way lets it stay simple, so you can manage more sophisticated behaviors without getting lost.  View: a visible, interactive UI representing the state of the view model. It displays information from the view model, sends commands to the view model (e.g., when the user clicks buttons), and updates whenever the state of the view model changes.  This concept drastically changed how to think about the designing sites / applications on the web. By introducing this &quot;Separation of Concerns&quot;, we can create code that is modular, reusable and testable.  In 2011 Facebook employee Jordan Walke created an early prototype of React called &quot;FaxJS&quot; which focused on creating &quot;components&quot;, essentially providing the &quot;view model&quot; and &quot;view&quot; for reusable pieces of a User Interface (UI). Multiple components would then be combined to create a functional web site / app.  Quick Note: &quot;Web Components&quot; are now standardized and available in modern browsers. Please refer to the MDN Documentation for more information.  In 2013, React was released as open source and has steadily grown in use among developers, even surpassing popular frameworks like Angular and Vue in metrics such as Questions per Month on Stack Overflow and Most commonly used Web Framework in the 2021 Stack Overflow Survey of over 67,000 professional developers.  ","version":"Next","tagName":"h2"},{"title":"Getting Started​","type":1,"pageTitle":"React Introduction","url":"/WebProgrammingForAppsAndServices/React-NextJS-Introduction/react-introduction#getting-started","content":" To get started creating applications with React, technically all we need to do is to add some scripts to an existing HTML page and start creating and rendering our components, ie:  &lt;h1&gt;React&lt;/h1&gt; &lt;!-- We will put our React component inside this div. --&gt; &lt;div id=&quot;main_container&quot;&gt;&lt;/div&gt; &lt;!-- Load React. --&gt; &lt;!-- Note: when deploying, replace &quot;development.js&quot; with &quot;production.min.js&quot;. --&gt; &lt;script src=&quot;https://unpkg.com/react@18/umd/react.development.js&quot; crossorigin&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/react-dom@18/umd/react-dom.development.js&quot; crossorigin&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/babel&quot;&gt; 'use strict'; // Hello Component function Hello(props){ return &lt;p&gt;message: {props.message}&lt;/p&gt; } // Main Component function Main() { return ( &lt;div&gt; &lt;Hello message='Hello World' /&gt; &lt;Hello message='This is a test' /&gt; &lt;/div&gt; ); } const root = ReactDOM.createRoot(document.querySelector('#main_container')); root.render(React.createElement(Main)); &lt;/script&gt;   However, we will be building larger apps and while adding React to an Existing Project is indeed possible (as we have seen above), we would prefer to use something that scales better and gives a superior development experience. Here, the idea of &quot;Toolchains&quot; comes into play, ie:  &quot;A set of programming tools that is used to perform a complex software development task or to create a software product&quot;  When working with React, this will typically be things like Webpack, Babel, ESLint and Jest among many others. Fortunately, there are frameworks available for us to use that have these &quot;toolchains&quot; correctly configured and optimized. For example:  React Router: &quot;The most popular routing library for React and can be paired with Vite to create a full-stack React framework. It emphasizes standard Web APIs and has several ready to deploy templates for various JavaScript runtimes and platforms.&quot;Next.js: &quot;A popular and lightweight framework for static and server‑rendered applications built with React. It includes styling and routing solutions out of the box, and assumes that you’re using Node.js as the server environment.&quot;Gatsby: &quot;The best way to create static websites with React. It lets you use React components, but outputs pre-rendered HTML and CSS to guarantee the fastest load time.&quot;Many others including: Remix, Expo, etc.  ","version":"Next","tagName":"h2"},{"title":"Next.js​","type":1,"pageTitle":"React Introduction","url":"/WebProgrammingForAppsAndServices/React-NextJS-Introduction/react-introduction#nextjs","content":" For this course, we will be choosing Next.js, which describes itself as &quot;the best developer experience with all the features you need for production: hybrid static &amp; server rendering, TypeScript support, smart bundling, route pre-fetching, and more. No config needed&quot;. This sounds perfect for our purposes, so why don't we get started and see what the starter app looks like for Next.js.  To begin, create a new folder on your machine and open it using Visual Studio Code. Next, open the Integrated Terminal and (assuming that you want to create a new app (and folder) named “my-app”) execute the command:  npx create-next-app@15 my-app --use-npm   You will then be asked to make some decisions regarding what to include in your new app (for now, we will chose the following values):  ? Would you like to use TypeScript? … No / Yes  ? Which linter would you like to use? › - Use arrow-keys. Return to submit. ESLint  ? Would you like to use Tailwind CSS? … No / Yes  ? Would you like your code inside a src/ directory? … No / Yes  ? Would you like to use App Router? (recommended) … No / Yes  ? Would you like to use Turbopack? (recommended) … No / Yes  ? Would you like to customize the import alias (@/* by default)? … No / Yes  The process will create a new folder called “my-app”, with the code needed to get started using Next.js. Once it finishes its initial setup (downloading dependencies, etc), you can view the starter site immediately by executing the commands:  cd my-app npm run dev   This will start a development server on localhost on port &quot;3000&quot; (http://localhost:3000) and when opened in the browser, should look something like this:    ","version":"Next","tagName":"h3"},{"title":"File Structure​","type":1,"pageTitle":"React Introduction","url":"/WebProgrammingForAppsAndServices/React-NextJS-Introduction/react-introduction#file-structure","content":" Now that we know how to create a &quot;Next.js&quot; app, let's walk through some of what was created during the &quot;create-next-app&quot; process. If you open the file explorer tab in Visual Studio Code, you should see the following:  📦 my-app ┣ 📂 node_modules ┣ 📂 pages ┃ ┣ 📂 api ┃ ┃ ┗ hello.js ┃ ┣ _app.js ┃ ┣ _document_.js ┃ ┗ index.js ┣ 📂 public ┃ ┣ favicon.ico ┃ ┣ file.svg ┃ ┣ globe.svg ┃ ┣ favicon.js ┃ ┣ next.svg ┃ ┣ vercel.svg ┃ ┗ window.svg ┣ 📂 styles ┃ ┣ globals.css ┃ ┗ Home.module.css ┣ .gitignore ┣ eslint.config.mjs ┣ jsconfig.json ┣ next.config.mjs ┣ package-lock.json ┣ package.json ┗ README.md   At first, we will not be touching many of these files and will be adding more folders and files to this structure in the near future. For the time being however, let's discuss the following areas already created for us:  &quot;pages&quot; Folder: This folder is responsible for containing the components that will act as &quot;routes&quot; for our application, ie: any file added to the &quot;pages&quot; directory is automatically available as a route. For example, currently we have an &quot;index&quot; route, ie &quot;/&quot; - this file (index.js) is where we find the &quot;Home&quot; component, which contains the code to render our &quot;Welcome to Next.js!&quot; page. Additionally, we have an &quot;api&quot; folder, currently containing the file &quot;hello.js&quot; with the code to return {&quot;name&quot;:&quot;John Doe&quot;} at the route &quot;/api/hello&quot;. &quot;public&quot; Folder: This is where we will keep any static resources for our app / site. For example, you can see that one of the files contained therein is &quot;next.svg&quot; - this file is referenced in the &quot;Home&quot; component (index.js) with the code: &lt;Image className={styles.logo} src=&quot;/next.svg&quot; alt=&quot;Next.js logo&quot; width={180} height={38} priority /&gt; &quot;styles&quot; Folder: As the name suggests, this is where we will be storing our .css files for the application. At the moment, you will find two files: &quot;globals.css&quot;: referenced in the &quot;_app.js&quot;, the file containing the top-level &quot;App&quot; component (discussed later) &quot;Home.module.css&quot;: referenced in the &quot;index.js&quot; file, used by the &quot;Home&quot; component. info The &quot;.module.css&quot; extension identifies the file as a &quot;CSS Module&quot; which will &quot;locally scope CSS by automatically creating a unique class name. This allows you to use the same CSS class name in different files without worrying about collisions.&quot; ","version":"Next","tagName":"h3"},{"title":"Learning resources","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Resources/learning-resources","content":"","keywords":"","version":"Next"},{"title":"Developer tools​","type":1,"pageTitle":"Learning resources","url":"/WebProgrammingForAppsAndServices/Resources/learning-resources#developer-tools","content":" Visual Studio Code (info, download) Getting started docs Browsers (current versions of Chrome, Firefox, Safari, Opera, Edge)Browser dev toolsHTTP inspector (e.g. Thunder Client)PlunkerjsFiddlejsBinOther dev tools will be introduced as we make progress through the weekly topics  You will need one or more devices. A College or personal desktop or laptop, and (likely) a personal mobile device (e.g. a smartphone).  ","version":"Next","tagName":"h2"},{"title":"Required textbook​","type":1,"pageTitle":"Learning resources","url":"/WebProgrammingForAppsAndServices/Resources/learning-resources#required-textbook","content":" None. This is a web programming course therefore, the best source for content is on the web!  ","version":"Next","tagName":"h2"},{"title":"Required online resources​","type":1,"pageTitle":"Learning resources","url":"/WebProgrammingForAppsAndServices/Resources/learning-resources#required-online-resources","content":" There are several required online resources:  The Mozilla Developer Network MDN Web Docs web site is vast, with thousands of documents. It is a trusted and authoritative source for web developer information. Of interest: HTML5 Guide, including HTML Forms Guide, and the HTML5 Element List CSS Reference JavaScript Reference JavaScript Reference(Also suggested) You Don't Know JavaScript DOM Reference  In October 2017, Microsoft, Google, and the W3C committed to making MDN Web Docs the single authoritative source for web developer documentation. Read more about this in an article by Ali Spivak.  Others:  Bootstrap (version 3) CSS documentation Links to other topics (e.g. Getting started, etc.) are on that page Official Next.js Documentation Node Reference Node.js Documentation(Suggested) nodejitsu Express.js Documentation TypesScript Reference  Oh, and you should must know (and love!) the series of RFCs that describe HTTP, 7230 through 7235. If you want a friendlier introduction to HTTP, read its Wikipedia article.  ","version":"Next","tagName":"h2"},{"title":"Other resources​","type":1,"pageTitle":"Learning resources","url":"/WebProgrammingForAppsAndServices/Resources/learning-resources#other-resources","content":" W3C Standards Google web developers content  Front end frameworks  ReactNext.js  Alternatives:  Angular (which is NOT AngularJS, a legacy technology)Vueand many others...  State management  JSON data API - jsonplaceholder  HTML and CSS  CSS Selectors - MDNCSS Attribute Selectors - MDN  ","version":"Next","tagName":"h2"},{"title":"Visual Studio Code tips and info​","type":1,"pageTitle":"Learning resources","url":"/WebProgrammingForAppsAndServices/Resources/learning-resources#visual-studio-code-tips-and-info","content":" Start VS Code from the command line  Make sure that you're in your project folder. Then type this command: code .  caution This assumes that your computer is configured to run this command. See the Running VS Code on Mac to configure that feature.    Useful keyboard shortcuts  Trigger IntelliSense: Control + Space  Toggle comments on/off: Command + /  Reformat document: Shift + Option + Command + F  Show/hide left-side bar: Command + B  Show/hide terminal: Control + (back-tick)  Markdown preview pane toggle on/off: Command + K, V  Useful Emmet snippets  For most elements, just begin typing the element name, without the angle bracket.  . Declare class(es), e.g. div.row  # Declare unique identifier, e.g. table#customers  &gt; Child, e.g. div&gt;p  * Multiplier, e.g. ul&gt;li*5  ( ) Grouping, often used with multiplier  + Sibling, e.g. div&gt;h3+p*3  {blahblah} Text content for an element, e.g. h3{Hello, world!}  [ Custom attribute, e.g. span[data-bind  See the Emmet cheat sheet for full coverage. ","version":"Next","tagName":"h2"},{"title":"Components","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/React-NextJS-Introduction/react-components","content":"","keywords":"","version":"Next"},{"title":"Creating our own Component​","type":1,"pageTitle":"Components","url":"/WebProgrammingForAppsAndServices/React-NextJS-Introduction/react-components#creating-our-own-component","content":" Now that we have seen what a basic component consists of, let's create our own component using the same pattern to explore the unique syntax and functionality that can be achieved using functional components.  Start by creating a new folder called &quot;components&quot; in the &quot;my-app&quot; directory. Next, within this folder, create a file called &quot;Hello.js&quot; (Our component will be named &quot;Hello&quot;). Inside the component, we will add everything required for a basic component that outputs (you guessed it: &quot;Hello World&quot;), ie:  export default function Hello() { return &lt;p&gt;Hello World!&lt;/p&gt; }   To actually see this component working, we need to render it on the page somewhere. Since we really only have one route / page at the moment (ie: &quot;Home&quot;, defined in &quot;index.js&quot;), let's place it there.  Before we do so however, we should first wipe out most of the code for our &quot;Home&quot; component, leaving a &quot;blank slate&quot; for us to start fresh. Go ahead and wipe out all of the code within the &quot;return&quot; statement, as well as the &quot;include&quot; statements, leaving only:  export default function Home() { return ( ) }   Next, at the top of the file, add the following &quot;import&quot; statement:  import Hello from '@/components/Hello';   Once that is complete, include the &quot;Hello&quot; component as the only item in the return statement:  &lt;Hello /&gt;   This should cause your index.js file to look like the following;  import Hello from '@/components/Hello'; export default function Home() { return ( &lt;Hello /&gt; ) }   Once you have saved everything, head back to your browser to see the changes - &quot;Hello World!&quot;  ","version":"Next","tagName":"h2"},{"title":"Introducing JSX​","type":1,"pageTitle":"Components","url":"/WebProgrammingForAppsAndServices/React-NextJS-Introduction/react-components#introducing-jsx","content":" With our &lt;Hello /&gt; component now displaying correctly within our &quot;Home&quot;, let's discuss the strange syntax within the return value of &quot;Home&quot; and other components. It is responsible for how the component is rendered and looks like a String or HTML, but it is in fact, neither:  &quot;It is called JSX, and it is a syntax extension to JavaScript. We recommend using it with React to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript&quot;.  ","version":"Next","tagName":"h2"},{"title":"Returning a Single Element​","type":1,"pageTitle":"Components","url":"/WebProgrammingForAppsAndServices/React-NextJS-Introduction/react-components#returning-a-single-element","content":" Whenever we use JSX, we must ensure that whatever we return is wrapped in a single element. This is because part of the build process for our Next.js apps involves Babel transforming JSX into function calls using utilities from react/jsx-runtime. These functions take the component type, props, and children as arguments, ie:  const element = &lt;p className=&quot;greeting&quot;&gt;Hello, world!&lt;/p&gt;   becomes:  import { jsx as _jsx } from 'react/jsx-runtime'; const element = _jsx('p', { className: 'greeting', children: 'Hello, world!' });   info If you do not wish to include a &quot;wrapper&quot; component (ie: a &lt;div&gt;...&lt;/div&gt;, &lt;span&gt;...&lt;/span&gt;, etc) you may instead use a &quot;JSX Fragment&quot; (ie: &lt;&gt;...&lt;/&gt;), which will not create an extra node in the DOM.  ","version":"Next","tagName":"h3"},{"title":"Empty Elements​","type":1,"pageTitle":"Components","url":"/WebProgrammingForAppsAndServices/React-NextJS-Introduction/react-components#empty-elements","content":" Also, When using JSX, there is no notion of an &quot;empty element&quot;, so be careful when using tags like:  &lt;br&gt;   as this will actually cause a problem and your component will not compile, due to the error &quot;JSX fragment has no corresponding closing tag.&quot;. Instead, you must use the &quot;self-closing&quot; syntax, ie:  &lt;br /&gt;   ","version":"Next","tagName":"h3"},{"title":"Embedding Expressions in JSX​","type":1,"pageTitle":"Components","url":"/WebProgrammingForAppsAndServices/React-NextJS-Introduction/react-components#embedding-expressions-in-jsx","content":" In the example below, we declare a variable called name and then use it inside JSX by wrapping it in curly braces:  export default function Hello() { const name = 'Josh Perez'; return &lt;p&gt;Hello {name}!&lt;/p&gt; }   You can put any valid JavaScript expression inside the curly braces in JSX. For example, 2 + 2, user.firstName, or formatName(user) are all valid JavaScript expressions.  In the example below, we embed the result of calling a JavaScript function, formatName(user), into a &lt;p&gt; element.  function formatName(user) { return user.firstName + ' ' + user.lastName; } export default function Hello() { const user = { firstName: 'Harper', lastName: 'Perez', }; return ( &lt;p&gt; Hello, {formatName(user)}! &lt;/p&gt; ); }   We often split JSX over multiple lines for readability (as above). While it isn’t required, when doing this, we also recommend wrapping it in parentheses to avoid the pitfalls of automatic semicolon insertion.  ","version":"Next","tagName":"h3"},{"title":"JSX is an Expression Too​","type":1,"pageTitle":"Components","url":"/WebProgrammingForAppsAndServices/React-NextJS-Introduction/react-components#jsx-is-an-expression-too","content":" After compilation, JSX expressions become regular JavaScript function calls and evaluate to JavaScript objects.  This means that you can use JSX inside of if statements and for loops, assign it to variables, accept it as arguments, and return it from functions:  function getGreeting(user) { if (user) { return &lt;p&gt;Hello, {formatName(user)}!&lt;/p&gt; } return &lt;p&gt;Hello, Stranger.&lt;/p&gt; }   ","version":"Next","tagName":"h3"},{"title":"Specifying Attributes with JSX​","type":1,"pageTitle":"Components","url":"/WebProgrammingForAppsAndServices/React-NextJS-Introduction/react-components#specifying-attributes-with-jsx","content":" You may use quotes to specify string literals as attributes:  const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;   You may also use curly braces to embed a JavaScript expression in an attribute:  const element = &lt;img src={user.avatarUrl} /&gt;   Don’t put quotes around curly braces when embedding a JavaScript expression in an attribute. You should either use quotes (for string values) or curly braces (for expressions), but not both in the same attribute.  Warning:  Since JSX is closer to JavaScript than to HTML, React DOM uses camelCase property naming convention instead of HTML attribute names.  For example, class becomes className in JSX, and tabindex becomes tabIndex.  ","version":"Next","tagName":"h3"},{"title":"Accepting \"Props\"​","type":1,"pageTitle":"Components","url":"/WebProgrammingForAppsAndServices/React-NextJS-Introduction/react-components#accepting-props","content":" Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen.  For example, we can extend our &quot;Hello&quot; component to accept one or more &quot;props&quot; by including the &quot;props&quot; parameter to our function definition and accessing each named &quot;prop&quot; as an attribute using the same name, ie:  export default function Hello(props) { return ( &lt;p&gt; Hello {props.fName} {props.lName}! &lt;/p&gt; ); }   will allow us to provide &quot;fName&quot; and &quot;lName&quot; values to the component using the straightforward syntax:  &lt;Hello fName=&quot;Jason&quot; lName=&quot;Perez&quot; /&gt;   info If we wish to have default values for props (in this case: fName and lName), we can update the function definition to use object destructuring with default values: export default function Hello({ fName = 'First Name', lName = 'Last Name' }) { // NOTE: props will be accessed using fName and lName instead of props.fName and props.lName }   ","version":"Next","tagName":"h2"},{"title":"Introducing \"Hooks\".​","type":1,"pageTitle":"Components","url":"/WebProgrammingForAppsAndServices/React-NextJS-Introduction/react-components#introducing-hooks","content":" As of version 16.8, React has introduced a feature known as &quot;hooks&quot;. Using this syntax will open up some new, interesting possibilities to our functional components, including working with the &quot;state&quot; as well as performing &quot;side effects&quot; during the lifetime of the component (ie: &quot;Data fetching, setting up a subscription, and manually changing the DOM in React components&quot;).  Basically, by using certain built-in &quot;hooks&quot; (functions), React components are able to store and manage data internally to the component (ie, its &quot;state&quot; values). When this data changes, a refresh (render) of the component will occur and the user interface will be updated. This allows us to create components that work with data internally that changes over time.  To actually see this in action, let's create a new component called Clock:  First, create a new file in &quot;components&quot; called &quot;Clock.js&quot;. Once this is done, add the following code:  import { useState, useEffect } from 'react'; export default function Clock(props) { return ( &lt;p&gt; Locale: {props.locale}: &lt;mark&gt;TODO: Render Locale-Dependant Clock Here&lt;/mark&gt; &lt;/p&gt; ); }   So far, this looks very similar to our &quot;Hello&quot; component above; it is defined as a function that accepts props and it returns some JSX to be rendered. However, there is one key difference: we have imported both the useState and the useEffect hooks from 'react'. Soon, we will use these functions within our component.  For now, let's just add the Clock component to our Home so that we can see what it outputs:  Open the index.js file and add the following &quot;import&quot; statement:  import Clock from '@/components/Clock';   Next, include the &quot;Clock&quot; component beneath the &lt;Hello /&gt; tag using its associated &quot;self-closing&quot; tag, as well as some code to include the locale as its only &quot;prop&quot;:  &lt;Clock locale=&quot;en-CA&quot; /&gt;   Currently, we should see the locale next to some highlighted text stating &quot;TODO: Render Locale-Dependant Clock Here&quot;.  ","version":"Next","tagName":"h2"},{"title":"Adding \"state\"​","type":1,"pageTitle":"Components","url":"/WebProgrammingForAppsAndServices/React-NextJS-Introduction/react-components#adding-state","content":" As mentioned above, the &quot;state&quot; of a component is a way to store data within the component (ie: the &quot;date&quot; data for our clock) that is synchronized with the UI of the component. This is a very powerful concept and one of the core ideas behind designing apps using components.  For our example, let's add a &quot;state&quot; value to our &lt;Clock /&gt; component, so that we can keep the UI of the component in sync with the current time. In this way, we can say that each &lt;Clock /&gt; component keeps track of its own internal Date value. It will also be responsible for updating its UI every second to reflect changes in this data.  Here is where we will use our first hook: useState(). In the first line of your &quot;Clock&quot; function, add the line:  const [date, setDate] = useState(null); // Note: Never set this to unknown data obtained at run time (ie: new Date(), a random number, etc.) - see: https://nextjs.org/docs/messages/react-hydration-error   Here, we can see that &quot;useState&quot; is a function, which:  Accepts a parameter that allows us to set the initial value of a &quot;state&quot; variable Returns an array consisting two values: the &quot;state&quot; variable itself and a function to update it. We use a destructuring assignment to assign each of those values to a pair of constant variables - in this case: &quot;date&quot; and &quot;setDate&quot;. In the above case, this is shorthand for: const dateState = useState(null); const date = dateState[0]; const setDate = dateState[1]; We use the &quot;const&quot; keyword here since we must use the &quot;setDate&quot; function to modify the state value &quot;date&quot; - we cannot modify &quot;date&quot; directly. By invoking the &quot;setDate&quot; method (ie: &quot;setDate(New Date Value)&quot;), we not only update the value of &quot;date&quot;, but also trigger our component to re-render!  Now, let's add some code to attempt to render the &quot;date&quot; value within our component. Here, we will be using the toLocaleTimeString function, ie:  return ( &lt;p&gt;Locale: {props.locale}: {date.toLocaleTimeString(props.locale)} &lt;/p&gt; );   However, if we refresh the page now, we should see an error since at this point since &quot;date&quot; is currently null, ie:  TypeError: Cannot read properties of null (reading 'toLocaleTimeString')   For the mean time (until we have a real date object that we can use), we can avoid this error by using the Optional Chaining Operator on our date object, ie:  {date?.toLocaleTimeString(props.locale)}   ","version":"Next","tagName":"h3"},{"title":"Quick Note: \"state\" vs. \"props\"​","type":1,"pageTitle":"Components","url":"/WebProgrammingForAppsAndServices/React-NextJS-Introduction/react-components#quick-note-state-vs-props","content":" While &quot;state&quot; &amp; &quot;props&quot; both hold information that can be used to influence the output of the rendered component, they are different in one important way: props get passed to the component whereas state is managed within the component.  One interesting thing to note about &quot;props&quot; is that we can pass anything as a property, including functions! This can be very helpful if we wish to send a message from a &quot;child&quot; component to a &quot;parent&quot; component. For example, if we define a function (ie: handleMessage(msg)) in the &quot;Parent&quot; component, we can pass it in to the &quot;Child&quot; component using a custom property, ie &quot;sendMessage&quot;). Whenever the child wishes to send a message back to the parent, it can invoke the callback function from &quot;props&quot; and pass the data:  Parent Component  function handleMessage(msg) { console.log(`Child Says: ${msg}`); } return &lt;Child sendMessage={handleMessage} /&gt;   Child Component  props.sendMessage('Hello');   ","version":"Next","tagName":"h3"},{"title":"Updating the <Clock /> Component using the \"useEffect\" Hook​","type":1,"pageTitle":"Components","url":"/WebProgrammingForAppsAndServices/React-NextJS-Introduction/react-components#updating-the-clock--component-using-the-useeffect-hook","content":" At the moment, our &lt;Clock /&gt; component has a &quot;date&quot; value in the state, but it's currently set to &quot;null&quot; so we are unable to see any values output in the browser. If we cannot set a new date value as the the initial value of the &quot;state&quot; variable (potentially causing a &quot;Hydration Error&quot; in this case), where do we initialize it?  This is where the useEffect Hook comes into play. This hook allows us to provide a function that only executes under certain conditions, for example when the component is &quot;first rendered&quot;. To see this in action, place the following code above your return statement in the &quot;Clock&quot; function:  useEffect(() =&gt; { setDate(new Date()); }, []);   Here, you will notice that the useEffect hook actually accepts two parameters: a callback function and an array of &quot;dependencies&quot;. The callback function is simply the code to be executed once the component is first &quot;mounted&quot; and rendered, while the dependency array is a list of variables that, when changed, will cause the effect to execute again. Since we only want this effect to execute once, we can provide an empty array.  Now if we refresh the page, we should see a clock value showing the current time!  However, if we wish our &lt;Clock /&gt; component to function as a proper clock and update the UI every second, we must add some additional logic. As expected, this will involve the setInterval() function to update the date value every second. To achieve this functionality, update the code in your useEffect hook to set a new date once every second, ie:  useEffect(() =&gt; { setDate(new Date()); // update the date once every second const timerID = setInterval(() =&gt; { setDate(new Date()); }, 1000); }, []);   caution If the new value of your state variable depends on the previous value, consider using an &quot;updater function&quot;. For more information, see: Updating state based on the previous state / Is using an updater always preferred?    When / How to Stop the interval?  At the moment, our code has no mechanism to stop the interval using clearInterval() when it is no longer needed. This would be part of a clean-up process and should execute when the component is &quot;unmounted&quot; or removed from the DOM.  Fortunately, we can handle this situation within the return value of the callback function provided to useEffect, ie:  useEffect(() =&gt; { setDate(new Date()); // update the date once every second const timerID = setInterval(() =&gt; { setDate(new Date()); }, 1000); return () =&gt; { // clean up the effect clearInterval(timerID); }; }, []);  ","version":"Next","tagName":"h3"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Testing-Introduction/example-code","content":"Example Code You may download the sample code for this topic here: Testing-Introduction","keywords":"","version":"Next"},{"title":"E2E (End to End) Testing","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Testing-Introduction/e2e-testing","content":"","keywords":"","version":"Next"},{"title":"Installing / Configuring Cypress​","type":1,"pageTitle":"E2E (End to End) Testing","url":"/WebProgrammingForAppsAndServices/Testing-Introduction/e2e-testing#installing--configuring-cypress","content":" To begin using Cypress for E2E testing, we first must install and configure it. For this example, we will be writing some tests on a sample application that implements &quot;Iron Session&quot;.  To get started, obtain the &quot;iron-session&quot; example from the Example Code.  Open this folder in Visual Studio Code and execute the following command in the Integrated Terminal:  npm install   You can then test that the example is functioning correctly by running the sample using the familiar command:  npm run dev   Once you are satisfied that it is working as expected, we can begin to install Cypress:  Install Cypress using NPM:  npm install --save-dev cypress   Add the following entry to &quot;scripts&quot; in package.json  &quot;cypress&quot;: &quot;cypress open&quot;   Execute the command:  npm run cypress   This will open the &quot;Cypress&quot; app, which will provide a visual interface to help us configure the application for testing:    Click on the &quot;E2E Testing&quot; Box to configure the &quot;Iron Session&quot; example. This performs the following actions:  Adds a &quot;cypress.config.js&quot; file at the root of the folder Adds a &quot;cypress/fixtures&quot; folder containing the file: &quot;example.json&quot; Adds a &quot;cypress/support&quot; folder containing the files: &quot;commands.js&quot; and &quot;e2e.js&quot; You can click the &quot;Continue&quot; button at the bottom to proceed to the next step  At the &quot;Choose a Browser&quot; prompt, click the green button to use the default option. This will likely be: &quot;Start E2E testing in Chrome&quot;    This will open a new Chrome window with the Cypress UI  At the next prompt: &quot;Create your first spec&quot;, you can create your first spec file by clicking the &quot;Create new empty spec&quot; button on the right.    This will create a new folder in the &quot;cypress&quot; directory called &quot;e2e&quot; which will contain the first spec file: spec.cy.js  Once the spec is successfully added, ie:  describe('empty spec', () =&gt; { it('passes', () =&gt; { cy.visit('https://example.cypress.io'); }); });   You can click the &quot;Okay, run the spec&quot; button to test it. You should see that the test runner successfully navigates to &quot;https://example.cypress.io&quot; and the spec passes.  Once this is done, you may close Cypress in the Integrated Terminal in Visual Studio Code with &quot;Ctrl + C&quot;  ","version":"Next","tagName":"h2"},{"title":"Testing the \"iron-session\" example​","type":1,"pageTitle":"E2E (End to End) Testing","url":"/WebProgrammingForAppsAndServices/Testing-Introduction/e2e-testing#testing-the-iron-session-example","content":" With Cypress correctly configured and executing a simple, boilerplate test, we can now focus on writing meaningful tests that test an example application that leverages &quot;Iron Session&quot; for authentication.  Before we write our first tests however, we must make one important configuration change: adding a baseUrl for our application:  By adding a baseUrl in your configuration Cypress will attempt to prefix the baseUrl any URL provided to commands like cy.visit() and cy.request() that are not fully qualified domain name (FQDN) URLs. This allows you to omit hard-coding fully qualified domain name (FQDN) URLs in commands. For example, cy.visit('http://localhost:3000/login') can be shortened to cy.visit('/login')  To achieve this in our application, we must open the cypress.config.js file and modify it to include a baseUrl property under &quot;e2e&quot;, ie:  const { defineConfig } = require('cypress'); module.exports = defineConfig({ e2e: { setupNodeEvents(on, config) { // implement node event listeners here }, baseUrl: 'http://localhost:3000', }, });   ","version":"Next","tagName":"h2"},{"title":"Cypress Test Syntax​","type":1,"pageTitle":"E2E (End to End) Testing","url":"/WebProgrammingForAppsAndServices/Testing-Introduction/e2e-testing#cypress-test-syntax","content":" You have probably noticed that the syntax for writing tests looks very similar to what was discussed when we wrote our first tests using &quot;Jest&quot;. There exists a &quot;describe&quot; function as well as an &quot;it&quot; function that works the same way as the &quot;test&quot; function in Jest (to identify a test).  info Recall, you can use the function &quot;it()&quot; in Jest as well, instead of &quot;test()&quot;, as &quot;it()&quot; is an alias for &quot;test()&quot; - see: https://jestjs.io/docs/api#testname-fn-timeout  The common functions and commands that we will be using to write our tests are as follows. For a full list of commands, see &quot;Commands&quot; in the official Cypress documentation:    describe(name, fn): Creates a block that groups several related tests together:  describe('some tests', () =&gt; { // test definitions here });     it(name, fn) - This is the function that defines a test, identified by &quot;name&quot;  it('test name', () =&gt; { // test &quot;expectations&quot; here });     cy.visit() - Visit (navigate to) a remote URL  cy.visit('/'); // visits the baseUrl cy.visit({ url: '/pages/hello.html', method: 'GET', });     cy.url() - Get the current URL of the page that is currently active.  cy.url(); // Yields the current URL as a string     cy.should() - Create an assertion. Assertions are automatically retried until they pass or time out. These typically take the form of .should(chainer, value), where &quot;chainer&quot; is one of the available assertions listed here, such as &quot;include&quot;, &quot;match&quot;, etc. and are chained (cannot be called directly from &quot;cy&quot;).  cy.url().should('include', '/login'); cy.url().should('match', /.*(\\/login)/);     cy.get() - Get one or more DOM elements by selector or alias  cy.get('.list &gt; li'); // Yield the &lt;li&gt;'s in .list     cy.contains() - Get the DOM element containing the text. DOM elements can contain more than the desired text and still match. Additionally, Cypress prefers some DOM elements over the deepest element found.  cy.get('.nav').contains('About'); // Yield element in .nav containing 'About' cy.contains('Hello'); // Yield first element in document containing 'Hello'     cy.click() - Click a DOM element.  cy.get('.btn').click(); // Click on button cy.contains('Welcome').click(); // Click on first element containing 'Welcome'     cy.type() - Type into a DOM element. Curly braces () may be used to type a key such as &quot;enter&quot;, &quot;esc&quot;, &quot;backspace&quot;, etc.  cy.get('input').type('Hello, World'); // Type 'Hello, World' into the 'input' cy.get('input').type('{enter}'); // Press the &quot;enter&quot; key while on the 'input'   ","version":"Next","tagName":"h3"},{"title":"Test 1 Protected Route /profile-sg​","type":1,"pageTitle":"E2E (End to End) Testing","url":"/WebProgrammingForAppsAndServices/Testing-Introduction/e2e-testing#test-1-protected-route-profile-sg","content":" For this first test, we will assert that the &quot;/profile-sg&quot; route cannot be accessed without first logging in. To create this test, we will be using the &quot;spec.cy.js&quot; file, so go ahead and comment out the existing test that was created for us:  // describe('empty spec', () =&gt; { // it('passes', () =&gt; { // cy.visit('https://example.cypress.io') // }) // })   Instead, we will be defining a new block of tests, ie:  describe('login / logout flow specification', () =&gt; {});   Within the callback, we will write the first test. The steps we need to verify are  User attempts to navigate (visit) the route &quot;/profile-sg&quot;User is redirected to &quot;/login&quot; route  To test the above flow, we can use the following test:  it('cannot navigate to /profile-sg without being logged in', () =&gt; { cy.visit(&quot;/profile-sg&quot;) .url().should('include', &quot;/login&quot;); });   Notice how we can &quot;chain&quot; the operations, ie cy.visit().url().should(). In the above code, we first attempt to visit the route &quot;/profile-sg&quot; and once this is complete, we examine the url to ensure that we are indeed at &quot;login&quot;.  ","version":"Next","tagName":"h3"},{"title":"Test 2 Rejecting Invalid Github Users​","type":1,"pageTitle":"E2E (End to End) Testing","url":"/WebProgrammingForAppsAndServices/Testing-Introduction/e2e-testing#test-2-rejecting-invalid-github-users","content":" To verify the login functionality of the app, we should make sure that an unknown GitHub user is not accepted past the &quot;Login&quot; process, ie:  Navigate (visit) the route &quot;/login&quot;Type in an unknown GitHub User (ie: &quot;!!!&quot; into the &quot;userName&quot; input element)Hit the &quot;enter&quot; key to submit the formUser remains on the route &quot;/login&quot;.  To test this flow, we can use the following test:  it('rejects a login attempt by an invalid github user: !!!', () =&gt; { cy.visit(&quot;/login&quot;) .get('input[name=&quot;username&quot;]').type(&quot;!!!&quot;).type(&quot;{enter}&quot;) .url().should('include', &quot;/login&quot;); });   Here, we first navigate to the &quot;/login&quot; route before &quot;getting&quot; the &quot;input&quot; element for username. We then instruct the test to type the invalid username and hit enter. Once this is complete we assert that the url does indeed remain at &quot;/login&quot;.  ","version":"Next","tagName":"h3"},{"title":"Test 3 Granting Access to Valid Github Users​","type":1,"pageTitle":"E2E (End to End) Testing","url":"/WebProgrammingForAppsAndServices/Testing-Introduction/e2e-testing#test-3-granting-access-to-valid-github-users","content":" In an effort to further verify the login functionality of our app, we should also write another test that successfully authenticates a known GitHub user. Additionally, once the user has been authenticated, we must ensure that they can access the protected route (/profile-sg), which was denied in our first test. Finally, we should ensure that once they have logged in, they can log out.  Essentially, we must verify the following flow:  Navigate (visit) the route &quot;/login&quot;Type in a known GitHub User (ie: &quot;test-account&quot; into the &quot;userName&quot; input element)Hit the &quot;enter&quot; key to submit the formUser should be directed to /profile-sgClick the &quot;Logout&quot; buttonUser should be directed to /login  This can be accomplished using the following test:  it('successfully authenticates a valid github user: test-account and logs out', () =&gt; { cy.visit(&quot;/login&quot;) .get('input[name=&quot;username&quot;]').type(&quot;test-account&quot;).type(&quot;{enter}&quot;) .url().should('include', '/profile-sg') .get(&quot;nav&quot;).contains(&quot;Logout&quot;).click() .url().should('include', &quot;/login&quot;); });   This is very similar to the previous test, however this time we assert that the url includes &quot;/profile-sg&quot; instead of &quot;/login&quot; after the login attempt. Additionally, we get the &quot;Logout&quot; button within the &quot;nav&quot; element and click it. If the user was directed back to &quot;/login&quot; then we know that this flow is functioning correctly .  info For more examples of how to run tests, including different commands such as working with cookies, files, network requests, the global window object and much more see the official documentation as well as the excellent &quot;Kitchen Sink&quot; example app, provided by Cypress.  ","version":"Next","tagName":"h3"},{"title":"Running in \"Headless\" Mode​","type":1,"pageTitle":"E2E (End to End) Testing","url":"/WebProgrammingForAppsAndServices/Testing-Introduction/e2e-testing#running-in-headless-mode","content":" If you do not wish to run your tests using the GUI tool, it is also possible to run the tests strictly from the command prompt (ie: &quot;Headlessly&quot;). All that is required is that we add the &quot;cypress run&quot; command to &quot;scripts&quot; in package.json, ie:  &quot;cypress:headless&quot;: &quot;cypress run&quot;   To start testing, we can run:  npm run cypress:headless  ","version":"Next","tagName":"h2"},{"title":"Unit Testing","type":0,"sectionRef":"#","url":"/WebProgrammingForAppsAndServices/Testing-Introduction/unit-testing","content":"","keywords":"","version":"Next"},{"title":"Jest Introduction​","type":1,"pageTitle":"Unit Testing","url":"/WebProgrammingForAppsAndServices/Testing-Introduction/unit-testing#jest-introduction","content":" When unit testing our Next.js code we will be using the popular &quot;Jest&quot; testing framework.  Jest is a delightful JavaScript Testing Framework with a focus on simplicity. It works with projects using: Babel, TypeScript, Node, React, Angular, Vue and more!  ","version":"Next","tagName":"h2"},{"title":"Getting Started​","type":1,"pageTitle":"Unit Testing","url":"/WebProgrammingForAppsAndServices/Testing-Introduction/unit-testing#getting-started","content":" Before we begin learning Jest, we should create a new Next.js app using the familiar command:  npx create-next-app@15 my-app --use-npm   Once this is complete, we will install Jest as a &quot;development dependency&quot; using npm, ie:  npm install --save-dev jest jest-environment-jsdom   Before we can begin writing tests however, we must create a jest.config.mjs file in &quot;my-app&quot; to configure the testing environment, ie:  File: &quot;my-app/jest.config.mjs&quot;  import nextJest from 'next/jest.js'; const createJestConfig = nextJest({ // Provide the path to your Next.js app to load next.config.js and .env files in your test environment dir: './', }); // Add any custom config to be passed to Jest /** @type {import('jest').Config} */ const config = { // Add more setup options before each test is run // setupFilesAfterEnv: ['&lt;rootDir&gt;/jest.setup.js'], testEnvironment: 'jest-environment-jsdom', }; // createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is async export default createJestConfig(config);   Finally, we should update the &quot;scripts&quot; section of our package.json file to create a new &quot;test&quot; script that runs Jest using the &quot;--watchAll&quot; flag (to run all tests):  &quot;scripts&quot;: { ... &quot;test&quot;: &quot;jest --watchAll&quot; }   Once the configuration is complete, create a new folder under &quot;my-app&quot; called &quot;tests&quot; (ie: my-app/tests) and add a new file within this folder called &quot;practice.test.js&quot;. This is where we will be practicing writing our first tests using Jest.  ","version":"Next","tagName":"h3"},{"title":"Writing Tests using Jest​","type":1,"pageTitle":"Unit Testing","url":"/WebProgrammingForAppsAndServices/Testing-Introduction/unit-testing#writing-tests-using-jest","content":" Defining tests using Jest typically involves the following functions:    describe(name, fn): Optional - Creates a block that groups several related tests together:  describe('some tests', () =&gt; { // test definitions here });     test(name, fn, timeout) (also under the alias: it(name, fn, timeout)) - This is the function that defines a test, identified by &quot;name&quot;  test('test name', () =&gt; { // test &quot;expectations&quot; here });     expect: This is typically used in the form expect(value) and is used to test the value with matcher functions such as &quot;.toBe()&quot;:  let x = 5; expect(x).toBe(5);     Putting these concepts together, we can write our first test in &quot;practice.test.js&quot; as follows:  let sum = (num1, num2) =&gt; num1 + num2; describe('Practice Tests', () =&gt; { test('sum function adds 1 + 2 to equal 3', () =&gt; { expect(sum(1, 2)).toBe(3); }); });   Here, we have defined a function called &quot;sum&quot; and written a test within our &quot;Practice Tests&quot; group to ensure that it functions correctly. To run this test, open the integrated terminal for your app and execute the command:  npm run test   This should run Jest in &quot;watch&quot; mode and execute your practice.test.js file, showing the following output:   PASS tests/practice.test.js Practice Tests ✓ sum function adds 1 + 2 to equal 3 (2 ms)   To ensure that this is working correctly, try modifying the test so that it fails, ie: expect(sum(1, 2)).toBe(4); and save the file. The test should run again and you will see the output:   FAIL tests/practice.test.js Practice Tests ✕ sum function adds 1 + 2 to equal 3 (3 ms)   ","version":"Next","tagName":"h3"},{"title":"Introduction to \"Matchers\"​","type":1,"pageTitle":"Unit Testing","url":"/WebProgrammingForAppsAndServices/Testing-Introduction/unit-testing#introduction-to-matchers","content":" As stated above, Jest uses matcher functions (&quot;matchers&quot;) to define a complete &quot;expectation&quot; for a value. These were designed to be as human-readable as possible and typically feature names like &quot;toBe&quot;, &quot;toHaveReturned&quot;, &quot;toBeCloseTo&quot;, etc. By using matchers with expect, we can create 1 or more &quot;expectations&quot; for a test. If the test meets all of the expectations, then it passes.  The following is a list of the most common matchers from the official Jest documentation, placed here for reference:  info For the full list, see the expect API doc.  Truthiness​  In tests, you sometimes need to distinguish between undefined, null, and false, but you sometimes do not want to treat these differently. Jest contains helpers that let you be explicit about what you want.  toBeNull matches only nulltoBeUndefined matches only undefinedtoBeDefined is the opposite of toBeUndefinedtoBeTruthy matches anything that an if statement treats as truetoBeFalsy matches anything that an if statement treats as false  For example:  test('null', () =&gt; { const n = null; expect(n).toBeNull(); expect(n).toBeDefined(); expect(n).not.toBeUndefined(); expect(n).not.toBeTruthy(); expect(n).toBeFalsy(); }); test('zero', () =&gt; { const z = 0; expect(z).not.toBeNull(); expect(z).toBeDefined(); expect(z).not.toBeUndefined(); expect(z).not.toBeTruthy(); expect(z).toBeFalsy(); });   You should use the matcher that most precisely corresponds to what you want your code to be doing.  Numbers​  Most ways of comparing numbers have matcher equivalents.  test('two plus two', () =&gt; { const value = 2 + 2; expect(value).toBeGreaterThan(3); expect(value).toBeGreaterThanOrEqual(3.5); expect(value).toBeLessThan(5); expect(value).toBeLessThanOrEqual(4.5); // toBe and toEqual are equivalent for numbers expect(value).toBe(4); expect(value).toEqual(4); });   For floating point equality, use toBeCloseTo instead of toEqual, because you don't want a test to depend on a tiny rounding error.  test('adding floating point numbers', () =&gt; { const value = 0.1 + 0.2; //expect(value).toBe(0.3); This won't work because of rounding error expect(value).toBeCloseTo(0.3); // This works. });   Strings​  You can check strings against regular expressions with toMatch:  test('there is no I in team', () =&gt; { expect('team').not.toMatch(/I/); }); test('but there is a &quot;stop&quot; in Christoph', () =&gt; { expect('Christoph').toMatch(/stop/); });   Arrays and iterables​  You can check if an array or iterable contains a particular item using toContain:  const shoppingList = ['diapers', 'kleenex', 'trash bags', 'paper towels', 'milk']; test('the shopping list has milk on it', () =&gt; { expect(shoppingList).toContain('milk'); expect(new Set(shoppingList)).toContain('milk'); });   Exceptions​  If you want to test whether a particular function throws an error when it's called, use toThrow.  function compileAndroidCode() { throw new Error('you are using the wrong JDK'); } test('compiling android goes as expected', () =&gt; { expect(() =&gt; compileAndroidCode()).toThrow(); expect(() =&gt; compileAndroidCode()).toThrow(Error); // You can also use the exact error message or a regexp expect(() =&gt; compileAndroidCode()).toThrow('you are using the wrong JDK'); expect(() =&gt; compileAndroidCode()).toThrow(/JDK/); });   caution The function that throws an exception needs to be invoked within a wrapping function otherwise the toThrow assertion will fail.  ","version":"Next","tagName":"h3"},{"title":"Testing Components and Pages​","type":1,"pageTitle":"Unit Testing","url":"/WebProgrammingForAppsAndServices/Testing-Introduction/unit-testing#testing-components-and-pages","content":" If we want to use these testing techniques to test more than functions, arrays, strings, etc. within our Next.js app, we will need to install an additional dependency, ie:  @testing-library/react: - A &quot;very light-weight solution for testing React components. It provides light utility functions on top of react-dom and react-dom/test-utils, in a way that encourages better testing practices.&quot;  npm install --save-dev @testing-library/react   This should complete the testing set up - now we can begin writing tests for components and pages. For now, we will start with a simple test that will examine the output of the default &quot;index&quot; page, included when an app is created using &quot;create-next-app&quot;:  ","version":"Next","tagName":"h2"},{"title":"Test 1: \"Vercel\" Link rendered the within the \"main\" element​","type":1,"pageTitle":"Unit Testing","url":"/WebProgrammingForAppsAndServices/Testing-Introduction/unit-testing#test-1-vercel-link-rendered-the-within-the-main-element","content":" For this first test, we must ensure that a link to &quot;https://vercel.com&quot; is rendered within the within the &quot;main&quot; element (section). We know this to be true by visually expecting the output, but how can we test this programmatically?  First, create a new file called: index.test.js in the &quot;tests&quot; folder Add the following dependencies:  import Home from '@/pages/index'; import { render } from '@testing-library/react';   Add the &quot;Home Page&quot; group by using the &quot;describe&quot; function:  describe('Home Page', () =&gt; { // ... });   Finally, add the &quot;test&quot; function to define the test:  test(&quot;renders at least one link to https://vercel.com within the 'main' element&quot;, () =&gt; { const {container} = render(&lt;Home /&gt;); // attempt to fetch the first child &quot;div&quot; element within the &quot;main&quot; element const child = container.querySelector('main div'); // ensure the the child element exists expect(child).toBeTruthy(); // get all &quot;a&quot; elements within the child element const childLinks = child.querySelectorAll(&quot;a&quot;); // ensure there is at least 1 &quot;a&quot; element within the child expect(childLinks.length).toBeGreaterThan(0); // at least one link // count the number of links that include &quot;https://vercel.com&quot; let vercelLinks = 0; childLinks.forEach(link =&gt; { if(link.href.includes(&quot;https://vercel.com&quot;)) vercelLinks++; }); // ensure that there is at least one link that includes &quot;https://vercel.com&quot; expect(vercelLinks).toBeGreaterThan(0); // at least one vercel link });   For this test, we have a number of &quot;expectations&quot; for our test to be true:  Ensure the existence of the first child element of &quot;main&quot;The child element must contain one or more linksOne of the links within the child element must contain the text &quot;https://vercel.com&quot;.  To test that this is indeed the case, we must render the component: &quot;&lt;Home /&gt;&quot; using the &quot;render&quot; function. We store the container property of the result, which is the DOM node containing the rendered component. Using this, we can use familiar DOM functions such as querySelector() to get the child element.  Once we are sure that there is a child element, we use querySelectorAll() to grab all of the &quot;a&quot; elements within it. To determine if there are any links to &quot;https://vercel.com&quot; in that list, we iterate over all of the links and use the &quot;includes&quot; function to check for the substring.  ","version":"Next","tagName":"h3"},{"title":"Test 2: Component with User Event(s)​","type":1,"pageTitle":"Unit Testing","url":"/WebProgrammingForAppsAndServices/Testing-Introduction/unit-testing#test-2-component-with-user-events","content":" For this next test, we will re-create our familiar &quot;ClickCounter&quot; component and write a test to ensure that when the user clicks the button, the counter increases. To begin, let's first create the component:  Create a new &quot;components&quot; folder Inside the &quot;components' folder, create a new file: &quot;ClickCounter.js&quot; Add the following code to define the &quot;&lt;ClickCounter /&gt; &quot; component:  import {useState} from 'react' export default function ClickCounter(){ const [count, setCount] = useState(0); return &lt;button onClick={()=&gt;{setCount(count + 1)}}&gt;Clicked {count} Times&lt;/button&gt; }   (Optional) Place the component somewhere on the &quot;Home&quot; page and confirm that it functions correctly by clicking the button  With the button defined and functioning correctly, we can now proceed to write the corresponding test:  Within the &quot;tests&quot; folder, create a new file: &quot;ClickCounter.test.js&quot; use npm to install &quot;@testing-library/user-event&quot;:  npm install --save-dev @testing-library/user-event   Add the following dependencies:  import ClickCounter from '@/components/ClickCounter'; import userEvent from '@testing-library/user-event'; import { render } from '@testing-library/react';   Add the &quot;ClickCounter Component&quot; group by using the &quot;describe&quot; function:  describe('ClickCounter Component', () =&gt; { // ... });   Add the &quot;test&quot; function to define the test:  test('increase count by 1 when clicked', async () =&gt; { const user = userEvent.setup(); const { container } = render(&lt;ClickCounter /&gt;); // attempt to fetch the &quot;button&quot; element const button = container.querySelector('button'); // ensure there the &quot;button&quot; element exists expect(button).toBeTruthy(); // ensure that the &quot;button&quot; text contains &quot;0&quot; to start expect(button.innerHTML).toContain('0'); // simulate a button click event await user.click(button); // ensure that the &quot;button&quot; context contains &quot;1&quot; after the event expect(button.innerHTML).toContain('1'); });   For this test, we have included another external &quot;companion&quot; library for Testing Library: &quot;user-event&quot;  user-event tries to simulate the real events that would happen in the browser as the user interacts with it. For example userEvent.click(checkbox) would change the state of the checkbox. The more your tests resemble the way your software is used, the more confidence they can give you.  In the code above, we have invoked the &quot;setup()&quot; method before rendering our component, as recommended in the documentation. We then use the familiar querySelector() function to get a reference to the button and ensure that it contains the text &quot;0&quot; before the click event has been triggered.  To trigger the event itself, we use the &quot;click()&quot; method. It's important that we execute this code using &quot;await&quot; as we cannot immediately execute the final &quot;expect&quot; without the event being triggered and the component updated as a result.  ","version":"Next","tagName":"h3"},{"title":"Test 3: API Route with Route Parameter​","type":1,"pageTitle":"Unit Testing","url":"/WebProgrammingForAppsAndServices/Testing-Introduction/unit-testing#test-3-api-route-with-route-parameter","content":" For our final test, we will implement an API route for a subset of our familiar &quot;vehicles&quot; static dataset from our &quot;simple-API&quot; example:  Within the &quot;pages/api&quot; folder, create a new folder: vehicles Within the newly created &quot;pages/api/vehicles&quot; folder, create a new file: [id].js Enter the following code to define our dynamic &quot;vehicles&quot; api route:  let vehicleData = [ { id: 1, year: 1994, make: 'Suzuki', model: 'SJ', vin: 'JN8AZ2KR6CT544012', }, { id: 2, year: 1999, make: 'Chrysler', model: '300', vin: '1B3CC5FB5AN648885', }, { id: 3, year: 2005, make: 'BMW', model: 'X3', vin: 'JTHBP5C29E5152916', }, ]; export default function handler(req, res) { const { method } = req; const { id } = req.query; switch (method) { case 'GET': let vehicleIndex = vehicleData.findIndex((v) =&gt; v.id == id); // if a vehicleIndex was found, return the corresponding vehicle, else send a 404 error vehicleIndex != -1 ? res.status(200).json(vehicleData[vehicleIndex]) : res.status(404).end(); break; default: // send an error message back, indicating that the method is not supported by this route res.setHeader('Allow', ['GET']); res.status(405).end(`Method ${method} Not Allowed`); } }   The structure of the above should look somewhat familiar, as it was discussed when we first introduced API routes (please have a quick review if required). Basically, all we are doing here is allowing for a simple &quot;GET&quot; request with a single route parameter &quot;id&quot;, ie: &quot;api/vehicles/3&quot; should return:  { &quot;id&quot;: 3, &quot;year&quot;: 2005, &quot;make&quot;: &quot;BMW&quot;, &quot;model&quot;: &quot;X3&quot;, &quot;vin&quot;: &quot;JTHBP5C29E5152916&quot; }   This route also sends a 404 status code if the requested &quot;id&quot; is not found, ie: &quot;api/vehicles/4&quot; should return an empty body with the status: 404.  To test this functionality, we will be using another 3rd party module to help make the request from within our test: &quot;node-mocks-http&quot;. Once you have installed it using npm:  npm install --save-dev node-mocks-http   You can commence writing the test:  First, create a new file called: vehicles.test.js in the &quot;tests&quot; folder Add the following dependencies:  import { createMocks } from 'node-mocks-http'; import handler from '@/pages/api/vehicles/[id]';   Add the &quot;/api/vehicles/[id] Route&quot; group by using the &quot;describe&quot; function:  describe('/api/vehicles/[id] Route', () =&gt; { // ... });   Add the first (of two) &quot;test&quot; functions to define the test for a known vehicle:  test('returns a vehicle for a specified ID', async () =&gt; { const { req, res } = createMocks({ method: 'GET', query: { id: '1', }, }); await handler(req, res); expect(res._getStatusCode()).toBe(200); expect(JSON.parse(res._getData())).toEqual( expect.objectContaining({ id: 1, }) ); });   Add the second (of two) &quot;test&quot; functions to define the test for an unknown vehicle:  test('returns 404 when vehicle id not found', async () =&gt; { const { req, res } = createMocks({ method: 'GET', query: { id: 'abc', }, }); await handler(req, res); expect(res._getStatusCode()).toBe(404); });   If we examine the first test (&quot;returns a vehicle for a specified ID&quot;), we can see that we use &quot;createMocks&quot; to create a mock &quot;GET&quot; request / response with the &quot;id&quot; route parameter value: 1. We then provide the mocked req and res objects to the asynchronous API &quot;handler&quot; function. After this has completed, we can use the _getStatusCode() function to pull the resultant status code from the response and examine it in our test:  expect(res._getStatusCode()).toBe(200);   Similarly, we use the _getData() function to get the returned data from the response. However, rather than testing every value in the returned object, we only make sure that the id value matches route parameter (in this case, 1):  expect(JSON.parse(res._getData())).toEqual( expect.objectContaining({ id: 1, }) );   To achieve this, we use the expect.objectContaining(object) function with the &quot;toEqual()&quot; matcher.  The second test (&quot;returns 404 when vehicle id not found&quot;) functions in almost exactly the same way as the first test, however instead of passing the route parameter: 1, we pass abc. We also only test for the status code &quot;404&quot; as no object is returned. ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}