"use strict";(self.webpackChunkipc144=self.webpackChunkipc144||[]).push([[3418],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>h});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),m=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},u=function(e){var t=m(e.components);return n.createElement(l.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=m(r),d=a,h=p["".concat(l,".").concat(d)]||p[d]||c[d]||i;return r?n.createElement(h,o(o({ref:t},u),{},{components:r})):n.createElement(h,o({ref:t},u))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:a,o[1]=s;for(var m=2;m<i;m++)o[m]=r[m];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},8854:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>m});var n=r(7462),a=(r(7294),r(3905));r(8209);const i={id:"validation",title:"Validation",sidebar_position:2,description:"Validation"},o="Form Validation",s={unversionedId:"Forms-Introduction/validation",id:"Forms-Introduction/validation",title:"Validation",description:"Validation",source:"@site/docs/Forms-Introduction/validation.md",sourceDirName:"Forms-Introduction",slug:"/Forms-Introduction/validation",permalink:"/Forms-Introduction/validation",draft:!1,editUrl:"hhttps://github.com/patrick-crawford/WebProgrammingForAppsAndServices/tree/master/docs/Forms-Introduction/validation.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"validation",title:"Validation",sidebar_position:2,description:"Validation"},sidebar:"courseNotesSidebar",previous:{title:"React Forms",permalink:"/Forms-Introduction/react-forms"},next:{title:"Example Code",permalink:"/Forms-Introduction/example-code"}},l={},m=[{value:"Adding Validation Rules to &quot;register&quot;",id:"adding-validation-rules-to-register",level:2},{value:"Custom Validation Rules",id:"custom-validation-rules",level:3},{value:"Showing Errors",id:"showing-errors",level:2},{value:"Highlighting Fields",id:"highlighting-fields",level:3},{value:"Disabling the &quot;submit&quot; Button",id:"disabling-the-submit-button",level:3}],u={toc:m},p="wrapper";function c(e){let{components:t,...r}=e;return(0,a.kt)(p,(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"form-validation"},"Form Validation"),(0,a.kt)("p",null,"React Hook Form makes simple form validation very straightforward by aligning with ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation"},'"browser native validation"')," attributes. As such, the following basic validation rules are provided:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"required:")," Indicates that the input must have a value before the form can be submitted."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"min:")," The minimum value to accept for this input (number)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"max:")," The maximum value to accept for the input (number)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"minLength:")," The minimum length of the value to accept for the input"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"maxLength:")," The maximum length of the value to accept for the input"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"pattern:")," The regex pattern for the input.")),(0,a.kt)("h2",{id:"adding-validation-rules-to-register"},'Adding Validation Rules to "register"'),(0,a.kt)("p",null,'In addition to "registering" our form controls, the ',(0,a.kt)("a",{parentName:"p",href:"https://react-hook-form.com/api/useform/register"},'"register"'),' function also accepts a second "options" parameter to configure how the control behaves, including setting validation rules.'),(0,a.kt)("p",null,"For example, we will start with the following simple form:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},'import { useForm } from \'react-hook-form\';\nimport { useEffect } from \'react\';\n\nexport default function FormWithValidation() {\n\n  const { register, handleSubmit, setValue } = useForm({\n    defaultValues: {\n      firstName: "",\n      lastName: "",\n      age: 0\n    }\n  });\n\n  useEffect(() => {\n    let data = {\n      firstName: "Homer",\n      lastName: "Simpson",\n      age: 42\n    }\n\n    // set the values of each form field to match "data"\n    for (const prop in data) {\n      setValue(prop, data[prop]);\n    }\n  }, []);\n\n  function submitForm(data) {\n    console.log(data);\n  }\n\n  return (\n    <form onSubmit={handleSubmit(submitForm)}>\n      First Name: <br />\n      <input {...register("firstName")} /><br /><br />\n\n      Last Name: <br />\n      <input {...register("lastName")} /><br /><br />\n\n      Age: <br />\n      <input type="number" {...register("age")} /><br /><br />\n\n      <button type="submit">Update User</button>\n    </form>\n  );\n}\n')),(0,a.kt)("p",null,'Here, we ask the user to modify their first name, last name and age, starting from initial values obtained in the "useEffect" hook. At the moment, there are no restrictions on what the user may enter, apart from the restriction built in to the input type ',(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/number"},'"number"'),"."),(0,a.kt)("p",null,"If we wish to add specific validation rules for each form field individually, we can specify each validation rule as a ",(0,a.kt)("em",{parentName:"p"},"property")," of the ",(0,a.kt)("em",{parentName:"p"},"RegisterOptions")," parameter of the ",(0,a.kt)("a",{parentName:"p",href:"https://react-hook-form.com/api/useform/register"},'"register"'),' method. For example, we can modify the 3 form fields above to use specific validation rules such as "required", "maxLength", "pattern", "min", "max", etc.'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},'<form onSubmit={handleSubmit(submitForm)}>\n      First Name: <br />\n      <input {...register("firstName", { required: true, maxLength: 20 })} /><br /><br />\n\n      Last Name: <br />\n      <input {...register("lastName", { pattern: /^[A-Za-z]+$/i })} /><br /><br />\n\n      Age: <br />\n      <input type="number" {...register("age", { min: 18, max: 99 })} /><br /><br />\n\n      <button type="submit">Update User</button>\n    </form>\n')),(0,a.kt)("p",null,"AFter this change has been made, the form should still appear the same, however if we try to break one of the validation rules (ie: removing the first name value) before submitting the form, we will notice that:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"The (first) form field that is in violation of a validation rule is focused"),(0,a.kt)("li",{parentName:"ol"},'The "submitForm" function does not run')),(0,a.kt)("h3",{id:"custom-validation-rules"},"Custom Validation Rules"),(0,a.kt)("p",null,'In addition to the above "native validation", React Hook Form also allows us to create our own validation rules by specifying one or more callback functions as properties within a "validate" parameter to ',(0,a.kt)("em",{parentName:"p"},"RegisterOptions"),'. As a simple example, say we wish to ensure that we are only accepting "Age" values that are even, in the above form. We can add the following ',(0,a.kt)("strong",{parentName:"p"},"custom"),' "onlyEven" validation rule to our "nunber" field:'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},'<input type="number" {...register("age", { min: 18, max: 99, validate: { onlyEven: v => v % 2 == 0 } })} /><br /><br />\n')),(0,a.kt)("h2",{id:"showing-errors"},"Showing Errors"),(0,a.kt)("p",null,"While restricting the form submission and automatically focusing the problematic field is an effective way to perform client side validation, we are missing an important piece: showing a ",(0,a.kt)("em",{parentName:"p"},"description")," of the error to the user, so that they can correct the mistake."),(0,a.kt)("p",null,'In order to actually show the errors, we must first add the "errors" object from ',(0,a.kt)("a",{parentName:"p",href:"https://react-hook-form.com/api/useform/formstate"},'"formState"'),", to give us access to any errors in the form:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"const { register, handleSubmit, setValue, formState: { errors } } = useForm({...});\n")),(0,a.kt)("p",null,'This will give us access to the "errors" object, which will contain each form field that contains an error, as a property. Additionally, each specific validation error will also be identified for each form field using a "type" property. If there are no invalid fields, this object will be empty, ie "{}".'),(0,a.kt)("p",null,'Using this, we can easily inspect a specific form control to see if it contains any errors and if so, which rules have been violated. For example, if we wish to show errors for the "firstName" field, we could use the following code:'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},'<input {...register("firstName", { required: true, maxLength: 20 })} />\n{errors.firstName?.type === "required" && <span><br />First Name is required</span>}\n{errors.firstName?.type === "maxLength" && <span><br />First Name Cannot contain more than 20 characters</span>}\n<br /><br />\n')),(0,a.kt)("p",null,"Notice how we use the ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining"},'"optional chaining operator"'),' before checking the "type" of the error message. This ensures that we do not receive the following error if the form field is currently valid (ie: no errors):'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"TypeError: Cannot read properties of undefined (reading 'type')\n")),(0,a.kt)("p",null,"Also, if you try running the example again, you should see that the error messages show up only after the form is first submitted. After this first submit, the errors are shown / hidden as the user modifies the form. This lets the user know immediately if they have corrected the error."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"NOTE"),': In addition to the "errors" object, you can include additional objects such as ',(0,a.kt)("em",{parentName:"p"},'"dirtyFields"')," and ",(0,a.kt)("em",{parentName:"p"},'"touchedFields"')," to monitor which fields have been modified and visited.")),(0,a.kt)("h3",{id:"highlighting-fields"},"Highlighting Fields"),(0,a.kt)("p",null,'Given that the "errors" object contains property names of all form fields that are currently in violation of a validation rule, it is a simple task to conditionally add a CSS class to a form field that is in error. For example, if we had the class "inputError", we could conditionally add it to the field using the code:'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},'className={errors.firstName && "inputError"}\n')),(0,a.kt)("p",null,'Here, we check if the "errors" object contains a ',(0,a.kt)("em",{parentName:"p"},"firstName"),' property, and if it does, add the "inputError" class.'),(0,a.kt)("h3",{id:"disabling-the-submit-button"},'Disabling the "submit" Button'),(0,a.kt)("p",null,'Another interesting UI improvement that can be made using "errors" is conditionally disabling the "submit" button if the form is "in error" (has one or more fields with validation errors). This can be done by counting how many properties exist on the "errors" object using "',(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys"},'Object.keys()"'),", since only form fields that are in error should have a corresponding property within the errors object, ie:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},'<button type="submit" disabled={Object.keys(errors).length > 0}>Update User</button>\n')))}c.isMDXComponent=!0},8209:(e,t,r)=>{r(7294)}}]);