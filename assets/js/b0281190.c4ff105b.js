"use strict";(self.webpackChunkOERTemplate=self.webpackChunkOERTemplate||[]).push([[5378],{3102:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"Managing-Application-State/introducing-jotai","title":"Introducing Jotai","description":"Introducing Jotai","source":"@site/docs/Managing-Application-State/introducing-jotai.md","sourceDirName":"Managing-Application-State","slug":"/Managing-Application-State/introducing-jotai","permalink":"/WebProgrammingForAppsAndServices/Managing-Application-State/introducing-jotai","draft":false,"unlisted":false,"editUrl":"https://github.com/catherine-leung/OERTemplate/tree/main/docs/Managing-Application-State/introducing-jotai.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"introducing-jotai","title":"Introducing Jotai","sidebar_position":2,"description":"Introducing Jotai"},"sidebar":"courseNotesSidebar","previous":{"title":"Shared State with Props and Context","permalink":"/WebProgrammingForAppsAndServices/Managing-Application-State/shared-state-props-context"},"next":{"title":"Implementation: Shopping Cart","permalink":"/WebProgrammingForAppsAndServices/Managing-Application-State/implementation-shopping-cart"}}');var i=n(4848),s=n(8453);const a={id:"introducing-jotai",title:"Introducing Jotai",sidebar_position:2,description:"Introducing Jotai"},r="Introducing Jotai",c={},l=[{value:"Getting Started",id:"getting-started",level:2},{value:"Defining Application Level State",id:"defining-application-level-state",level:2},{value:"Async Default Values",id:"async-default-values",level:3},{value:"Reading / Writing State",id:"reading--writing-state",level:2},{value:"&quot;Component Tree&quot; Example",id:"component-tree-example",level:2}];function d(e){const t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"introducing-jotai",children:"Introducing Jotai"})}),"\n",(0,i.jsx)(t.p,{children:'As we have seen, there are a number of popular 3rd party state management solutions for React. However, for our purposes we will be going with the relatively new "Jotai", for its simplicity, efficiency and support for Next.js. It also makes use of Typescript, which is excellent, but not currently necessary for our implementations going forward.'}),"\n",(0,i.jsxs)(t.p,{children:["From the ",(0,i.jsx)(t.a,{href:"https://jotai.org/docs/basics/concepts",children:"Jotai Documentation"}),":"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"Jotai was born to solve extra re-render issues in React. An extra re-render is when the render process produces the same UI result, where users won't see any differences."}),"\n",(0,i.jsx)(t.p,{children:"To tackle this issue with React context (useContext + useState), one would require many contexts and face some issues."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Provider hell: It's likely that your root component has many context providers, which is technically okay, and sometimes desirable to provide context in different subtree."}),"\n",(0,i.jsxs)(t.li,{children:["Dynamic addition/deletion: Adding a new context at runtime is not very nice, because you need to add a new provider and its children will be re-mounted.\nTraditionally, a top-down solution to this is to use a selector interface. The ",(0,i.jsx)(t.a,{href:"https://github.com/dai-shi/use-context-selector",children:"use-context-selector"})," library is one example. The issue with this approach is the selector function needs to return referentially equal values to prevent re-renders, and this often requires a memoization technique."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Jotai takes a bottom-up approach with the atomic model, inspired by ",(0,i.jsx)(t.a,{href:"https://recoiljs.org/",children:"Recoil"}),". One can build state combining atoms, and optimize renders based on atom dependency. This avoids the need for memoization."]}),"\n",(0,i.jsx)(t.p,{children:"Jotai has two principles."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Primitive: Its basic interface is simple, like useState."}),"\n",(0,i.jsx)(t.li,{children:"Flexible: Derived atoms can combine other atoms and enable useReducer style with side effects.\nJotai's core API is minimalistic and makes it easy to build utilities based upon it."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["As you can see from the main concepts outlined above, Jotai was inspired by ",(0,i.jsx)(t.a,{href:"https://recoiljs.org/",children:"Recoil"}),' (an experimental library created by Dave McCabe, a Software Engineer at Facebook) and was designed to solve some of the problems such as "provider hell" and unnecessary re-renders that we discussed when reviewing "Prop Drilling" and "Context" in the previous section. This makes it a perfect alternative for us to use.']}),"\n",(0,i.jsx)(t.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,i.jsx)(t.p,{children:"To begin working with Jotai, all we need to do is install it using npm, ie:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"npm i jotai\n"})}),"\n",(0,i.jsx)(t.h2,{id:"defining-application-level-state",children:"Defining Application Level State"}),"\n",(0,i.jsxs)(t.p,{children:['In Jotai, state values are defined as "atoms", essentially units of state that are both updatable and subscribable. When an atom is updated, any subscribed component will be re-rendered with the new value. This makes working with atoms very familiar, as the syntax and behaviour very closely resembles working with local state in components using the ',(0,i.jsx)(t.a,{href:"https://react.dev/reference/react/useState",children:'"useState"'})," hook."]}),"\n",(0,i.jsx)(t.p,{children:'To define atoms in Next.js, we will place them in a separate file, ie: "store.js". Since each atom represents a different unit of state, we can define as many as we wish in this file, ie:'}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"File:"}),' "my-app/store.js"']}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-jsx",children:"import { atom } from 'jotai';\n\nexport const countAtom = atom(0);\nexport const countryAtom = atom('Japan');\nexport const citiesAtom = atom(['Tokyo', 'Kyoto', 'Osaka']);\nexport const mangaAtom = atom({ 'Dragon Ball': 1984, 'One Piece': 1997, 'Naruto': 1999 });\n"})}),"\n",(0,i.jsx)(t.p,{children:'Here, we have defined 4 atoms with varying default values from numbers, strings, arrays and objects. Each of these atoms can be directly referenced from any component in the tree and may be used just like "useState" (see below).'}),"\n",(0,i.jsx)(t.h3,{id:"async-default-values",children:"Async Default Values"}),"\n",(0,i.jsxs)(t.p,{children:["There may be situations where you cannot hard-code default values into your atoms and instead must fetch them from an API, file, etc. To accommodate this, Jotai allows atoms to be defined using an ",(0,i.jsx)(t.a,{href:"https://jotai.org/docs/guides/async",children:'"async function"'}),", ie:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"export const postAtom = atom((async () => {\n  const res = await fetch('https://jsonplaceholder.typicode.com/posts/1');\n  const data = await res.json();\n\n  return data;\n})());\n"})}),"\n",(0,i.jsx)(t.h2,{id:"reading--writing-state",children:"Reading / Writing State"}),"\n",(0,i.jsxs)(t.p,{children:['To use any of the atoms defined in our "store.js" file, we must import both the ',(0,i.jsx)(t.a,{href:"https://jotai.org/docs/basics/primitives#use-atom",children:'"useAtom"'}),' function (from \'jotai\') as well as the specific atom that we wish to read from / write to. For example, if we wish to reference the "countryAtom" (defined above with a default value of "Japan"), we can use the following code:']}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-jsx",children:"import { useAtom } from 'jotai';\nimport { countryAtom } from '@/store';\n\nexport default function Country() {\n  const [country, setCountry] = useAtom(countryAtom);\n\n  return <>Country: {country}</>\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Notice how ",(0,i.jsx)(t.a,{href:"https://jotai.org/docs/basics/primitives#use-atom",children:'"useAtom"'})," functions in a very similar way to ",(0,i.jsx)(t.a,{href:"https://react.dev/reference/react/useState",children:'"useState"'}),'. We can access the state directly from the atom and when it\'s updated (using "setCountry", in this case) any other components rendering the value from the countryAtom will also get updated.']}),"\n",(0,i.jsx)(t.h2,{id:"component-tree-example",children:'"Component Tree" Example'}),"\n",(0,i.jsx)(t.p,{children:'Now that we understand how state management works in Jotai, let\'s update our "Component Tree" example from the previous section to use it.'}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.p,{children:["We do ",(0,i.jsx)(t.em,{children:"not"}),' need to modify the file "/pages/_app.js" as in previous examples. Instead we will create a new file: "store.js".']})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"File:"}),' "my-app/store.js"']}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-jsx",children:"import { atom } from 'jotai';\n\nexport const countAtom = atom(0);\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"File:"}),' "/components/Component3.js"']}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-jsx",children:"import { useAtom } from 'jotai';\nimport { countAtom } from '@/store';\n\nexport default function Component3() {\n  const [count, setCount] = useAtom(countAtom);\n  return <>Value: {count}</>\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"File:"}),' "/components/ComponentC.js"']}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-jsx",children:"import { useAtom } from 'jotai';\nimport { countAtom } from '@/store';\n\nexport default function ComponentC() {\n  const [count, setCount] = useAtom(countAtom);\n  return <button onClick={(e) => setCount(count + 1)}>Increase Value</button>\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"As you can see, we only had to create / modify 3 files:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"store.js"}),": Defines our atoms (global state with optional default values)"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"component3.js"}),": The component using the atom to display its value"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"componentC.js"}),": The component using the atom to modify its value"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:'This is much cleaner than our previous approaches, with the added bonus of having the syntax feel very familiar. Additionally, our application / site no longer suffers from the performance hit caused by re-rendering all of the components in the tree; only "Component3" and "ComponentC" are re-rendered when the state changes.'}),"\n",(0,i.jsxs)(t.p,{children:["For more information including handling special cases, etc. please reference the ",(0,i.jsx)(t.a,{href:"https://jotai.org/",children:'"official Jotai documentation"'}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var o=n(6540);const i={},s=o.createContext(i);function a(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);