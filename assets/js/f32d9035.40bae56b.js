"use strict";(self.webpackChunkOERTemplate=self.webpackChunkOERTemplate||[]).push([[5419],{2726:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"API-Routes-Middleware/middleware","title":"Middeware","description":"Middleware","source":"@site/docs/API-Routes-Middleware/middleware.md","sourceDirName":"API-Routes-Middleware","slug":"/API-Routes-Middleware/middleware","permalink":"/WebProgrammingForAppsAndServices/API-Routes-Middleware/middleware","draft":false,"unlisted":false,"editUrl":"https://github.com/catherine-leung/OERTemplate/tree/main/docs/API-Routes-Middleware/middleware.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"middleware","title":"Middeware","sidebar_position":2,"description":"Middleware"},"sidebar":"courseNotesSidebar","previous":{"title":"API Routes Introduction","permalink":"/WebProgrammingForAppsAndServices/API-Routes-Middleware/api-routes-intro"},"next":{"title":"Example Code","permalink":"/WebProgrammingForAppsAndServices/API-Routes-Middleware/example-code"}}');var i=s(4848),r=s(8453);const a={id:"middleware",title:"Middeware",sidebar_position:2,description:"Middleware"},o="Middleware",l={},c=[{value:"Getting Started",id:"getting-started",level:2},{value:"Matching Paths",id:"matching-paths",level:2},{value:"Multiple Paths",id:"multiple-paths",level:3},{value:"Nested Paths (Wildcard)",id:"nested-paths-wildcard",level:3},{value:"Conditionally",id:"conditionally",level:3},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Using Cookies",id:"using-cookies",level:3},{value:"URL Rewrites",id:"url-rewrites",level:3}];function d(e){const t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"middleware",children:"Middleware"})}),"\n",(0,i.jsxs)(t.p,{children:["If you are familiar with the popular ",(0,i.jsx)(t.a,{href:"https://expressjs.com/",children:'"Express.js"'}),' web framework for Node.js, you will be familiar with the concept of "Middleware"']}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"Middleware functions are functions that have access to the request object (req), the response object (res), and the next() function in the application\u2019s request-response cycle. The next() function is a function in the Express router which, when invoked, executes the middleware succeeding the current middleware."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"http://expressjs.com/en/guide/writing-middleware.html",children:"http://expressjs.com/en/guide/writing-middleware.html"}),"."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Essentially, middleware allows us to execute functions in the \u2018middle\u2019 of a request/response cycle typically before a matching route (api / page) handler function is executed."}),"\n",(0,i.jsx)(t.p,{children:"Next.js has a similar concept:"}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"[In Next.js] middleware allows you to run code on the server before a request is completed. Then, based on the incoming request, you can modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly."}),"\n",(0,i.jsx)(t.p,{children:"Middleware executes before routes are rendered. It's particularly useful for implementing custom server-side logic like authentication, logging, or handling redirects."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://nextjs.org/docs/pages/api-reference/file-conventions/middleware",children:"https://nextjs.org/docs/pages/api-reference/file-conventions/middleware"})}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Here, we have a function that is automatically executed as part of the request / response cycle in Next.js. It can be configured to apply logic to a specific route, or conditionally with multiple routes."}),"\n",(0,i.jsx)(t.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,i.jsxs)(t.p,{children:["To see how middleware in Next.js is implemented, create a ",(0,i.jsx)(t.strong,{children:'"middleware.js"'}),' file within the root of your application folder (ie: "my-app/middleware.js"):']}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"File:"})," /middleware.js"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"export function middleware(request) {\n  console.log('requested: ', request.url);\n}\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.p,{children:["If the middleware does not modify the response (discussed further down), you do not need to explicitly return or invoke a ",(0,i.jsx)(t.code,{children:".next()"})," method. Next.js will automatically continue processing the request."]})}),"\n",(0,i.jsxs)(t.p,{children:['If you test the server now and navigate to the default route "/", you will see that the middleware function has been executed once for every resource sent from our local server (',(0,i.jsx)(t.code,{children:"http://localhost:3000"}),') for the "/" page:']}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"requested:  http://localhost:3000/vercel.svg\nrequested:  http://localhost:3000/next.svg\nrequested:  http://localhost:3000/_next/static/media/2aaf0723e720e8b9-s.p.woff2\nrequested:  http://localhost:3000/_next/static/chunks/react-refresh.js?ts=1693361554048\nrequested:  http://localhost:3000/_next/static/chunks/main.js?ts=1693361554048\nrequested:  http://localhost:3000/_next/static/chunks/webpack.js?ts=1693361554048\nrequested:  http://localhost:3000/_next/static/chunks/pages/_app.js?ts=1693361554048\nrequested:  http://localhost:3000/_next/static/development/_buildManifest.js?ts=1693361554048\nrequested:  http://localhost:3000/_next/static/chunks/pages/index.js?ts=1693361554048\nrequested:  http://localhost:3000/_next/static/development/_ssgManifest.js?ts=1693361554048\nrequested:  http://localhost:3000/_next/static/development/_devMiddlewareManifest.json\nrequested:  http://localhost:3000/_next/static/development/_devPagesManifest.json\nrequested:  http://localhost:3000/favicon.ico\nrequested:  http://localhost:3000/vercel.svg\nrequested:  http://localhost:3000/next.svg\n"})}),"\n",(0,i.jsxs)(t.p,{children:['We are able to access the "url" property on the "request" object, because request is technically an instance of ',(0,i.jsx)(t.a,{href:"https://nextjs.org/docs/pages/api-reference/functions/next-request",children:'"NextRequest"'}),", which itself, is an extension of the native ",(0,i.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Request",children:'"Request"'})," object."]}),"\n",(0,i.jsx)(t.h2,{id:"matching-paths",children:"Matching Paths"}),"\n",(0,i.jsx)(t.p,{children:'Now that we know that the "middleware" function is behaving correctly (ie: invoked as a part of the request / response cycle - before the request is completed), we should consider only applying it to certain paths, such as pages or api routes. To achieve this, we must update our "middleware.js" file to also export a "config" object with a "matcher" property:'}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"export const config = {\n  matcher: '/',\n};\n"})}),"\n",(0,i.jsxs)(t.p,{children:['In the above case, having a matcher value of "/" will restrict the middleware function to ',(0,i.jsx)(t.em,{children:"only"}),' run on the "/" route. If we open the console with the current configuration, we will only see:']}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"requested:  http://localhost:3000/\n"})}),"\n",(0,i.jsx)(t.h3,{id:"multiple-paths",children:"Multiple Paths"}),"\n",(0,i.jsxs)(t.p,{children:['Say we have a second route: "/about" that we would also like to match. This can be done by passing an ',(0,i.jsx)(t.strong,{children:"array of matchers"}),' to the "matcher" property:']}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"export const config = {\n  matcher: ['/', '/about'],\n};\n"})}),"\n",(0,i.jsx)(t.h3,{id:"nested-paths-wildcard",children:"Nested Paths (Wildcard)"}),"\n",(0,i.jsxs)(t.p,{children:['There are many cases where we have nested paths, such as "/api/users". In addition to matching "/api/users", we may want to match all "/api/users" routes, such as "/api/users/123". This can be done using the ',(0,i.jsx)(t.code,{children:":path*"}),' (which will also match routes such as "/api/users/a/b/c"):']}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"export const config = {\n  matcher: ['/api/users/:path*'],\n};\n"})}),"\n",(0,i.jsxs)(t.admonition,{type:"info",children:[(0,i.jsxs)(t.p,{children:["The matcher config allows full regex so matching like negative lookaheads or character matching is supported. For example: ",(0,i.jsx)(t.code,{children:"'/((?!api|_next/static|_next/image|favicon.ico).*)'"})," will match all request paths except for the ones starting with:"]}),(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"api (API routes)"}),"\n",(0,i.jsx)(t.li,{children:"_next/static (static files)"}),"\n",(0,i.jsx)(t.li,{children:"_next/image (image optimization files)"}),"\n",(0,i.jsx)(t.li,{children:"favicon.ico (favicon file)"}),"\n"]}),(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://nextjs.org/docs/pages/api-reference/file-conventions/middleware#matcher",children:'Next.js Docs - "matcher"'})})]}),"\n",(0,i.jsx)(t.h3,{id:"conditionally",children:"Conditionally"}),"\n",(0,i.jsxs)(t.p,{children:['Finally, we may wish to perform different actions depending on which path is matched. In this case, we do not include the "matcher" config, and instead rely on the "request" parameter. Recall: this is an instance of ',(0,i.jsx)(t.a,{href:"https://nextjs.org/docs/pages/api-reference/functions/next-request",children:'"NextRequest"'}),', which gives us access to the "nextUrl" property, which itself includes "an extended, parsed, URL object that gives you access to Next.js specific properties such as pathname, basePath, trailingSlash and i18n". This appears to be exactly what we need (i.e. manually examine the ',(0,i.jsx)(t.em,{children:"pathname"})," and respond with the intended logic):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"export function middleware(request) {\n  if (request.nextUrl.pathname.startsWith('/about')) {\n    console.log('Visiting About');\n  }\n\n  if (request.nextUrl.pathname.startsWith('/api/users')) {\n    console.log('Visiting the Users API');\n  }\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,i.jsx)(t.p,{children:"Now that we are able to add middleware functionality to a certain route / set of routes, let's see what kind of practical benefits this provides."}),"\n",(0,i.jsxs)(t.admonition,{type:"info",children:[(0,i.jsxs)(t.p,{children:["When using middleware, we have access to a ",(0,i.jsx)(t.a,{href:"https://nextjs.org/docs/pages/building-your-application/routing/middleware#nextresponse",children:'"NextResponse"'}),' object from "next/server" (ie: ',(0,i.jsx)(t.code,{children:"import { NextResponse } from 'next/server';"}),"). Using this object, we can perform some useful actions from our middleware, such as:"]}),(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"redirect the incoming request to a different URL"}),"\n",(0,i.jsx)(t.li,{children:"rewrite the response by displaying a given URL"}),"\n",(0,i.jsx)(t.li,{children:"Set request headers for API Routes, getServerSideProps, and rewrite destinations"}),"\n",(0,i.jsx)(t.li,{children:"Set response cookies"}),"\n",(0,i.jsx)(t.li,{children:"Set response headers"}),"\n"]})]}),"\n",(0,i.jsx)(t.h3,{id:"using-cookies",children:"Using Cookies"}),"\n",(0,i.jsxs)(t.p,{children:['As we know, a "cookie" is a small chunk of data that is sent by a server and stored in the client\'s web browser using the header ',(0,i.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie",children:'"Set-Cookie"'}),". Similarly, the data is automatically sent from the client back to the server, using the ",(0,i.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cookie",children:'"Cookie"'}),' header, often used to manage session information. In Next.js we can implement this functionality in our middleware functions by using the "cookies" property on both the request ("NextRequest") and response ("NextResponse") objects.']}),"\n",(0,i.jsxs)(t.p,{children:['In the below example, we have two routes: "/setCookie" (which is expecting a query parameter: "message") and "/getCookie". When the middleware matches the "/setCookie" route, it reads the query parameter "message" and adds it to the "Set-Cookie" response header. If the middleware matches the "/getCookie" route, it simply outputs the "message" cookie value to the console. It uses the ',(0,i.jsx)(t.a,{href:"https://nextjs.org/docs/app/api-reference/functions/next-response#next",children:'"next()"'})," function to continue routing:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"import { NextResponse } from 'next/server';\n\nexport function middleware(request) {\n  const response = NextResponse.next();\n\n  if (request.nextUrl.pathname.startsWith('/setCookie')) {\n    let cookieMessage = request.nextUrl.searchParams.get('message');\n    response.cookies.set('message', cookieMessage);\n  }\n\n  if (request.nextUrl.pathname.startsWith('/getCookie')) {\n    let cookie = request.cookies.get('message');\n    console.log(cookie);\n  }\n\n  return response;\n}\n"})}),"\n",(0,i.jsxs)(t.admonition,{type:"info",children:[(0,i.jsxs)(t.p,{children:["We can also manually set headers using ",(0,i.jsx)(t.code,{children:"response.headers.set()"}),", ie:"]}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"response.headers.set('x-hello-from-middleware', 'hello');\n"})})]}),"\n",(0,i.jsx)(t.h3,{id:"url-rewrites",children:"URL Rewrites"}),"\n",(0,i.jsxs)(t.p,{children:["It may also be beneficial to map a specific path in Next.js to a different one, either temporarily (ie: during testing or development of a new bug fix / feature) or permanently depending on a condition such as the users language preference. This is possible using URL ",(0,i.jsx)(t.a,{href:"https://nextjs.org/docs/pages/api-reference/next-config-js/rewrites",children:'"rewrites"'}),":"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"Rewrites allow you to map an incoming request path to a different destination path."}),"\n",(0,i.jsx)(t.p,{children:"Rewrites act as a URL proxy and mask the destination path, making it appear the user hasn't changed their location on the site. In contrast, redirects will reroute to a new page and show the URL changes."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:'For example, the following code will check the "Accept-Language" header value for the existence of "fr". If it is found, the url will be "rewritten" to the "/fr/about" route. To the user, they will still be at "/about", but the page rendered will be from "/fr/about"'}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"import { NextResponse } from 'next/server';\n\nexport function middleware(request) {\n  const language = request.headers.get('Accept-Language');\n\n  if (language.includes('fr')) {\n    return NextResponse.rewrite(new URL('/fr/about', request.url));\n  }\n}\n\nexport const config = {\n  matcher: ['/about'],\n};\n"})})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>o});var n=s(6540);const i={},r=n.createContext(i);function a(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);