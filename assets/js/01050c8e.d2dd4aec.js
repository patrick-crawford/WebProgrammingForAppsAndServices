"use strict";(self.webpackChunkOERTemplate=self.webpackChunkOERTemplate||[]).push([[9333],{1874:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"Authentication-In-Next/UI-considerations","title":"UI Considerations","description":"UI Considerations","source":"@site/docs/Authentication-In-Next/UI-considerations.md","sourceDirName":"Authentication-In-Next","slug":"/Authentication-In-Next/UI-considerations","permalink":"/WebProgrammingForAppsAndServices/Authentication-In-Next/UI-considerations","draft":false,"unlisted":false,"editUrl":"https://github.com/catherine-leung/OERTemplate/tree/main/docs/Authentication-In-Next/UI-considerations.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"UI-considerations","title":"UI Considerations","sidebar_position":2,"description":"UI Considerations"},"sidebar":"courseNotesSidebar","previous":{"title":"Authentication (Logging In)","permalink":"/WebProgrammingForAppsAndServices/Authentication-In-Next/authentication-logging-in"},"next":{"title":"Example Code","permalink":"/WebProgrammingForAppsAndServices/Authentication-In-Next/example-code"}}');var o=t(4848),r=t(8453);const a={id:"UI-considerations",title:"UI Considerations",sidebar_position:2,description:"UI Considerations"},s="UI Considerations",c={},h=[{value:"Creating a &quot;Route Guard&quot; Component",id:"creating-a-route-guard-component",level:2},{value:"Redirecting to &quot;/login&quot; if unauthenticated",id:"redirecting-to-login-if-unauthenticated",level:3},{value:"authCheck() Function",id:"authcheck-function",level:4},{value:"invoking authCheck()",id:"invoking-authcheck",level:4},{value:"Adding Authentication &amp; Redirection",id:"adding-authentication--redirection",level:4},{value:"Updating the Navigation Component",id:"updating-the-navigation-component",level:2},{value:"Updating the JSX",id:"updating-the-jsx",level:3}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"ui-considerations",children:"UI Considerations"})}),"\n",(0,o.jsx)(n.p,{children:'Continuing with the example for this topic ("simple-UI"); we have seen that our "vehicles" page is finally capable of rendering the data after acquiring the JWT from our "simple-API-complete" server. However, there still remain a few usability concerns that must be addressed. For example, the user should not be permitted to access the \u201cvehicles\u201d page without being authenticated. What if there is sensitive static information visible on this page? Also, does it make sense to allow an unauthenticated user to visit a view, if they\u2019re guaranteed to not see any data? if It would be better for usability and security, if we did not enable the user to navigate to that route, unless they are authenticated.'}),"\n",(0,o.jsx)(n.p,{children:'Additionally, it\'s common practice for the UI to show some indication that the user has logged in. This may include showing their user name / avatar somewhere prominent on the site (ie: the navbar) as well as allowing them to "log out".'}),"\n",(0,o.jsx)(n.h2,{id:"creating-a-route-guard-component",children:'Creating a "Route Guard" Component'}),"\n",(0,o.jsxs)(n.p,{children:['To address the first issue (unauthorized access to the "vehicles" page), we will create a component that functions in a similar way to "Layout", in that it will be placed in App (_app.js) and "wrap" ',(0,o.jsx)(n.code,{children:"<Component {...pageProps} />"}),'. The purpose of this component is to only render "props.children" if the user has been authenticated and is allowed to view the requested route.']}),"\n",(0,o.jsx)(n.p,{children:'To begin, create a new component in the "components" folder called: "RouteGuard" and add it to _app.js'}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"File:"}),' "/components/RouteGuard.js"']}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"export default function RouteGuard(props) {\n  return <>{props.children}</>\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"File:"}),' "/pages/_app.js"']}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"import 'bootstrap/dist/css/bootstrap.min.css';\nimport Layout from '@/components/Layout';\nimport RouteGuard from '@/components/RouteGuard';\n\nexport default function App({ Component, pageProps }) {\n  return <RouteGuard><Layout><Component {...pageProps} /></Layout></RouteGuard>\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"At the moment, this will not have any effect. However, with the component correctly positioned within our app, we can discuss how we can correctly add the desired functionality to the guard."}),"\n",(0,o.jsx)(n.h3,{id:"redirecting-to-login-if-unauthenticated",children:'Redirecting to "/login" if unauthenticated'}),"\n",(0,o.jsx)(n.p,{children:'If we wish to send the user to the "/login" route if they try to access a route without being authenticated first, we need to ensure that the following logic is in place for our route guard:'}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:'Maintains a list of "public" routes, ie: "/login", "/" and "/_error" (Next.js uses the path "/_error" internally when rendering the "404 | This page could not be found" error).'}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Ability to check the url of the current (requested) route and compare it against the above list"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Check to see if the user is currently authenticated"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:'Redirect to "/login" if unauthenticated / render props.children if the user is authenticated'}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"authcheck-function",children:"authCheck() Function"}),"\n",(0,o.jsx)(n.p,{children:'To implement these requirements, we should first construct a function called "authCheck" that checks the requested route and compares it against the "public" routes.'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"const PUBLIC_PATHS = ['/login', '/', '/_error'];\n\n// ...\n\nfunction authCheck(url) {\n  const path = url.split('?')[0];\n  if (!PUBLIC_PATHS.includes(path)) {\n    console.log(`trying to request a secure path: ${path}`);\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Here, we define constant list of \"PUBLIC_PATHS\" as '/login', '/' and '/_error'. We also remove any query parameters from the url by ",(0,o.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split",children:"splitting"}),' the string at "?" and taking the first half.']}),"\n",(0,o.jsxs)(n.p,{children:["If the PUBLIC_PATHS array does not ",(0,o.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes",children:"include"})," the requested route, output a message to the console indicating that a secure path is being accessed."]}),"\n",(0,o.jsx)(n.h4,{id:"invoking-authcheck",children:"invoking authCheck()"}),"\n",(0,o.jsx)(n.p,{children:"To correctly invoke authCheck() we must execute it:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"When the component is first mounted: using the useEffect() hook"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["When a client-side route change has completed: using the 'routeChangeComplete' ",(0,o.jsx)(n.a,{href:"https://nextjs.org/docs/api-reference/next/router#routerevents",children:"router event"})]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"NOTE:"})," ",(0,o.jsx)(n.a,{href:"https://nextjs.org/docs/api-reference/next/router#routerevents",children:"Router Events"}),' in Next.js can be "subscribed" to by using the "events.on" properties of the "router" object (obtained from the useRouter() hook), for example:']}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"router.events.on('routeChangeComplete', (url) => {\n  console.log(`route change to ${url} complete!`);\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:['When no longer needed, the event can be "unsubscribed" to by using: ',(0,o.jsx)(n.code,{children:"router.evnts.off()"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"To ensure that authCheck() is correctly invoked in both of the above scenarios, we can update our RouteGuard component to use the following code:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"import { useRouter } from 'next/router';\nimport { useState, useEffect } from 'react';\n\nconst PUBLIC_PATHS = ['/login', '/', '/_error'];\n\nexport default function RouteGuard(props) {\n  const router = useRouter();\n\n  useEffect(() => {\n    // on initial load - run auth check\n    authCheck(router.pathname);\n\n    // on route change complete - run auth check\n    router.events.on('routeChangeComplete', authCheck);\n\n    // unsubscribe from events in useEffect return function\n    return () => {\n      router.events.off('routeChangeComplete', authCheck);\n    };\n  }, []);\n\n  function authCheck(url) {\n    const path = url.split('?')[0];\n    if (!PUBLIC_PATHS.includes(path)) {\n      console.log(`trying to request a secure path: ${path}`);\n    }\n  }\n\n  return <>{props.children}</>\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:['With this code in place for RouteGuard, we should see "trying to request a secure path /vehicles" if we try to refresh the "/vehicles" page ',(0,o.jsx)(n.strong,{children:"or"})," navigate to it using the navigation bar."]}),"\n",(0,o.jsx)(n.h4,{id:"adding-authentication--redirection",children:"Adding Authentication & Redirection"}),"\n",(0,o.jsxs)(n.p,{children:['To complete the RouteGuard functionality, we must implement logic to check whether or not the user is logged in. We can use this to either alow access to the requested route (by rendering "props.children"), or redirect the user back to "/login" (using ',(0,o.jsx)(n.code,{children:'router.push("/login");'}),")."]}),"\n",(0,o.jsx)(n.p,{children:'First, we should add a value in the state to store whether or not the user has been authorized to view the protected routes. We can use this to conditionally render "props.children", as described above:'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"const [authorized, setAuthorized] = useState(false);\n\n// ...\n\nreturn <>{authorized && props.children}</>\n"})}),"\n",(0,o.jsx)(n.p,{children:'Next, we must add the ability to check if a user has been authenticated and if so, set "authorized" to true, so that the route may be rendered. However, if the user has not been authenticated, we can set "authorized" to false and redirect the user back to "/login". This can be achieved by importing the "isAuthenticated()" function from our "authenticate" lib, as well as updating our "authCheck" function:'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"import { isAuthenticated } from '@/lib/authenticate';\n\n// ...\n\nfunction authCheck(url) {\n  // redirect to login page if accessing a private page and not logged in\n  const path = url.split('?')[0];\n  if (!isAuthenticated() && !PUBLIC_PATHS.includes(path)) {\n    setAuthorized(false);\n    router.push('/login');\n  } else {\n    setAuthorized(true);\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:['Here, we make sure to only redirect to "/login" if the user has not been authenticated ',(0,o.jsx)(n.strong,{children:"and"}),' they are trying to access a restricted route. If they are not authenticated and try to access an unrestricted route (ie: a route defined in "PUBLIC_PATHS"), then they should be allowed to proceed.']}),"\n",(0,o.jsx)(n.h2,{id:"updating-the-navigation-component",children:"Updating the Navigation Component"}),"\n",(0,o.jsxs)(n.p,{children:['With our Route Guard in place and successfully preventing unauthorized users from viewing the "/vehicles" page, we an concentrate on the last piece of our UI: Updating the "Navigation" Component. Here, we will show a welcome message, ie "Welcome ',(0,o.jsx)(n.strong,{children:"userName"}),'" as well as only show the "Vehicles" link if the user has logged in. Additionally, we will replace the "login" link with a "logout" link.']}),"\n",(0,o.jsx)(n.p,{children:'The first thing we must do is add the "readToken" and "removeToken" functions from our "authenticate" lib as well as "useRouter" from "next/router":'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"import { readToken, removeToken } from '@/lib/authenticate';\nimport { useRouter } from 'next/router';\n"})}),"\n",(0,o.jsx)(n.p,{children:"We will use this within the component to:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Store the current value of the token:"}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"let token = readToken();\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:'Implement a "logout" function that removes the token and redirects the user back to "/":'}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"const router = useRouter();\n\nfunction logout() {\n  removeToken();\n  router.push('/');\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"updating-the-jsx",children:"Updating the JSX"}),"\n",(0,o.jsx)(n.p,{children:'Finally, with our token in place and our logout function implemented, we can make the following changes to our JSX code for the component to conditionally render text / elements using the "token" value:'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:'return (\n  <Navbar bg="light" expand="lg">\n    <Container>\n      <Link href="/" passHref legacyBehavior><Navbar.Brand >Vehicles UI {token && <>- Welcome {token.userName}</>}</Navbar.Brand></Link>\n      <Navbar.Toggle aria-controls="basic-navbar-nav" />\n      <Navbar.Collapse id="basic-navbar-nav">\n        <Nav className="me-auto">\n          <Link href="/" passHref legacyBehavior ><Nav.Link>Home</Nav.Link></Link>\n          {token && <Link href="/vehicles" passHref legacyBehavior><Nav.Link>Vehicles</Nav.Link></Link>}\n        </Nav>\n        <Nav className="ml-auto">\n          {!token && <Link href="/login" passHref legacyBehavior><Nav.Link>Login</Nav.Link></Link>}\n          {token && <Nav.Link onClick={logout}>Logout</Nav.Link>}\n        </Nav>\n      </Navbar.Collapse>\n    </Container>\n  </Navbar>\n);\n'})}),"\n",(0,o.jsx)(n.p,{children:'Using the above code, we can ensure that once the user is logged in, they will see their user name as well as the "vehicles" and "logout" links in the navigation bar!'})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var i=t(6540);const o={},r=i.createContext(o);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);