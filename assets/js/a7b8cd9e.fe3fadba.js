"use strict";(self.webpackChunkOERTemplate=self.webpackChunkOERTemplate||[]).push([[3114],{1321:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"Managing-Application-State/shared-state-props-context","title":"Shared State with Props and Context","description":"Shared State with Props and Context","source":"@site/docs/Managing-Application-State/shared-state-props-context.md","sourceDirName":"Managing-Application-State","slug":"/Managing-Application-State/shared-state-props-context","permalink":"/WebProgrammingForAppsAndServices/Managing-Application-State/shared-state-props-context","draft":false,"unlisted":false,"editUrl":"https://github.com/catherine-leung/OERTemplate/tree/main/docs/Managing-Application-State/shared-state-props-context.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"shared-state-props-context","title":"Shared State with Props and Context","sidebar_position":1,"description":"Shared State with Props and Context"},"sidebar":"courseNotesSidebar","previous":{"title":"Example Code","permalink":"/WebProgrammingForAppsAndServices/Forms-Introduction/example-code"},"next":{"title":"Introducing Jotai","permalink":"/WebProgrammingForAppsAndServices/Managing-Application-State/introducing-jotai"}}');var s=n(4848),a=n(8453);const i={id:"shared-state-props-context",title:"Shared State with Props and Context",sidebar_position:1,description:"Shared State with Props and Context"},r="Shared State with Props & Context",p={},c=[{value:"Prop Drilling",id:"prop-drilling",level:2},{value:"Problems with Prop Drilling",id:"problems-with-prop-drilling",level:3},{value:"Context",id:"context",level:2},{value:"Problems with Context",id:"problems-with-context",level:3},{value:"Alternatives",id:"alternatives",level:2}];function l(e){const t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"shared-state-with-props--context",children:"Shared State with Props & Context"})}),"\n",(0,s.jsxs)(t.p,{children:["So far, we have discussed ",(0,s.jsx)(t.a,{href:"https://react.dev/learn/state-a-components-memory",children:'"Component State"'}),", ie: managing data / values that are associated with a specific ",(0,s.jsx)(t.em,{children:"component"}),'. These values can change over time and when this happens, the component is re-rendered to reflect the updated "state" data. It is this feature that allows us to crate dynamic components that change over time, such as our original "clock" example.']}),"\n",(0,s.jsx)(t.p,{children:'However, there are many circumstances in which the notion of "state" extends beyond an individual component. Consider a typical e-commerce site that allows users to pick and choose products to add to a "cart". Once the user is ready, they can modify the cart and / or purchase the items. In this situation, the concept of the "cart" and the items it contains must be shared by more than one component. This is because the navbar may show how many items are in the cart, or specific products may show an "added to cart" message. Additionally, the button to actually add an item to a cart would exist in a separate component from the list of items in the cart.'}),"\n",(0,s.jsx)(t.p,{children:'Essentially, what we would like to do is have the notion of an "application level" state to for the "cart" that may be used by one or more components in the "component tree" (the components used in your application / site, leading all the way back to a single component).'}),"\n",(0,s.jsx)(t.h2,{id:"prop-drilling",children:"Prop Drilling"}),"\n",(0,s.jsx)(t.p,{children:'Using what we know so far, there is a way to implement the concept of an application level state in our application / site. What we must do, is declare the state in a top-level component and pass it down from component to component via "props", so that it may be accessed by the nested component that requires it. This is informally known as "prop drilling", since we\'re "drilling" through multiple components via "props" to deliver the state to the nested component. For example, consider the following tree of components:'}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Component Tree",src:n(8939).A+"",width:"350",height:"329"})}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(t.p,{children:'In this case, both "ComponentA" and "Component1" are rendered by the "Home" component. "ComponentA" renders "ComponentB", which renders "ComponentC" and likewise, "Component1" renders "Component2", which renders "Component3".'}),"\n",(0,s.jsxs)(t.p,{children:['Now, say there\'s a button on "ComponentC" that increments a counter value by 1. We have seen this before when introducing "user events" with "onClick". However, the difference here is that the component ',(0,s.jsx)(t.em,{children:"responsible for displaying"}),' the counter value as it increases is actually "Component3", ',(0,s.jsx)(t.strong,{children:"not"}),' "ComponentC", where the button is rendered.']}),"\n",(0,s.jsxs)(t.p,{children:['To solve this, we do not declare the "count" state in "ComponentC" with the button, but instead declare it in a ',(0,s.jsx)(t.em,{children:"top level"})," component."]}),"\n",(0,s.jsxs)(t.p,{children:['You will recall from the discussion on "Layouts & Pages" that Next.js actually has a ',(0,s.jsx)(t.a,{href:"https://nextjs.org/docs/advanced-features/custom-app",children:"high-level component"}),' declared in "pages/_app.js" - this is where we placed our <layout>...</layout> component so that it will be available on all pages. This is also where we will declare our counter state and pass it to page components via props, ie:']}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"File:"}),' "/pages/_app.js"']}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsx",children:"import '@/styles/globals.css';\nimport { useState } from 'react';\n\nexport default function App({ Component, pageProps }) {\n  const [count, setCount] = useState(0); // declare high-level \"count\" state\n  return <Component {...pageProps} count={count} setCount={setCount} /> // pass it as props to the page components\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:'Here, we declare the state in "App" and ensure that it can be accessed by passing the values as props "count" and "setCount", respectfully.'}),"\n",(0,s.jsx)(t.p,{children:'Now, in the "Home" component when we render "ComponentA" and "Component1", we will continue to pass the props so that "ComponentB" and "Component2" have access, and so on. We are passing ("drilling") the state through every component via "props" until it reaches a component that requires it.'}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"File:"}),' "/pages/index.js"']}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsx",children:"<Component1 count={props.count} />\n<ComponentA setCount={props.setCount} />\n"})}),"\n",(0,s.jsx)(t.p,{children:'The "Home" component (declared in "index.js") simply passes the "count" and "setCount" properties to the appropriate components, so that in addition to rendering "Component2", "Component1" takes the "count" prop and passes it on, until it can be used by "Component3". The same is true for "ComponentA", however it takes the "setCount" prop and passes it on, until it can be used by "ComponentC".'}),"\n",(0,s.jsx)(t.p,{children:'Let\'s skip ahead and look at the final components; "ComponentC" and "Component3" to see how they make use of the "count" and "setCount" props that have been passed down to them:'}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"File:"}),' "/components/Component3.js"']}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsx",children:"export default function Component3(props) {\n  return <>Value: {props.count}</>\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"File:"}),' "/components/ComponentC.js"']}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsx",children:"export default function ComponentC(props) {\n  return <button onClick={(e) => props.setCount(n => n + 1)}>Increase Value</button>\n}\n"})}),"\n",(0,s.jsx)(t.admonition,{type:"info",children:(0,s.jsxs)(t.p,{children:["If the new state is computed using the previous state, you can ",(0,s.jsx)(t.a,{href:"https://react.dev/reference/react/useState#updating-state-based-on-the-previous-state",children:"pass a function to setState"}),", which receives the previous value."]})}),"\n",(0,s.jsx)(t.p,{children:'As you can see, "count" and "setCount" can be accessed directly from the "props" object, since it has been passed down from component to component.'}),"\n",(0,s.jsx)(t.h3,{id:"problems-with-prop-drilling",children:"Problems with Prop Drilling"}),"\n",(0,s.jsx)(t.p,{children:'Depending on the complexity of the layout / application, "prop drilling" can add extra properties to components that do not actually need them; the only reason they were passed the props, is to hand them off to their child components. This makes components harder to reuse and adds an extra dependency between components that we would like to avoid. This can also get very cumbersome if we have many application level state values to manage.'}),"\n",(0,s.jsxs)(t.p,{children:["Additionally, there is an impact on performance when using this method of passing state from component to component. Every time the state is accessed / changed in a child component, ",(0,s.jsx)(t.strong,{children:"every"}),' parent component in the "prop" chain (ie: "Home", "Component1", "Component2", "Component3", "ComponentA", "ComponentB", "ComponentC") ',(0,s.jsx)(t.strong,{children:"also"})," gets rendered."]}),"\n",(0,s.jsx)(t.h2,{id:"context",children:"Context"}),"\n",(0,s.jsxs)(t.p,{children:['As we have seen, our first approach to solving "application level" state works, but causes organizational and performance problems with our application / site. It is for these reasons that as of React 16, ',(0,s.jsx)(t.a,{href:"https://react.dev/learn/passing-data-deeply-with-context",children:'"Context"'})," was introduced:"]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:'"In a typical React application, data is passed top-down (parent to child) via props, but such usage can be cumbersome for certain types of props (e.g. locale preference, UI theme) that are required by many components within an application. Context provides a way to share values like these between components without having to explicitly pass a prop through every level of the tree."'}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:['This is certainly an improvement to "prop drilling", so let\'s implement it in our scenario above. As before, we will declare a "count" state in App, but instead of passing various "props" we will instead create ',(0,s.jsx)(t.a,{href:"https://react.dev/learn/passing-data-deeply-with-context#step-1-create-the-context",children:'"Context"'})," objects and wrap our ",(0,s.jsx)(t.code,{children:"<Component {...pageProps} />"})," with ",(0,s.jsx)(t.a,{href:"https://react.dev/learn/passing-data-deeply-with-context#step-3-provide-the-context",children:'"Provider"'})," components:"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"File:"}),' "/pages/_app.js"']}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsx",children:"import '@/styles/globals.css';\nimport { useState, createContext } from 'react';\n\nexport const CountContext = createContext();\nexport const SetCountContext = createContext();\n\nexport default function App({ Component, pageProps }) {\n  const [count, setCount] = useState(0);\n\n  return (\n    <>\n      <CountContext.Provider value={count}>\n        <SetCountContext.Provider value={setCount}>\n          <Component {...pageProps} />\n        </SetCountContext.Provider>\n      </CountContext.Provider>\n    </>\n  );\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:['Notice how we create and export a new "Context" object for every value that we wish to make "global" to our application (ie: accessible by deeply nested components, such as "Component3" and "ComponentC"). We then wrap our ',(0,s.jsx)(t.code,{children:"<Component {...pageProps} />"}),' with the associated "Provider" components with a "value" prop, to make the context values available to child components (pages).']}),"\n",(0,s.jsxs)(t.p,{children:['This eliminates the need for "prop drilling", so we do not need to update any components ',(0,s.jsx)(t.em,{children:"except"}),' the components that must make use of the context, ie: "Component3" and "ComponentC":']}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"File:"}),' "/components/Component3.js"']}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsx",children:"import { useContext } from 'react';\nimport { CountContext } from '@/pages/_app';\n\nexport default function Component3() {\n  const count = useContext(CountContext);\n  return <>Value: {count}</>\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"File:"}),' "/components/ComponentC.js"']}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsx",children:"import { useContext } from 'react';\nimport { SetCountContext } from '@/pages/_app';\n\nexport default function ComponentC() {\n  const setCount = useContext(SetCountContext);\n  return <button onClick={(e) => setCount(n => n + 1)}>Increase Value</button>;\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:'For both functions, we must import "useContext" from \'react\', as well as the specific "Context" object that is required by the component, ie: "CountContext" or "SetCountContext". We invoke the "useContext" function with a specific "Context" object to retrieve the value from the "Provider" component (included in "App"), which can then be used within our component.'}),"\n",(0,s.jsx)(t.h3,{id:"problems-with-context",children:"Problems with Context"}),"\n",(0,s.jsx)(t.p,{children:'Unfortunately, while this does avoid the need to pass props through unrelated components ("prop drilling"), it still suffers from some organizational and performance issues. For example, what happens when the "application state" gets complicated, causing the providers to build up? This can result in what is known as "provider hell", ie:'}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsx",children:'<AContext.Provider value={"A"}>\n  <BContext.Provider value={"B"}>\n    <CContext.Provider value={"C"}>\n      <DContext.Provider value={"D"}>\n        <EContext.Provider value={"E"}>\n          <Component {...pageProps} />\n        </AContext.Provider>\n      </BContext.Provider>\n    </CContext.Provider>\n  </DContext.Provider>\n</EContext.Provider>\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Additionally, the same performance problem exists, ie: every time the state is accessed / changed in a child component using context, ",(0,s.jsx)(t.strong,{children:"every"}),' parent component back to the "Provider" (ie: "Home", "Component1", "Component2", "Component3", "ComponentA", "ComponentB", "ComponentC") ',(0,s.jsx)(t.strong,{children:"also"})," gets rendered."]}),"\n",(0,s.jsx)(t.h2,{id:"alternatives",children:"Alternatives"}),"\n",(0,s.jsxs)(t.p,{children:["If neither of the above built-in strategies work for your specific application, don't worry; there exist ",(0,s.jsx)(t.strong,{children:"many"})," 3rd party alternatives. Some of the more popular state management libraries include:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsxs)(t.strong,{children:[(0,s.jsx)(t.a,{href:"https://redux.js.org/",children:"Redux"})," / ",(0,s.jsx)(t.a,{href:"https://redux-toolkit.js.org/",children:"Redux Toolkit"}),":"]}),' "The official, opinionated, batteries-included toolset for efficient Redux development. Includes utilities to simplify common use cases like store setup, creating reducers, immutable update logic, and more."']}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsxs)(t.strong,{children:[(0,s.jsx)(t.a,{href:"https://recoiljs.org/",children:"Recoil"}),":"]}),' "A state management library for React. Recoil works and thinks like React. Add some to your app and get fast and flexible shared state."']}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsxs)(t.strong,{children:[(0,s.jsx)(t.a,{href:"https://jotai.org/",children:"Jotai"}),":"]}),' "Jotai takes a bottom-up approach to React state management with an atomic model inspired by Recoil. One can build state by combining atoms and renders are optimized based on atom dependency. This solves the extra re-render issue of React context and eliminates the need for the memoization technique."']}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsxs)(t.strong,{children:[(0,s.jsx)(t.a,{href:"https://docs.pmnd.rs/zustand",children:"Zustand"}),":"]}),' "A small, fast and scalable bearbones state-management solution. Has a comfy api based on hooks, isn\'t boilerplatey or opinionated, but still just enough to be explicit and flux-like."']}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsxs)(t.strong,{children:[(0,s.jsx)(t.a,{href:"https://mobx.js.org/",children:"MobX"}),":"]}),' "MobX is a battle tested library that makes state management simple and scalable by transparently applying functional reactive programming (TFRP)."']}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsxs)(t.strong,{children:[(0,s.jsx)(t.a,{href:"https://hookstate.js.org/",children:"HookState"}),":"]}),' "The most straightforward, extensible and incredibly fast state management that is based on React state hook"']}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>r});var o=n(6540);const s={},a=o.createContext(s);function i(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(a.Provider,{value:t},e.children)}},8939:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/component-tree-29aa59d305e8a23ba274021e68d127cf.png"}}]);