"use strict";(self.webpackChunkOERTemplate=self.webpackChunkOERTemplate||[]).push([[3205],{523:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"Handling-Events-Rendering-Data/adding-API-data","title":"Adding API Data","description":"Adding API Data","source":"@site/docs/Handling-Events-Rendering-Data/adding-API-data.md","sourceDirName":"Handling-Events-Rendering-Data","slug":"/Handling-Events-Rendering-Data/adding-API-data","permalink":"/WebProgrammingForAppsAndServices/Handling-Events-Rendering-Data/adding-API-data","draft":false,"unlisted":false,"editUrl":"https://github.com/catherine-leung/OERTemplate/tree/main/docs/Handling-Events-Rendering-Data/adding-API-data.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"adding-API-data","title":"Adding API Data","sidebar_position":2,"description":"Adding API Data"},"sidebar":"courseNotesSidebar","previous":{"title":"Handling User Events","permalink":"/WebProgrammingForAppsAndServices/Handling-Events-Rendering-Data/handling-user-events"},"next":{"title":"Conditionally Displaying Data","permalink":"/WebProgrammingForAppsAndServices/Handling-Events-Rendering-Data/conditionally-displaying-data"}}');var o=n(4848),r=n(8453);const a={id:"adding-API-data",title:"Adding API Data",sidebar_position:2,description:"Adding API Data"},i="Adding API Data",c={},d=[{value:"Hydration",id:"hydration",level:2},{value:"Fetching API Data after Hydration",id:"fetching-api-data-after-hydration",level:2},{value:"Fetching API Data for Pre-Rendered HTML",id:"fetching-api-data-for-pre-rendered-html",level:2},{value:"Passing the staticPost prop to &quot;Post&quot;",id:"passing-the-staticpost-prop-to-post",level:3}];function h(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"adding-api-data",children:"Adding API Data"})}),"\n",(0,o.jsxs)(t.p,{children:["If you inspect the source code that is returned from the development server for a given page in Next.js, you will notice that in addition to the <script> tags that provide the functionality for the application / site, we also have parts of our components ",(0,o.jsx)(t.em,{children:"already rendered"}),' in the <body>. This is in stark contrast to other toolchains / frameworks such as "Create React App" which only contain a ',(0,o.jsx)(t.strong,{children:"single"})," element in the <body>, ie:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-html",children:'<div id="root"></div>\n'})}),"\n",(0,o.jsxs)(t.p,{children:["The bulk of the content (ie: your Components) would then be dynamically added to the body using JavaScript and the full page would be rendered. Unfortunately, this method of rendering content means that it is more difficult for search engines to index your pages and ",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Search_engine_optimization",children:"SEO (Search Engine Optimization)"})," suffers as a result. Fortunately, since we are using Next.js, this is less of a problem:"]}),"\n",(0,o.jsxs)(t.p,{children:["From the ",(0,o.jsx)(t.a,{href:"https://nextjs.org/learn/pages-router/data-fetching-pre-rendering",children:"official Next.js documentation"})]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"By default, Next.js pre-renders every page. This means that Next.js generates HTML for each page in advance, instead of having it all done by client-side JavaScript. Pre-rendering can result in better performance and SEO."}),"\n",(0,o.jsx)(t.p,{children:"Each generated HTML is associated with minimal JavaScript code necessary for that page. When a page is loaded by the browser, its JavaScript code runs and makes the page fully interactive. (This process is called hydration.)"}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"hydration",children:"Hydration"}),"\n",(0,o.jsx)(t.p,{children:'Notice how the documentation mentioned "hydration" in its description of what occurs when a page is loaded by the browser. This is not the first time that we have seen this mentioned in these notes - recall the code to initialize the "date" state for our <Clock /> component :'}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",children:"const [date, setDate] = useState(null); // Note: Never set this to unknown data obtained at run time (ie: new Date(), a random number, etc.) - see: https://nextjs.org/docs/messages/react-hydration-error\n"})}),"\n",(0,o.jsxs)(t.p,{children:['We were forced to set the initial value of "date" to "null" to avoid a potential ',(0,o.jsx)(t.a,{href:"https://nextjs.org/docs/messages/react-hydration-error",children:"hydration error"}),'. This is because the pre-rendered HTML is actually generated when the app does a new "build" (in "dev" mode, this is every time a change is made to your code). If we initialize the state to a dynamic value (ie: "new Date()"), then the page will be pre-rendered with a value that will be instantly out-of-date. When the page is then loaded at a different time, a hydration error occurs:']}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"Unhandled Runtime Error\nError: Text content does not match server-rendered HTML.\n"})}),"\n",(0,o.jsx)(t.p,{children:"This is because the pre-rendered body of the page looks something like this:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-html",children:"<p>\n  Locale: \x3c!-- --\x3e: \x3c!-- --\x3e1:43:08 PM\x3c!-- --\x3e \x3c!-- --\x3e\n</p>\n"})}),"\n",(0,o.jsx)(t.p,{children:'which instantly disagrees with the code generated on the first render, ie after "hydration" sometime later.'}),"\n",(0,o.jsxs)(t.p,{children:["You will recall that to fix this issue, we placed our code to initialize the date value within the body of the ",(0,o.jsx)(t.a,{href:"https://react.dev/reference/react/useEffect",children:'"useEffect"'})," hook's callback function:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"useEffect(() => {\n  setDate(new Date());\n}, []);\n"})}),"\n",(0,o.jsx)(t.p,{children:'The reason that this worked to solve the hydration error was because code in the callback defined in the useEffect hook only gets executed once the component is first "mounted" (ie: added to the DOM) after "hydration". It is not executed when the pre-rendered HTML is being generated. This causes the pre-rendered body of the page to look like the following:'}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-html",children:"<p>\n  Locale: \x3c!-- --\x3e: \x3c!-- --\x3e \x3c!-- --\x3e\n</p>\n"})}),"\n",(0,o.jsx)(t.p,{children:'which avoids the content mis-match when the component is rendered after "hydration".'}),"\n",(0,o.jsx)(t.h2,{id:"fetching-api-data-after-hydration",children:"Fetching API Data after Hydration"}),"\n",(0,o.jsxs)(t.p,{children:['Now that we are familiar with the concepts of "pre-rendering" and "hydration", it follows that a request for API data that must occur ',(0,o.jsx)(t.em,{children:"after"}),' hydration should be done within the "useEffect" hook as well. For example, consider the following "Post" component which fetches data from our familiar ',(0,o.jsx)(t.a,{href:"https://jsonplaceholder.typicode.com/",children:"{JSON&125; Placeholder"})," dataset:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",children:'import { useState, useEffect } from "react";\n\nexport default function Post() {\n\n  const [post, setPost] = useState();\n\n  useEffect(() => { // NOTE: The callback function must not be "async" - Results in error: TypeError: destroy is not a function\n    fetch(`https://jsonplaceholder.typicode.com/posts/1`).then(res => res.json()).then(data => {\n      setPost(data);\n    })\n  }, []);\n\n  return (\n    <>\n      <strong>User ID:</strong> {post?.userId}<br />\n      <strong>Title:</strong> {post?.title}<br />\n      <strong>Body:</strong> {post?.body}<br />\n    </>\n  )\n}\n'})}),"\n",(0,o.jsx)(t.p,{children:'This component does not set any value for "post" in the state (leaving it \'undefined\') and instead relies upon the callback function defined within "useEffect" to pull in the data and update the "post" value. This results in the pre-rendered HTML looking like the following:'}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-html",children:"<strong>User ID:</strong> \x3c!-- --\x3e<br>\n<strong>Title:</strong> \x3c!-- --\x3e<br>\n<strong>Body:</strong> \x3c!-- --\x3e<br>\n"})}),"\n",(0,o.jsx)(t.p,{children:'Once "hydration" occurs, the effect is executed and the "post" value is set (causing a render). This gives us:'}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-html",children:"<strong>User ID:</strong> \x3c!-- --\x3e1\x3c!-- --\x3e<br>\n<strong>Title:</strong> \x3c!-- --\x3esunt aut facere repellat provident occaecati excepturi optio reprehenderit\x3c!-- --\x3e<br>\n<strong>Body:</strong> \x3c!-- --\x3equia et suscipit suscipit recusandae consequuntur expedita et cum reprehenderit molestiae ut ut quas totam nostrum rerum est autem sunt rem eveniet architecto\x3c!-- --\x3e<br>\n\n"})}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"NOTE"}),': When fetching data on the client-side (as above, in the "useEffect" hook), Next.js recommends that ',(0,o.jsx)(t.a,{href:"https://swr.vercel.app/",children:(0,o.jsx)(t.strong,{children:"SWR"})}),' be used instead, as it handles "caching, revalidation, focus tracking, refetching on intervals, and more".']}),"\n",(0,o.jsx)(t.p,{children:"Using SWR, the above component would look like:"}),"\n"]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",children:"import useSWR from 'swr';\n\n// define the \"fetcher\" function.  This Can also be defined globally using SWRConfig (https://swr.vercel.app/docs/global-configuration)\nconst fetcher = (url) => fetch(url).then((res) => res.json()); \n\nexport default function Post() {\n  const { data, error } = useSWR('https://jsonplaceholder.typicode.com/posts/1', fetcher);\n\n  return (\n    <>\n      <strong>User ID:</strong> {data?.userId}<br />\n      <strong>Title:</strong> {data?.title}<br />\n      <strong>Body:</strong> {data?.body}<br />\n    </>\n  );\n}\n"})}),"\n"]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:["For more information on using SWR, refer to the ",(0,o.jsx)(t.a,{href:"https://swr.vercel.app/docs/getting-started",children:"official SWR documentation"}),"."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"fetching-api-data-for-pre-rendered-html",children:"Fetching API Data for Pre-Rendered HTML"}),"\n",(0,o.jsx)(t.p,{children:"If the data that is coming back from the API is not likely to change, we may wish to include it in the pre-rendered HTML to speed up load times and provide greater SEO."}),"\n",(0,o.jsxs)(t.p,{children:["Next.js provides this functionality via a mechanism called ",(0,o.jsx)(t.a,{href:"https://nextjs.org/docs/basic-features/data-fetching/get-static-props",children:"getStaticProps"}),'. This is essentially a function that Next.js runs on the server when the app is built in order to obtain data required to pre-render your pages. From our point of view, it is a function that we can export from any "page" component to provide data to any components on that page via "props".']}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Warning:"})," This will ",(0,o.jsx)(t.em,{children:"not work"}),' with custom components defined within the "components" folder.']}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:['At the moment, we really only have one "page" component - the <Home /> component declared in ',(0,o.jsx)(t.strong,{children:"index.html"}),". It should contain the <Post /> component, ie:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",children:"import Post from '@/components/Post';\n\nexport default function Home() {\n  return (\n    <>\n      <Post />\n    </>\n  );\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:'if we wish to have the data for the <Post /> component fetched at build time, we must make use of the "asynchronous" getStaticProps() function in this file, ie:'}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",children:"import Post from '@/components/Post';\n\n// This function gets called at build time\nexport function getStaticProps() {\n  // Call an external API endpoint to get posts\n  return new Promise((resolve,reject)=>{\n    fetch('https://jsonplaceholder.typicode.com/posts/1').then(res=>res.json()).then(data=>{\n      resolve({ props: { staticPost: data } })\n    })\n  })\n}\n\nexport default function Home(props) {\n  console.log(props); // props.staticPost should contain our data\n  return (\n    <>\n      <Post />\n    </>\n  );\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:['Here, we have exported an extra function above our "Home" component definition. The purpose of this function is to provide the exported page component (ie: ',(0,o.jsx)(t.strong,{children:'"Home"'}),", in this case) with additional props that contain data to be pre-rendered by the component and/or the child components. The function always returns a promise which resolves with an object that contains one of the following properties:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.a,{href:"https://nextjs.org/docs/api-reference/data-fetching/get-static-props#props",children:(0,o.jsx)(t.strong,{children:"props"})}),': "a key-value pair, where each value is received by the page component. It should be a serializable object so that any props passed, could be serialized with JSON.stringify."']}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.a,{href:"https://nextjs.org/docs/api-reference/data-fetching/get-static-props#redirect",children:(0,o.jsx)(t.strong,{children:"redirect"})}),': "The redirect object allows redirecting to internal or external resources. It should match the shape of ',(0,o.jsx)(t.code,{children:"{ destination: string, permanent: boolean }."})]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.a,{href:"https://nextjs.org/docs/api-reference/data-fetching/get-static-props#notfound",children:(0,o.jsx)(t.strong,{children:"notfound"})}),': "allows the page to return a 404 status and 404 Page. With notFound: true, the page will return a 404 even if there was a successfully generated page before. This is meant to support use cases like user-generated content getting removed by its author."']}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"NOTE"}),': an optional "',(0,o.jsx)(t.a,{href:"https://nextjs.org/docs/api-reference/data-fetching/get-static-props#revalidate",children:"revalidate"}),'" is also available, which allows you to update static pages after you\u2019ve built your site. See: ',(0,o.jsx)(t.a,{href:"https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration",children:"Incremental Static Regeneration (ISR)"})," for more information"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["Finally, since this function always returns a promise is often written using the ",(0,o.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function",children:"async / await"})," syntax, ie:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",children:"// This function gets called at build time\nexport async function getStaticProps() {\n  // Call an external API endpoint to get posts\n  const res = await fetch('https://jsonplaceholder.typicode.com/posts/1');\n  const data = await res.json();\n\n  return { props: { staticPost: data } };\n}\n"})}),"\n",(0,o.jsx)(t.h3,{id:"passing-the-staticpost-prop-to-post",children:'Passing the staticPost prop to "Post"'}),"\n",(0,o.jsx)(t.p,{children:'Now that we know we can fetch data at build time for "page" components, the final step is to refactor any components contained on the page that use that data to accept it as a property (props). In our case, this is the <Post /> component. At the moment, it is in charge of fetching its own data on demand at runtime (per request) by placing the "fetch" code within the "useEffect" callback:'}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",children:'import { useState, useEffect } from "react";\n\nexport default function Post() {\n\n  const [post, setPost] = useState();\n\n  useEffect(() => {\n    fetch(`https://jsonplaceholder.typicode.com/posts/1`).then(res => res.json()).then(data => {\n      setPost(data);\n    })\n  }, []);\n\n  return (\n    <>\n      <strong>User ID:</strong> {post?.userId}<br />\n      <strong>Title:</strong> {post?.title}<br />\n      <strong>Body:</strong> {post?.body}<br />\n    </>\n  )\n}\n'})}),"\n",(0,o.jsx)(t.p,{children:'since we know that the same data is available in the parent component, we can refactor this code to use "props" instead:'}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",children:"export default function Post(props) {\n  return (\n    <>\n      <strong>User ID:</strong> {props.post?.userId}<br />\n      <strong>Title:</strong> {props.post?.title}<br />\n      <strong>Body:</strong> {props.post?.body}<br />\n    </>\n  )\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:'Finally, we must ensure that the <Post /> component actually receives the props from the parent "page" component:'}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",children:"export default function Home(props) {\n  return (\n    <>\n      <Post post={props.staticPost} />\n    </>\n  );\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:"Now, if you try viewing the component again you should see the data as before, however now the pre-rendered content of the page contains the data:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-html",children:"<strong>User ID:</strong> \x3c!-- --\x3e1\x3c!-- --\x3e<br>\n<strong>Title:</strong> \x3c!-- --\x3esunt aut facere repellat provident occaecati excepturi optio reprehenderit\x3c!-- --\x3e<br>\n<strong>Body:</strong> \x3c!-- --\x3equia et suscipit suscipit recusandae consequuntur expedita et cum reprehenderit molestiae ut ut quas totam nostrum rerum est autem sunt rem eveniet architecto\x3c!-- --\x3e<br>\n"})})]})}function l(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>i});var s=n(6540);const o={},r=s.createContext(o);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);